<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Johan Hidding" />
  <title>Advent of Code 2021</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      { color: #cccccc; background-color: #332244; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ffcfaf; } /* Alert */
    code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
    code span.at { } /* Attribute */
    code span.bn { color: #dca3a3; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #f0dfaf; } /* ControlFlow */
    code span.ch { color: #dca3a3; } /* Char */
    code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
    code span.co { color: #7f9f7f; } /* Comment */
    code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
    code span.do { color: #7f9f7f; } /* Documentation */
    code span.dt { color: #dfdfbf; } /* DataType */
    code span.dv { color: #dcdccc; } /* DecVal */
    code span.er { color: #c3bf9f; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #c0bed1; } /* Float */
    code span.fu { color: #efef8f; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
    code span.kw { color: #f0dfaf; } /* Keyword */
    code span.op { color: #f0efd0; } /* Operator */
    code span.ot { color: #efef8f; } /* Other */
    code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
    code span.sc { color: #dca3a3; } /* SpecialChar */
    code span.ss { color: #cc9393; } /* SpecialString */
    code span.st { color: #cc9393; } /* String */
    code span.va { } /* Variable */
    code span.vs { color: #cc9393; } /* VerbatimString */
    code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
  </style>
  <link rel="stylesheet" href="dark.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Advent of Code 2021</h1>
<p class="subtitle">solutions, literally in Haskell</p>
<p class="author">Johan Hidding</p>
</header>
<div class="row">
        <div class="col-6 col-s-9" id="main">
<p><a href="https://entangled.github.io/"><img src="https://img.shields.io/badge/entangled-Use%20the%20source!-%2300aeff" alt="Entangled badge" /></a> <a href="https://github.com/jhidding/aoc2021/"><img src="https://img.shields.io/badge/github-clone%20me-%44ee55ff" alt="Github badge" /></a></p>
<section id="advent-of-code-2021" class="level1">
<h1>Advent of Code 2021</h1>
<p>This year I will publish my solutions for Advent of Code in Haskell, using Entangled to do <strong>Literate Programming</strong>.</p>
<section id="advent-of-code" class="level2">
<h2>Advent of Code</h2>
<p><a href="https://www.adventofcode.com">Advent of Code</a> is an anual coding challenge keeping nerds off the street for the entire merry month of decemeber. This is officially the best way to learn a new programming language or improve on your existing skills.</p>
<div class="warning">
<blockquote>
<h3 id="spoiler-warning">Spoiler warning</h3>
<p>If you’re still trying to solve AOC2021, this site contains spoilers.</p>
</blockquote>
</div>
</section>
<section id="entangled" class="level2">
<h2>Entangled</h2>
<p><a href="https://entangled.github.io">Entangled</a> is a tool for Literate Programming. My challenge for this years’ Advent of Code is to create a set of beautifull solutions, that are completely documented in a literate form. The idea is that the code you see here is the complete solution to a problem. Think of Entangled as a content-management system for code blocks in your Markdown documents. The code blocks are assembled into compilable code, while changes are also tracked back to your markdown files. This means you can still debug and work with your favourite IDE.</p>
</section>
<section id="instructions" class="level2">
<h2>Instructions</h2>
<p>To run this code, I recommend installing Haskell using the <a href="https://www.haskell.org/ghcup/">GHCUp installer</a>. Run all solutions:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">cabal</span> run x2021 <span class="at">--</span> <span class="at">-a</span></span></code></pre></div>
</section>
<section id="generic-remarks" class="level2">
<h2>Generic remarks</h2>
<p>All solutions use the <code>RIO</code> library to replace the standard <code>Prelude</code>. This saves a long list of standard imports and is much better suited to modern Haskell practices. Most of the input parsing is done through <code>Megaparsec</code>, for which I have a submodule that contains some common types and functions, see the <a href="#appendix-boiler-plate">boilerplate section</a>.</p>
</section>
<section id="license" class="level2">
<h2>License</h2>
<p>This code is licensed under the Apache v2 license, see <code>LICENSE</code> file in this repository.</p>
</section>
</section>
<section id="day-1-sonar-sweep" class="level1">
<h1>Day 1: Sonar Sweep</h1>
<p>It seems we are going on a deep dive this year! We are given the height data of a sonar sweep of the bottom of the sea.</p>
<div class="named-code-block">
<p>file:app/Day01.hs</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day01</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> m [<span class="dt">Int</span>]</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    text <span class="ot">&lt;-</span> Text.lines <span class="op">&lt;$&gt;</span> readFileUtf8 <span class="st">&quot;data/day01.txt&quot;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="op">$</span> mapMaybe (readMaybe <span class="op">.</span> Text.unpack) text</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">1</span><span class="op">&gt;&gt;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p><img src="fig/day01.svg" title="My input data" class="figure" alt="My input data" /></p>
<p>The question is: how often do we find this sequence ascending? We may solve this by computing the difference between each consecutive element in the input list. Then we need to know the number of possitive numbers in the difference list:</p>
<div class="named-code-block">
<p>«solution-day-1»</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>solutionA <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> (<span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">.</span> diff</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> diff (a1<span class="op">:</span>a2<span class="op">:</span>as) <span class="ot">=</span> a2 <span class="op">-</span> a1 <span class="op">:</span> diff (a2<span class="op">:</span>as)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>          diff _          <span class="ot">=</span> []</span></code></pre></div>
</div>
<p>In the second part we need to do a sliding sum over the list of input numbers, reducing the problem to that of part A:</p>
<div class="named-code-block">
<p>«solution-day-1»</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>solutionB <span class="ot">=</span> solutionA <span class="op">.</span> slidingSum</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> slidingSum (a1<span class="op">:</span>a2<span class="op">:</span>a3<span class="op">:</span>as) <span class="ot">=</span> a1 <span class="op">+</span> a2 <span class="op">+</span> a3 <span class="op">:</span> slidingSum (a2<span class="op">:</span>a3<span class="op">:</span>as)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>          slidingSum _             <span class="ot">=</span> []</span></code></pre></div>
</div>
<p>In hindsight, a more efficient solution would be:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>solutionB <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> (<span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">.</span> diff3</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> diff3 (a1<span class="op">:</span>a2<span class="op">:</span>a3<span class="op">:</span>a4<span class="op">:</span>as) <span class="ot">=</span> a4 <span class="op">-</span> a1 <span class="op">:</span> diff3 (a2<span class="op">:</span>a3<span class="op">:</span>a4<span class="op">:</span>as)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>          diff3 _                <span class="ot">=</span> []</span></code></pre></div>
<p>The middle terms in the finite difference drop out.</p>
</section>
<section id="day-2-dive" class="level1">
<h1>Day 2: Dive!</h1>
<p>We are given our first mini instruction set! We need to steer the submarine using an instruction set <code>forward</code>, <code>down</code> or <code>up</code> with a number attached. We get to do our first parsing of this year (yay!).</p>
<div class="named-code-block">
<p>file:app/Day02.hs</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day02</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (foldl)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> (readInputParsing, <span class="dt">Parser</span>, lexeme, string, integer, sepEndBy1, eol)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">2</span><span class="op">&gt;&gt;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>We start by defining a datatype and the associated parser:</p>
<div class="named-code-block">
<p>«solution-day-2»</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Instruction</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">GoForward</span> <span class="dt">Int</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">GoUp</span> <span class="dt">Int</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">GoDown</span> <span class="dt">Int</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="ot">instructions ::</span> <span class="dt">Parser</span> [<span class="dt">Instruction</span>]</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>instructions <span class="ot">=</span> sepEndBy1 (lexeme direction <span class="op">&lt;*&gt;</span> integer) eol</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> direction <span class="ot">=</span>   (string <span class="st">&quot;forward&quot;</span> <span class="op">$&gt;</span> <span class="dt">GoForward</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>                    <span class="op">&lt;|&gt;</span> (string <span class="st">&quot;up&quot;</span>      <span class="op">$&gt;</span> <span class="dt">GoUp</span>)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>                    <span class="op">&lt;|&gt;</span> (string <span class="st">&quot;down&quot;</span>    <span class="op">$&gt;</span> <span class="dt">GoDown</span>)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">MonadIO</span> m, <span class="dt">MonadReader</span> env m, <span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> m [<span class="dt">Instruction</span>]</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day02.txt&quot;</span> instructions</span></code></pre></div>
</div>
<p>In the first part, we are asked to do some Turtle movement. We can reduce the set of instructions in a <code>foldl</code> if we define a function that updates the position for each move:</p>
<div class="named-code-block">
<p>«solution-day-2»</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Pos</span> <span class="ot">=</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="ot">moveA ::</span> <span class="dt">Pos</span> <span class="ot">-&gt;</span> <span class="dt">Instruction</span> <span class="ot">-&gt;</span> <span class="dt">Pos</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>moveA (x, y) (<span class="dt">GoForward</span> dx) <span class="ot">=</span> (x <span class="op">+</span> dx, y)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>moveA (x, y) (<span class="dt">GoUp</span> dy)      <span class="ot">=</span> (x, y <span class="op">-</span> dy)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>moveA (x, y) (<span class="dt">GoDown</span> dy)    <span class="ot">=</span> (x, y <span class="op">+</span> dy)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> [<span class="dt">Instruction</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>solutionA inst <span class="ot">=</span> x <span class="op">*</span> y</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> (x, y) <span class="ot">=</span> <span class="fu">foldl</span> moveA (<span class="dv">0</span>, <span class="dv">0</span>) inst</span></code></pre></div>
</div>
<p>In the second part, the interpretation of the instructions changes slightly, but the only thing we have to change is the <code>moveA</code> function and the corresponding accumulator data type (I’m using <code>NamedFieldPuns</code> and <code>RecordWildCards</code>, which I prefer over lenses in these simple cases):</p>
<div class="named-code-block">
<p>«solution-day-2»</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Navigation</span> <span class="ot">=</span> <span class="dt">Navigation</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> navDepth ::</span> <span class="dt">Int</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> navAim   ::</span> <span class="dt">Int</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> navPos   ::</span> <span class="dt">Int</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="ot">moveB ::</span> <span class="dt">Navigation</span> <span class="ot">-&gt;</span> <span class="dt">Instruction</span> <span class="ot">-&gt;</span> <span class="dt">Navigation</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>moveB n<span class="op">@</span><span class="dt">Navigation</span>{<span class="op">..</span>} (<span class="dt">GoForward</span> x) <span class="ot">=</span> n{ navPos <span class="ot">=</span> navPos <span class="op">+</span> x</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>                                        , navDepth <span class="ot">=</span> navDepth <span class="op">+</span> navAim <span class="op">*</span> x }</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>moveB n<span class="op">@</span><span class="dt">Navigation</span>{<span class="op">..</span>} (<span class="dt">GoUp</span> x)      <span class="ot">=</span> n{ navAim <span class="ot">=</span> navAim <span class="op">-</span> x }</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>moveB n<span class="op">@</span><span class="dt">Navigation</span>{<span class="op">..</span>} (<span class="dt">GoDown</span> x)    <span class="ot">=</span> n{ navAim <span class="ot">=</span> navAim <span class="op">+</span> x }</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> [<span class="dt">Instruction</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>solutionB inst <span class="ot">=</span> navPos <span class="op">*</span> navDepth</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> <span class="dt">Navigation</span>{<span class="op">..</span>} <span class="ot">=</span> <span class="fu">foldl</span> moveB (<span class="dt">Navigation</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span>) inst</span></code></pre></div>
</div>
</section>
<section id="day-3-binary-diagnostic" class="level1">
<h1>Day 3: Binary Diagnostic</h1>
<div class="named-code-block">
<p>file:app/Day03.hs</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day03</span> <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List.Partial</span> (foldl1)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> (<span class="dt">Parser</span>, sepEndBy1, char, eol, readInputParsing)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">Vector</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Vector</span> (<span class="dt">Vector</span>)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">3</span><span class="op">&gt;&gt;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>Because of part 2 of this puzzle, I chose to put the bit sequence in a <code>Vector</code>.</p>
<div class="named-code-block">
<p>«solution-day-3»</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Bits</span> <span class="ot">=</span> <span class="dt">Vector</span> <span class="dt">Int</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ot">bitSequence ::</span> <span class="dt">Parser</span> [<span class="dt">Bits</span>]</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>bitSequence <span class="ot">=</span> sepEndBy1 bits eol</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span><span class="ot"> bits ::</span> <span class="dt">Parser</span> <span class="dt">Bits</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>          bits <span class="ot">=</span> Vector.fromList</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>               <span class="op">&lt;$&gt;</span> some (   (char <span class="ch">&#39;0&#39;</span> <span class="op">$&gt;</span> <span class="dv">0</span>)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>                        <span class="op">&lt;|&gt;</span> (char <span class="ch">&#39;1&#39;</span> <span class="op">$&gt;</span> <span class="dv">1</span>))</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env [<span class="dt">Bits</span>]</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day03.txt&quot;</span> bitSequence</span></code></pre></div>
</div>
<p>We need to compute the most common digit for each bit position. I solve this by rounding of the mean bit value.</p>
<div class="named-code-block">
<p>«solution-day-3»</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fromBinary ::</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>fromBinary <span class="ot">=</span> go <span class="dv">0</span> <span class="op">.</span> Vector.toList</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go n (b<span class="op">:</span>bs) <span class="ot">=</span> go (<span class="dv">2</span><span class="op">*</span>n <span class="op">+</span> b) bs</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>          go n []     <span class="ot">=</span> n</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="ot">invertBinary ::</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>invertBinary <span class="ot">=</span> Vector.map (<span class="dv">1</span> <span class="op">-</span>)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="ot">mostCommon ::</span> [<span class="dt">Bits</span>] <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>mostCommon b <span class="ot">=</span> Vector.map ((<span class="ot">`div`</span> <span class="fu">length</span> b) <span class="op">.</span> (<span class="op">*</span> <span class="dv">2</span>))</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>             <span class="op">$</span> <span class="fu">foldl1</span> (Vector.zipWith (<span class="op">+</span>)) b</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="ot">leastCommon ::</span> [<span class="dt">Bits</span>] <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>leastCommon <span class="ot">=</span> invertBinary <span class="op">.</span> mostCommon</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> [<span class="dt">Bits</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>solutionA input <span class="ot">=</span> gammaRate <span class="op">*</span> epsilonRate</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> gammaRate   <span class="ot">=</span> fromBinary mc</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>          epsilonRate <span class="ot">=</span> fromBinary <span class="op">$</span> invertBinary mc</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>          mc <span class="ot">=</span> mostCommon input</span></code></pre></div>
</div>
<p>In the second part we need to filter down on a single bit in each iteration. The most or least common bit value needs to be computed every time, as it changes when bit sequences are filtered out.</p>
<div class="named-code-block">
<p>«solution-day-3»</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">findRating ::</span> ([<span class="dt">Bits</span>] <span class="ot">-&gt;</span> <span class="dt">Bits</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Bits</span>] <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>findRating _ _   [b]  <span class="ot">=</span> b</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>findRating f idx bits <span class="ot">=</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    findRating f (idx <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">$</span> <span class="fu">filter</span> (\b <span class="ot">-&gt;</span> b <span class="op">Vector.!?</span> idx <span class="op">==</span> mc <span class="op">Vector.!?</span> idx) bits</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> mc <span class="ot">=</span> f bits</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="ot">oxygenGeneratorRating ::</span> [<span class="dt">Bits</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>oxygenGeneratorRating <span class="ot">=</span> fromBinary <span class="op">.</span> findRating mostCommon <span class="dv">0</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="ot">co2ScrubberRating ::</span> [<span class="dt">Bits</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>co2ScrubberRating <span class="ot">=</span> fromBinary <span class="op">.</span> findRating leastCommon <span class="dv">0</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> [<span class="dt">Bits</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>solutionB bits <span class="ot">=</span> oxygenGeneratorRating bits <span class="op">*</span> co2ScrubberRating bits</span></code></pre></div>
</div>
</section>
<section id="day-4-giant-squid" class="level1">
<h1>Day 4: Giant Squid</h1>
<p>We’re playing Bingo with a giant squid. This is why I love advent of Code!</p>
<p>Doing contrived array arithmetic is not seen as the strong suit of Haskell. Solving this in Python with NumPy would seem so much easier. I will use the nice <code>Massiv</code> library, that implements multi-dimensional arrays, fancy indexing, stencil operations etc.</p>
<div class="named-code-block">
<p>file:app/Day04.hs</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day04</span> <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span> <span class="kw">hiding</span> (try)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (partition, headMaybe, lastMaybe)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> ( <span class="dt">Parser</span>, sepEndBy1, sepBy1, char, hspace, eol</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>               , integer, lexeme, readInputParsing</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>               , failOnException )</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Massiv.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="kw">data</span><span class="op">-</span>types<span class="op">-</span>day<span class="op">-</span><span class="dv">4</span><span class="op">&gt;&gt;</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day<span class="op">-</span><span class="dv">4</span><span class="op">&gt;&gt;</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">4</span><span class="op">&gt;&gt;</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>We need to have integers that we can mark when we play Bingo. I’ll make a generic <code>Mark</code> container, that contains an extra boolean flag.</p>
<div class="named-code-block">
<p>«data-types-day-4»</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Mark</span> a <span class="ot">=</span> <span class="dt">Mark</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> marked ::</span> <span class="dt">Bool</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> markValue ::</span> a</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="ot">markEq ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Mark</span> a <span class="ot">-&gt;</span> <span class="dt">Mark</span> a</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>markEq v <span class="dt">Mark</span>{ <span class="op">..</span> }</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> v <span class="op">==</span> markValue <span class="ot">=</span> <span class="dt">Mark</span> <span class="dt">True</span>   markValue</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span>      <span class="ot">=</span> <span class="dt">Mark</span> marked markValue</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="ot">unmarked ::</span> <span class="dt">Mark</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>unmarked <span class="ot">=</span> <span class="fu">not</span> <span class="op">.</span> marked</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Board</span> <span class="ot">=</span> <span class="dt">A.Array</span> <span class="dt">A.B</span> <span class="dt">A.Ix2</span> (<span class="dt">Mark</span> <span class="dt">Int</span>)</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bingo</span> <span class="ot">=</span> <span class="dt">Bingo</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> draws ::</span> [<span class="dt">Int</span>]</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> boards ::</span> [<span class="dt">Board</span>]</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
</div>
<p>Next, we need to parse the input data.</p>
<div class="named-code-block">
<p>«parser-day-4»</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">drawsP ::</span> <span class="dt">Parser</span> [<span class="dt">Int</span>]</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>drawsP <span class="ot">=</span> sepBy1 integer (lexeme <span class="op">$</span> char <span class="ch">&#39;,&#39;</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="ot">boardP ::</span> <span class="dt">Parser</span> <span class="dt">Board</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>boardP <span class="ot">=</span> sepEndBy1 row eol <span class="op">&gt;&gt;=</span> toBoard</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> whitespace <span class="ot">=</span> lexeme (<span class="fu">return</span> ())</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>          row <span class="ot">=</span> whitespace <span class="op">&gt;&gt;</span> some (<span class="dt">Mark</span> <span class="dt">False</span> <span class="op">&lt;$&gt;</span> integer)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>          toBoard <span class="ot">=</span> failOnException <span class="op">.</span> A.fromListsM <span class="dt">A.Seq</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="ot">bingoP ::</span> <span class="dt">Parser</span> <span class="dt">Bingo</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>bingoP <span class="ot">=</span> <span class="dt">Bingo</span> <span class="op">&lt;$&gt;</span> drawsP <span class="op">&lt;*</span> eol <span class="op">&lt;*</span> eol <span class="op">&lt;*&gt;</span> sepEndBy1 boardP eol</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env <span class="dt">Bingo</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day04.txt&quot;</span> bingoP</span></code></pre></div>
</div>
<p>We win at Bingo if a row of column on a board is fully marked. The <code>Massiv</code> library provides the nice functions <code>outerSlices</code> and <code>innerSlices</code>, allowing us to traverse all rows and columns:</p>
<div class="named-code-block">
<p>«solution-day-4»</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">win ::</span> <span class="dt">Board</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>win b <span class="ot">=</span> rows <span class="op">||</span> columns</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> rows    <span class="ot">=</span> <span class="fu">any</span> (<span class="fu">all</span> marked) (A.outerSlices b)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>          columns <span class="ot">=</span> <span class="fu">any</span> (<span class="fu">all</span> marked) (A.innerSlices b)</span></code></pre></div>
</div>
<p>Each time a number is called we mark all matching values:</p>
<div class="named-code-block">
<p>«solution-day-4»</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">markBoard ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Board</span> <span class="ot">-&gt;</span> <span class="dt">Board</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>markBoard n b <span class="ot">=</span> markEq n <span class="op">&lt;$&gt;</span> b</span></code></pre></div>
</div>
<p>For part A we need to figure out, the first board to win and the last number that was called. I won’t pretend this is the first implementation I came up with. After also solving part B, it turns out this is the most elegant and generic way to do it. The function <code>winners</code> generates a list of <code>(Int, Board)</code> pairs, giving in order each board winning and on what number:</p>
<div class="named-code-block">
<p>«solution-day-4»</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">winSeq ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Board</span>] <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Board</span>)]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>winSeq []       _       <span class="ot">=</span> []</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>winSeq _        []      <span class="ot">=</span> []</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>winSeq (d<span class="op">:</span>draws) boards <span class="ot">=</span> <span class="fu">map</span> (d,) winners <span class="op">&lt;&gt;</span> winSeq draws losers</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> (winners, losers) <span class="ot">=</span> partition win <span class="op">$</span> markBoard d <span class="op">&lt;$&gt;</span> boards</span></code></pre></div>
</div>
<p>Now, to get the first winner, we can just get the <code>head</code> of the list of all winners:</p>
<div class="named-code-block">
<p>«solution-day-4»</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">score ::</span> (<span class="dt">Int</span>, <span class="dt">Board</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>score (n, b) <span class="ot">=</span> n <span class="op">*</span> <span class="fu">sum</span> (unmarkedValues <span class="op">$</span> A.toList b)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> unmarkedValues <span class="ot">=</span> <span class="fu">map</span> markValue <span class="op">.</span> <span class="fu">filter</span> unmarked</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> <span class="dt">Bingo</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>solutionA <span class="dt">Bingo</span>{<span class="op">..</span>} <span class="ot">=</span> score <span class="op">&lt;$&gt;</span> headMaybe (winSeq draws boards)</span></code></pre></div>
</div>
<p>For part B we need to know the last board to win, which is now a trivial ajustment:</p>
<div class="named-code-block">
<p>«solution-day-4»</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> <span class="dt">Bingo</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>solutionB <span class="dt">Bingo</span>{<span class="op">..</span>} <span class="ot">=</span> score <span class="op">&lt;$&gt;</span> lastMaybe (winSeq draws boards)</span></code></pre></div>
</div>
</section>
<section id="day-5-hydrothermal-venture" class="level1">
<h1>Day 5: Hydrothermal Venture</h1>
<p>We need to plot a map of hydrothermal vents on a grid. We are given lists of coordinates in the form <code>x1,y1 -&gt; x2,y2</code>. Since we are plotting on 2D grids again, I reach for my friend <code>Massiv</code>. Today, we’ll see how to program in Haskell like its Fortran 77.</p>
<div class="named-code-block">
<p>file:app/Day05.hs</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day05</span> <span class="kw">where</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span> <span class="kw">hiding</span> (try)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.ByteString</span> (putStr)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List.Partial</span> (foldl1)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (partition, headMaybe, lastMaybe)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> ( <span class="dt">Parser</span>, sepEndBy1, sepBy1, char, hspace, eol</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>               , integer, lexeme, readInputParsing</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>               , string )</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Massiv.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Massiv.Array.Mutable</span> <span class="kw">as</span> <span class="dt">MA</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="kw">data</span><span class="op">-</span>types<span class="op">-</span>day<span class="op">-</span><span class="dv">5</span><span class="op">&gt;&gt;</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day<span class="op">-</span><span class="dv">5</span><span class="op">&gt;&gt;</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">5</span><span class="op">&gt;&gt;</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>extra<span class="op">-</span>day<span class="op">-</span><span class="dv">5</span><span class="op">&gt;&gt;</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p><img src="fig/day05-input.svg" class="figure" alt="" /></p>
<p>I like to have position variables that I can treat like applicatives.</p>
<div class="named-code-block">
<p>«data-types-day-5»</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Vec2</span> a <span class="ot">=</span> <span class="dt">Vec2</span> (a, a)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Vec2</span> a) <span class="kw">where</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">show</span> (<span class="dt">Vec2</span> (x, y)) <span class="ot">=</span> <span class="st">&quot;(&quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> x <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> y <span class="op">&lt;&gt;</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Vec2</span> <span class="kw">where</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Vec2</span> (x, y)) <span class="ot">=</span> <span class="dt">Vec2</span> (f x, f y)</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Vec2</span> <span class="kw">where</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">Vec2</span> (x, x)</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    liftA2 f (<span class="dt">Vec2</span> (ax, ay)) (<span class="dt">Vec2</span> (bx, by)) <span class="ot">=</span> <span class="dt">Vec2</span> (f ax bx, f ay by)</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Pos</span> <span class="ot">=</span> <span class="dt">Vec2</span> <span class="dt">Int</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="ot">pos ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Pos</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>pos x y <span class="ot">=</span> <span class="dt">Vec2</span> (x, y)</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Line</span> <span class="ot">=</span> (<span class="dt">Pos</span>, <span class="dt">Pos</span>)</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a><span class="ot">makeLine ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Line</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>makeLine x1 y1 x2 y2 <span class="ot">=</span> (pos x1 y1, pos x2 y2)</span></code></pre></div>
</div>
<p>Now we can parse the list of lines:</p>
<div class="named-code-block">
<p>«parser-day-5»</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lineP ::</span> <span class="dt">Parser</span> <span class="dt">Line</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>lineP <span class="ot">=</span> makeLine <span class="op">&lt;$&gt;</span> integer <span class="op">&lt;*</span> lexeme (char <span class="ch">&#39;,&#39;</span>) <span class="op">&lt;*&gt;</span> integer</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>                 <span class="op">&lt;*</span>  lexeme (string <span class="st">&quot;-&gt;&quot;</span>)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>                 <span class="op">&lt;*&gt;</span> integer <span class="op">&lt;*</span> lexeme (char <span class="ch">&#39;,&#39;</span>) <span class="op">&lt;*&gt;</span> integer</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env [<span class="dt">Line</span>]</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day05.txt&quot;</span> (sepEndBy1 lineP eol)</span></code></pre></div>
</div>
<p>We need to plot the lines on a diagram. I will be using the <code>ST</code> monad to do mutations on the diagram sequentially.</p>
<div class="named-code-block">
<p>«data-types-day-5»</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Diagram</span> <span class="ot">=</span> <span class="dt">A.Array</span> <span class="dt">A.P</span> <span class="dt">A.Ix2</span> <span class="dt">Int</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">MutDiagram</span> s <span class="ot">=</span> <span class="dt">MA.MArray</span> s <span class="dt">A.P</span> <span class="dt">A.Ix2</span> <span class="dt">Int</span></span></code></pre></div>
</div>
<p>We need to know the min/max coordinates of the lines.</p>
<div class="named-code-block">
<p>«solution-day-5»</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lineMinMax ::</span> <span class="dt">Line</span> <span class="ot">-&gt;</span> (<span class="dt">Pos</span>, <span class="dt">Pos</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>lineMinMax (a, b) <span class="ot">=</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> a <span class="op">&lt;*&gt;</span> b, <span class="fu">max</span> <span class="op">&lt;$&gt;</span> a <span class="op">&lt;*&gt;</span> b)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="ot">totalMinMax ::</span> [<span class="dt">Line</span>] <span class="ot">-&gt;</span> (<span class="dt">Pos</span>, <span class="dt">Pos</span>)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>totalMinMax ls <span class="ot">=</span> <span class="fu">foldl1</span> minMax <span class="op">$</span> lineMinMax <span class="op">&lt;$&gt;</span> ls</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> minMax (a, b) (c, d) <span class="ot">=</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> a <span class="op">&lt;*&gt;</span> c, <span class="fu">max</span> <span class="op">&lt;$&gt;</span> b <span class="op">&lt;*&gt;</span> d)</span></code></pre></div>
</div>
<section id="part-a" class="level3">
<h3>Part A</h3>
<p>In part A, we only need to treat the lines that are vertical or horizontal. We can write a routine that plots the line on the diagram, given a list of coordinates:</p>
<div class="named-code-block">
<p>«solution-day-5»</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">plotCoords ::</span> <span class="dt">MutDiagram</span> s <span class="ot">-&gt;</span> [<span class="dt">A.Ix2</span>] <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>plotCoords d <span class="ot">=</span> <span class="fu">mapM_</span> (MA.modify_ d (<span class="fu">return</span> <span class="op">.</span> (<span class="op">+</span> <span class="dv">1</span>)))</span></code></pre></div>
</div>
<p>Now we need to generate the list of coordinates, taking care that origin and end point can be flipped. I make a generic function that splits on several cases:</p>
<div class="named-code-block">
<p>«solution-day-5»</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">range</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="fu">range</span> a b</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a <span class="op">&gt;</span> b <span class="ot">=</span> <span class="fu">reverse</span> [b <span class="op">..</span> a]</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> [a <span class="op">..</span> b]</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="ot">lineCoords ::</span> <span class="dt">Line</span> <span class="ot">-&gt;</span> [<span class="dt">A.Ix2</span>]</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>lineCoords l</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>day<span class="op">-</span><span class="dv">5</span><span class="op">-</span>line<span class="op">-</span>cases<span class="op">&gt;&gt;</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;Illegal line: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> l</span></code></pre></div>
</div>
<section id="horizontal" class="level4">
<h4>Horizontal</h4>
<div class="named-code-block">
<p>«day-5-line-cases»</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> horizontal l <span class="ot">=</span> horizontalCoords l</span></code></pre></div>
</div>
<div class="named-code-block">
<p>«solution-day-5»</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">horizontal ::</span> <span class="dt">Line</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>horizontal (<span class="dt">Vec2</span> (_, ay), <span class="dt">Vec2</span> (_, by)) <span class="ot">=</span> ay <span class="op">==</span> by</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="ot">horizontalCoords ::</span> <span class="dt">Line</span> <span class="ot">-&gt;</span> [<span class="dt">A.Ix2</span>]</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>horizontalCoords (<span class="dt">Vec2</span> (ax, y), <span class="dt">Vec2</span> (bx, _))</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> A.toIx2 <span class="op">.</span> (,y) <span class="op">&lt;$&gt;</span> <span class="fu">range</span> ax bx</span></code></pre></div>
</div>
</section>
<section id="vertical" class="level4">
<h4>Vertical</h4>
<div class="named-code-block">
<p>«day-5-line-cases»</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> vertical l <span class="ot">=</span> verticalCoords l</span></code></pre></div>
</div>
<div class="named-code-block">
<p>«solution-day-5»</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">vertical ::</span> <span class="dt">Line</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>vertical (<span class="dt">Vec2</span> (ax, _), <span class="dt">Vec2</span> (bx, _)) <span class="ot">=</span> ax <span class="op">==</span> bx</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="ot">verticalCoords ::</span> <span class="dt">Line</span> <span class="ot">-&gt;</span> [<span class="dt">A.Ix2</span>]</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>verticalCoords (<span class="dt">Vec2</span> (x, ay), <span class="dt">Vec2</span> (_, by))</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> A.toIx2 <span class="op">.</span> (x,) <span class="op">&lt;$&gt;</span> <span class="fu">range</span> ay by</span></code></pre></div>
</div>
<p>Now, for the solution:</p>
<div class="named-code-block">
<p>«solution-day-5»</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ot">plotLines ::</span> [<span class="dt">Line</span>] <span class="ot">-&gt;</span> <span class="dt">Diagram</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>plotLines l <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    arr <span class="ot">&lt;-</span> MA.newMArray (<span class="dt">A.Sz2</span> <span class="dv">1000</span> <span class="dv">1000</span>) <span class="dv">0</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mapM_</span> (plotCoords arr <span class="op">.</span> lineCoords) l</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    MA.freezeS arr</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> [<span class="dt">Line</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>solutionA <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> (<span class="op">&gt;</span> <span class="dv">1</span>) <span class="op">.</span> A.toList </span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>          <span class="op">.</span> plotLines <span class="op">.</span> <span class="fu">filter</span> (<span class="fu">not</span> <span class="op">.</span> diagonal)</span></code></pre></div>
</div>
</section>
</section>
<section id="part-b" class="level3">
<h3>Part B</h3>
<p>Adding the case of diagonal lines:</p>
<div class="named-code-block">
<p>«day-5-line-cases»</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> diagonal l <span class="ot">=</span> diagonalCoords l</span></code></pre></div>
</div>
<div class="named-code-block">
<p>«solution-day-5»</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="ot">diagonal ::</span> <span class="dt">Line</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>diagonal (<span class="dt">Vec2</span> (ax, ay), <span class="dt">Vec2</span> (bx, by))</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="fu">abs</span> (ax <span class="op">-</span> bx) <span class="op">==</span> <span class="fu">abs</span> (ay <span class="op">-</span> by)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="ot">diagonalCoords ::</span> <span class="dt">Line</span> <span class="ot">-&gt;</span> [<span class="dt">A.Ix2</span>]</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>diagonalCoords (<span class="dt">Vec2</span> (ax, ay), <span class="dt">Vec2</span> (bx, by))</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> A.toIx2 <span class="op">&lt;$&gt;</span> <span class="fu">zip</span> (<span class="fu">range</span> ax bx) (<span class="fu">range</span> ay by)</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> [<span class="dt">Line</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>solutionB <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> (<span class="op">&gt;</span> <span class="dv">1</span>) <span class="op">.</span> A.toList <span class="op">.</span> plotLines</span></code></pre></div>
</div>
<p><img src="fig/day05-output.svg" class="figure" alt="" /></p>
</section>
</section>
<section id="day-6-lanternfish" class="level1">
<h1>Day 6: Lanternfish</h1>
<p>We need to simulate the number of lanternfish, each with a timer, spawning new lanternfish etc. Since we have an exponential growth process, to simulate this naively would be stupid, which is kind of the point of the exercise. We only have nine possible states for each fish, so instead we can tally <strong>how many</strong> lanternfish exist in each state. It turns out however, that programming it the stupid way first, turns this innocent looking exercise into a nice lesson on <strong>Constraint Kinds</strong>.</p>
<div class="named-code-block">
<p>file:app/Day06.hs</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day06</span> <span class="kw">where</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (foldl)</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List.Partial</span> (last)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> ( <span class="dt">Parser</span>, readInputParsing, sepEndBy1</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>               , lexeme, char, integer)</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.Map</span> (<span class="dt">Map</span>, (!?))</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Constraint</span> (<span class="dt">Constraint</span>)</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day<span class="op">-</span><span class="dv">6</span><span class="op">&gt;&gt;</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">6</span><span class="op">&gt;&gt;</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>As always, we first parse the input:</p>
<div class="named-code-block">
<p>«parser-day-6»</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="ot">csvInts ::</span> <span class="dt">Parser</span> [<span class="dt">Int</span>]</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>csvInts <span class="ot">=</span> sepEndBy1 integer (lexeme (char <span class="ch">&#39;,&#39;</span>))</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env [<span class="dt">Int</span>]</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day06.txt&quot;</span> csvInts</span></code></pre></div>
</div>
<p>The point of the exercise is that we can have a naive solution, which I implement here just for fun:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rules ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>rules clock</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> clock <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> [<span class="dv">8</span>, <span class="dv">6</span>]</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span>  <span class="ot">=</span> [clock <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="ot">step ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>step <span class="ot">=</span> (<span class="op">&gt;&gt;=</span> rules)</span></code></pre></div>
<p>We then iterate the <code>step</code> any number of times and get the length of the result:</p>
<div class="named-code-block">
<p>«solution-day-6»</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">iterate</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="fu">iterate</span> n f x</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> n <span class="op">==</span> <span class="dv">0</span>    <span class="ot">=</span> [x]</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> x <span class="op">:</span> <span class="fu">iterate</span> (n <span class="op">-</span> <span class="dv">1</span>) f (f x)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>solutionA <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">last</span> <span class="op">.</span> <span class="fu">iterate</span> <span class="dv">80</span> step</span></code></pre></div>
</div>
<p>The problem is that this solution doesn’t scale very well. To solve this more efficiently, we should keep track of how many fish are present in each state, then we can solve this problem in constant memory.</p>
<p>For tallying the amount of lanternfish in each state, I like to use a <code>Map Int Int</code>.</p>
<div class="named-code-block">
<p>«solution-day-6»</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Tally</span> a <span class="ot">=</span> <span class="dt">Tally</span> {<span class="ot"> tallyMap ::</span> <span class="dt">Map</span> a <span class="dt">Int</span> }</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
</div>
<p>Now we can implement <code>Semigroup</code> and <code>Monoid</code>:</p>
<div class="named-code-block">
<p>«solution-day-6»</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Tally</span> a) <span class="kw">where</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Tally</span> a <span class="op">&lt;&gt;</span> <span class="dt">Tally</span> b <span class="ot">=</span> <span class="dt">Tally</span> <span class="op">$</span> Map.unionWith (<span class="op">+</span>) a b</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Tally</span> a) <span class="kw">where</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Tally</span> <span class="fu">mempty</span></span></code></pre></div>
</div>
<p>Now we could do something like,</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="ot">multiply ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tally</span> a</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>multiply items n <span class="ot">=</span> <span class="fu">foldMap</span> (\k <span class="ot">-&gt;</span> <span class="dt">Tally</span> <span class="op">$</span> Map.singleton k n) items</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="fu">concatMap</span><span class="ot"> ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> <span class="dt">Tally</span> a <span class="ot">-&gt;</span> <span class="dt">Tally</span> a</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="fu">concatMap</span> f (<span class="dt">Tally</span> a) <span class="ot">=</span> Map.foldMapWithKey (multiply <span class="op">.</span> f) a</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="ot">step ::</span> <span class="dt">Tally</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tally</span> <span class="dt">Int</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>step <span class="ot">=</span> <span class="fu">concatMap</span> rules</span></code></pre></div>
<p>However, things could be even pretier if we could define something like <code>Applicative</code> on <code>Tally</code>.</p>
<section id="associated-constraint-types" class="level2">
<h2>Associated Constraint Types</h2>
<p>What if we could implement the naive version of this problem in such a way that we can easily scale it up later? We could say:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rules ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Semigroup</span> (f <span class="dt">Int</span>)) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> f <span class="dt">Int</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>rules clock</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> clock <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="fu">pure</span> <span class="dv">8</span> <span class="op">&lt;&gt;</span> <span class="fu">pure</span> <span class="dv">6</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span>  <span class="ot">=</span> <span class="fu">pure</span> (clock <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>But this comes with another problem: our intended container <code>Tally</code> can never be a <code>Functor</code> or <code>Applicative</code>, since it only works on sortable <code>Ord</code> types. This kind of problem can only be solved if we are allowed associated constraint types with our class implementation. For this to work you need to enable the <code>TypeFamilies</code> and <code>ConstraintKinds</code> language extensions enabled.</p>
<p>We have to reimplement the <code>Functor &gt; Applicative &gt; Monad</code> stack.</p>
<div class="named-code-block">
<p>«solution-day-6»</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">CFunctor</span> f <span class="kw">where</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">ElemCt</span> f<span class="ot"> a ::</span> <span class="dt">Constraint</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    cmap ::</span> (<span class="dt">ElemCt</span> f a, <span class="dt">ElemCt</span> f b) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">CFunctor</span> f <span class="ot">=&gt;</span> <span class="dt">CApplicative</span> f <span class="kw">where</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    cpure ::</span> (<span class="dt">ElemCt</span> f a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    cliftA2 ::</span> (<span class="dt">ElemCt</span> f a, <span class="dt">ElemCt</span> f b, <span class="dt">ElemCt</span> f c)</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>            <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</span></code></pre></div>
</div>
<p>It is already impossible to implement the constraint version of <code>&lt;*&gt;</code> from the type signature. The default implementation of <code>cliftA2 id</code> assumes <code>ElemCt f (b -&gt; c)</code> which we can never guarantee. There is no problem however defining <code>CMonad</code>.</p>
<div class="named-code-block">
<p>«solution-day-6»</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">CApplicative</span> f <span class="ot">=&gt;</span> <span class="dt">CMonad</span> f <span class="kw">where</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    cbind ::</span> (<span class="dt">ElemCt</span> f a, <span class="dt">ElemCt</span> f b) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
</div>
<p>With these type classes in place, we can rewrite the solution to todays problem once again:</p>
<div class="named-code-block">
<p>«solution-day-6»</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rules ::</span> (<span class="dt">CApplicative</span> f, <span class="dt">ElemCt</span> f <span class="dt">Int</span>, <span class="dt">Semigroup</span> (f <span class="dt">Int</span>)) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> f <span class="dt">Int</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>rules fish</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> fish <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> cpure <span class="dv">8</span> <span class="op">&lt;&gt;</span> cpure <span class="dv">6</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> cpure (fish <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="ot">step ::</span> (<span class="dt">CMonad</span> f, <span class="dt">ElemCt</span> f <span class="dt">Int</span>, <span class="dt">Semigroup</span> (f <span class="dt">Int</span>)) <span class="ot">=&gt;</span> f <span class="dt">Int</span> <span class="ot">-&gt;</span> f <span class="dt">Int</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>step <span class="ot">=</span> cbind rules</span></code></pre></div>
</div>
<section id="implementation-for-list" class="level3">
<h3>Implementation for List</h3>
<p>There is the little annoyance that we need to be able to signal an <code>Empty</code> constraint:</p>
<div class="named-code-block">
<p>«solution-day-6»</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">EmptyCt</span> a</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">EmptyCt</span> a</span></code></pre></div>
</div>
<p>We now need to implement <code>CMonad</code> on lists and we should have our first naive implementation back in working order.</p>
<div class="named-code-block">
<p>«solution-day-6»</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">CFunctor</span> [] <span class="kw">where</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">ElemCt</span> [] a <span class="ot">=</span> <span class="dt">EmptyCt</span> a</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    cmap <span class="ot">=</span> <span class="fu">fmap</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">CApplicative</span> [] <span class="kw">where</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    cpure <span class="ot">=</span> <span class="fu">pure</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    cliftA2 <span class="ot">=</span> liftA2</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">CMonad</span> [] <span class="kw">where</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    cbind <span class="ot">=</span> (<span class="op">=&lt;&lt;</span>)</span></code></pre></div>
</div>
<p>This even means we could have <code>do</code> notation on constraint monads without loss of generality!</p>
</section>
<section id="implementation-for-tally" class="level3">
<h3>Implementation for <code>Tally</code></h3>
<div class="named-code-block">
<p>«solution-day-6»</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">CFunctor</span> <span class="dt">Tally</span> <span class="kw">where</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">ElemCt</span> <span class="dt">Tally</span> a <span class="ot">=</span> <span class="dt">Ord</span> a</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>    cmap f (<span class="dt">Tally</span> a) <span class="ot">=</span> <span class="dt">Tally</span> (Map.mapKeys f a)</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="ot">multiply ::</span> <span class="dt">Tally</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tally</span> a</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>multiply (<span class="dt">Tally</span> a) n <span class="ot">=</span> <span class="dt">Tally</span> (Map.map (<span class="op">*</span> n) a)</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">CApplicative</span> <span class="dt">Tally</span> <span class="kw">where</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    cpure a <span class="ot">=</span> <span class="dt">Tally</span> <span class="op">$</span> Map.singleton a <span class="dv">1</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>    cliftA2 f (<span class="dt">Tally</span> a) b <span class="ot">=</span> Map.foldMapWithKey</span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>            (\k v <span class="ot">-&gt;</span> multiply (cmap (f k) b) v) a</span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">CMonad</span> <span class="dt">Tally</span> <span class="kw">where</span></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>    cbind f (<span class="dt">Tally</span> a) <span class="ot">=</span> Map.foldMapWithKey (multiply <span class="op">.</span> f) a</span></code></pre></div>
</div>
<p>Notice that the implementation of <code>cliftA2</code> is as if the elements were all stored in a list. This is motivated by the linear property that <code>(f &lt;*&gt; a) &lt;&gt; (f &lt;*&gt; b) == f &lt;*&gt; (a &lt;&gt; b)</code>. We don’t need <code>cliftA2</code> in our problem, but I included it here for completeness.</p>
<div class="named-code-block">
<p>«solution-day-6»</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tallyLength ::</span> <span class="dt">Tally</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>tallyLength (<span class="dt">Tally</span> a) <span class="ot">=</span> <span class="fu">sum</span> <span class="op">$</span> Map.elems a</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="ot">tallyFromList ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Tally</span> a</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>tallyFromList <span class="ot">=</span> <span class="fu">foldMap</span> cpure</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>solutionB <span class="ot">=</span> tallyLength <span class="op">.</span> <span class="fu">last</span> <span class="op">.</span> <span class="fu">iterate</span> <span class="dv">256</span> step <span class="op">.</span> tallyFromList</span></code></pre></div>
</div>
</section>
</section>
</section>
<section id="day-7-the-treachery-of-whales" class="level1">
<h1>Day 7: The Treachery of Whales</h1>
<p>But I like whales! We need to minimize a cost function. We have a list of integers, so we can reuse the parser from Day 6.</p>
<div class="named-code-block">
<p>file:app/Day07.hs</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day07</span> <span class="kw">where</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (sort)</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List.Partial</span> ((!!))</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> ( <span class="dt">Parser</span>, readInputParsing, sepEndBy1</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>               , lexeme, char, integer)</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day<span class="op">-</span><span class="dv">7</span><span class="op">&gt;&gt;</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">7</span><span class="op">&gt;&gt;</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«parser-day-7»</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="ot">csvInts ::</span> <span class="dt">Parser</span> [<span class="dt">Int</span>]</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>csvInts <span class="ot">=</span> sepEndBy1 integer (lexeme (char <span class="ch">&#39;,&#39;</span>))</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env [<span class="dt">Int</span>]</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day07.txt&quot;</span> csvInts</span></code></pre></div>
</div>
<p>We minimize the function,</p>
<p><span class="math display">\[f_a(x) = \sum_{i=1}^N |c_i - x|.\]</span></p>
<p>We know that the solution should be translation invariant. For <span class="math inline">\(N=2\)</span> the cost function is equal at any point in between, only for <span class="math inline">\(N=3\)</span> do we start to get a minimum, at the center most point. That would suggest a median. If we remove the outer two most points, the answer stays the same, repeat and we arrive at the center most point. Proven! Since we’re only interested in the value attained at the minimum, it doesn’t matter if we take the upper or lower median for even length sequences.</p>
<div class="named-code-block">
<p>«solution-day-7»</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="ot">costFuncA ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>costFuncA cs x <span class="ot">=</span> <span class="fu">sum</span> (<span class="fu">map</span> (<span class="fu">abs</span> <span class="op">.</span> (x <span class="op">-</span>)) cs)</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="ot">median ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>median x <span class="ot">=</span> <span class="fu">sort</span> x <span class="op">!!</span> (<span class="fu">length</span> x <span class="ot">`div`</span> <span class="dv">2</span>)</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>solutionA as <span class="ot">=</span> (loc, costFuncA as loc)</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> loc <span class="ot">=</span> <span class="fu">sort</span> as <span class="op">!!</span> (<span class="fu">length</span> as <span class="ot">`div`</span> <span class="dv">2</span>)</span></code></pre></div>
</div>
<p>For part B, we get a distance function that goes like <span class="math inline">\(\sum_{i=1}^d d = d (d + 1) / 2\)</span>, where <span class="math inline">\(d = |c_i - x|.\)</span> We arrive at a minimum at the mean <span class="math inline">\(x = \langle c_i \rangle\)</span>, and I can prove it. The cost function now is,</p>
<p><span class="math display">\[f_b(x) = \sum_{i=1}^N |c_i - x| (|c_i -x| + 1) / 2 = \sum_{i=1}^N \frac{1}{2}(c_i - x)^2 + \frac{1}{2}|c_i - x|.\]</span></p>
<p>For the square part, we have that the minimum of <span class="math inline">\(\sum (c_i - x)^2\)</span> is found at,</p>
<p><span class="math display">\[\partial_x \sum (c_i - x)^2 / 2 = \sum x - c_i = Nx - \sum c_i = 0,\]</span></p>
<p>so <span class="math inline">\(x = \sum c_i / N = \langle c_i \rangle\)</span>, which is where we actually found our answer. The residual term of</p>
<p><span class="math display">\[\sum |c_i - x| / 2\]</span></p>
<p>is not differentiable, but we know how fast it grows. Since we have increments of 1, the quadratic term always grows equal or faster. Again, we’re only interested in the value, not the location of the minimum, so there we have it.</p>
<div class="named-code-block">
<p>«solution-day-7»</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="ot">costFuncB ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>costFuncB cs x <span class="ot">=</span> <span class="fu">sum</span> (<span class="fu">map</span> f cs)</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> f c <span class="ot">=</span> <span class="fu">abs</span> (x <span class="op">-</span> c) <span class="op">*</span> (<span class="fu">abs</span> (x <span class="op">-</span> c) <span class="op">+</span> <span class="dv">1</span>) <span class="ot">`div`</span> <span class="dv">2</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="ot">mean ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>mean x <span class="ot">=</span> <span class="fu">sum</span> x <span class="ot">`div`</span> <span class="fu">length</span> x</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>solutionB x <span class="ot">=</span> (loc, costFuncB x loc)</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> loc <span class="ot">=</span> mean x</span></code></pre></div>
</div>
</section>
<section id="day-8-seven-segment-search" class="level1">
<h1>Day 8: Seven Segment Search</h1>
<p>Oh boy. This was a really nice puzzle. I think I managed to put the solution into readable code also.</p>
<div class="named-code-block">
<p>file:app/Day08.hs</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day08</span> <span class="kw">where</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (foldl, find)</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Map.Lazy</span> (<span class="dt">Map</span>, (!?))</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Lazy</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Tuple</span> (swap)</span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Set</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> ( <span class="dt">Parser</span>, readInputParsing, sepEndBy1</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>               , lexeme, char, eol)</span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> (takeWhile1P)</span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="kw">data</span><span class="op">-</span>types<span class="op">-</span>day<span class="op">-</span><span class="dv">8</span><span class="op">&gt;&gt;</span></span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day<span class="op">-</span><span class="dv">8</span><span class="op">&gt;&gt;</span></span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">8</span><span class="op">&gt;&gt;</span></span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>I’ll define a <code>Digit</code> as a <code>Set Char</code> and add some operations. We get the number 8 for free, and we can use it to invert other digits.</p>
<div class="named-code-block">
<p>«data-types-day-8»</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Digit</span> <span class="ot">=</span> <span class="dt">Digit</span> {<span class="ot"> digitSet ::</span> <span class="dt">Set</span> <span class="dt">Char</span> }</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Ord</span>, <span class="dt">Eq</span>)</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">Digit</span> <span class="kw">where</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Digit</span> a <span class="op">&lt;&gt;</span> <span class="dt">Digit</span> b <span class="ot">=</span> <span class="dt">Digit</span> <span class="op">$</span> (a <span class="dt">Set</span><span class="op">.</span>\\ b) <span class="ot">`Set.union`</span> (b <span class="dt">Set</span><span class="op">.</span>\\ a)</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Digit</span> <span class="kw">where</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Digit</span> <span class="fu">mempty</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a><span class="ot">eight ::</span> <span class="dt">Digit</span></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>eight <span class="ot">=</span> <span class="dt">Digit</span> <span class="op">$</span> Set.fromList [<span class="ch">&#39;a&#39;</span><span class="op">..</span><span class="ch">&#39;g&#39;</span>]</span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;&lt;&lt;) ::</span> <span class="dt">Digit</span> <span class="ot">-&gt;</span> <span class="dt">Digit</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a><span class="dt">Digit</span> a <span class="op">&lt;&lt;&lt;</span> <span class="dt">Digit</span> b <span class="ot">=</span> a <span class="ot">`Set.isSubsetOf`</span> b</span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a>(\\)<span class="ot"> ::</span> <span class="dt">Digit</span> <span class="ot">-&gt;</span> <span class="dt">Digit</span> <span class="ot">-&gt;</span> <span class="dt">Digit</span></span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a><span class="dt">Digit</span> a \\ <span class="dt">Digit</span> b <span class="ot">=</span> <span class="dt">Digit</span> <span class="op">$</span> a <span class="dt">Set</span><span class="op">.</span>\\ b</span>
<span id="cb56-18"><a href="#cb56-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-19"><a href="#cb56-19" aria-hidden="true" tabindex="-1"></a><span class="ot">invert ::</span> <span class="dt">Digit</span> <span class="ot">-&gt;</span> <span class="dt">Digit</span></span>
<span id="cb56-20"><a href="#cb56-20" aria-hidden="true" tabindex="-1"></a>invert <span class="ot">=</span> (eight \\)</span>
<span id="cb56-21"><a href="#cb56-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-22"><a href="#cb56-22" aria-hidden="true" tabindex="-1"></a><span class="ot">numberOfSegments ::</span> <span class="dt">Digit</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb56-23"><a href="#cb56-23" aria-hidden="true" tabindex="-1"></a>numberOfSegments (<span class="dt">Digit</span> a) <span class="ot">=</span> Set.size a</span>
<span id="cb56-24"><a href="#cb56-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-25"><a href="#cb56-25" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Line</span> <span class="ot">=</span> <span class="dt">Line</span></span>
<span id="cb56-26"><a href="#cb56-26" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> signalPattern ::</span> [<span class="dt">Digit</span>]</span>
<span id="cb56-27"><a href="#cb56-27" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> outputValues  ::</span> [<span class="dt">Digit</span>]</span>
<span id="cb56-28"><a href="#cb56-28" aria-hidden="true" tabindex="-1"></a>    } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
</div>
<p>Made a superfluous parser for the characters ‘a’ through ‘g’.</p>
<div class="named-code-block">
<p>«parser-day-8»</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="ot">word ::</span> <span class="dt">Parser</span> <span class="dt">Text</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>word <span class="ot">=</span> lexeme <span class="op">$</span> takeWhile1P (<span class="dt">Just</span> <span class="st">&quot;letter a-g&quot;</span>) (\c <span class="ot">-&gt;</span> c <span class="op">&gt;=</span> <span class="ch">&#39;a&#39;</span> <span class="op">&amp;&amp;</span> c <span class="op">&lt;=</span> <span class="ch">&#39;g&#39;</span>)</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="ot">charSet ::</span> <span class="dt">Parser</span> <span class="dt">Digit</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>charSet <span class="ot">=</span> <span class="dt">Digit</span> <span class="op">.</span> Set.fromList <span class="op">.</span> Text.unpack <span class="op">&lt;$&gt;</span> word</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a><span class="ot">lineP ::</span> <span class="dt">Parser</span> <span class="dt">Line</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>lineP <span class="ot">=</span> <span class="dt">Line</span> <span class="op">&lt;$&gt;</span> some charSet <span class="op">&lt;*</span> lexeme (char <span class="ch">&#39;|&#39;</span>) <span class="op">&lt;*&gt;</span> some charSet</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env [<span class="dt">Line</span>]</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day08.txt&quot;</span> (sepEndBy1 lineP eol)</span></code></pre></div>
</div>
<p>Part A is very simple.</p>
<div class="named-code-block">
<p>«solution-day-8»</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> [<span class="dt">Line</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>solutionA <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> ((<span class="ot">`elem`</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">7</span>]) <span class="op">.</span> numberOfSegments)</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>                   <span class="op">.</span> <span class="fu">concatMap</span> outputValues</span></code></pre></div>
</div>
<p>Part B is not simple. To find the correct mapping we have to play around with deducing digits from the digits we already know. I used a <strong>lazy</strong> <code>Map Int (Maybe Digit)</code> to represent the partially decoded map. In the end I call <code>Map.mapMaybe</code> which is strict, because it needs to do pattern matching. In this lazy approach we need to make sure that all entries to the map are there, but the values are not evaluated until needed. We have a <code>match</code> function that checks if a digit matches a certain number.</p>
<div class="named-code-block">
<p>«solution-day-8»</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Decoding</span> <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">Digit</span> <span class="dt">Int</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="ot">invertMap ::</span> (<span class="dt">Ord</span> k, <span class="dt">Ord</span> v) <span class="ot">=&gt;</span> <span class="dt">Map</span> k v <span class="ot">-&gt;</span> <span class="dt">Map</span> v k</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>invertMap <span class="ot">=</span> Map.fromList <span class="op">.</span> <span class="fu">map</span> swap <span class="op">.</span> Map.toList</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a><span class="ot">generateMap ::</span> (<span class="dt">Ord</span> k) <span class="ot">=&gt;</span> (k <span class="ot">-&gt;</span> v) <span class="ot">-&gt;</span> [k] <span class="ot">-&gt;</span> <span class="dt">Map</span> k v</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>generateMap f <span class="ot">=</span> Map.fromList <span class="op">.</span> <span class="fu">map</span> (\k <span class="ot">-&gt;</span> (k, f k))</span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a><span class="ot">decode ::</span> [<span class="dt">Digit</span>] <span class="ot">-&gt;</span> <span class="dt">Decoding</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>decode digits <span class="ot">=</span> invertMap <span class="op">$</span> Map.mapMaybe <span class="fu">id</span> decodedMap</span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> decodedMap <span class="ot">=</span> generateMap (\i <span class="ot">-&gt;</span> find (match i) digits) [<span class="dv">0</span><span class="op">..</span><span class="dv">9</span>]</span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>          getDigit <span class="ot">=</span> join <span class="op">.</span> (decodedMap <span class="op">!?</span>)</span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a>          match i digit</span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>              <span class="op">&lt;&lt;</span>digit<span class="op">-</span>decode<span class="op">-</span>cases<span class="op">&gt;&gt;</span></span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>              <span class="op">|</span> <span class="fu">otherwise</span>            <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>              <span class="kw">where</span> l <span class="ot">=</span> numberOfSegments digit</span></code></pre></div>
</div>
<p>The easy cases were already pointed to in part A:</p>
<div class="named-code-block">
<p>«digit-decode-cases»</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> i <span class="op">==</span> <span class="dv">1</span>             <span class="ot">=</span> l <span class="op">==</span> <span class="dv">2</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> i <span class="op">==</span> <span class="dv">4</span>             <span class="ot">=</span> l <span class="op">==</span> <span class="dv">4</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> i <span class="op">==</span> <span class="dv">7</span>             <span class="ot">=</span> l <span class="op">==</span> <span class="dv">3</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> i <span class="op">==</span> <span class="dv">8</span>             <span class="ot">=</span> l <span class="op">==</span> <span class="dv">7</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> i <span class="ot">`elem`</span> [<span class="dv">0</span>, <span class="dv">6</span>, <span class="dv">9</span>] <span class="ot">=</span> l <span class="op">==</span> <span class="dv">6</span> <span class="op">&amp;&amp;</span> </span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>digit<span class="op">-</span><span class="dv">6</span><span class="op">-</span>segments<span class="op">&gt;&gt;</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> i <span class="ot">`elem`</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>] <span class="ot">=</span> l <span class="op">==</span> <span class="dv">5</span> <span class="op">&amp;&amp;</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>digit<span class="op">-</span><span class="dv">5</span><span class="op">-</span>segments<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>In the case of five segments, i.e. numbers 2, 3 and 5, we can make the following deductions:</p>
<ul>
<li>digit 1 is a subset of 3 but not of 2 and 5</li>
<li>digit 2 contains the segment that is not in 6</li>
<li>digit 5 does not contain the segment that is not in 6</li>
</ul>
<div class="named-code-block">
<p>«digit-5-segments»</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>fromMaybe <span class="dt">False</span> ( <span class="kw">do</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>  one <span class="ot">&lt;-</span> getDigit <span class="dv">1</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>  six <span class="ot">&lt;-</span> getDigit <span class="dv">6</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> i <span class="op">==</span> <span class="dv">3</span> <span class="op">&amp;&amp;</span> one <span class="op">&lt;&lt;&lt;</span> digit</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">||</span> i <span class="op">==</span> <span class="dv">2</span> <span class="op">&amp;&amp;</span> invert six <span class="op">&lt;&lt;&lt;</span> digit</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>                  <span class="op">&amp;&amp;</span> <span class="fu">not</span> (one <span class="op">&lt;&lt;&lt;</span> digit)</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">||</span> i <span class="op">==</span> <span class="dv">5</span> <span class="op">&amp;&amp;</span> <span class="fu">not</span> (invert six <span class="op">&lt;&lt;&lt;</span> digit)</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>                  <span class="op">&amp;&amp;</span> <span class="fu">not</span> (one <span class="op">&lt;&lt;&lt;</span> digit) )</span></code></pre></div>
</div>
<p>In the case of six segments, i.e. numbers 0, 6 and 9, we can make the following deductions:</p>
<ul>
<li>the inverse of digit 0 (center segment) is in 4 and 1 is a subset of 0</li>
<li>the inverse of digit 6 is in 1</li>
<li>the digit 4 is a subset of digit 9</li>
</ul>
<div class="named-code-block">
<p>«digit-6-segments»</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>fromMaybe <span class="dt">False</span> ( <span class="kw">do</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>  one  <span class="ot">&lt;-</span> getDigit <span class="dv">1</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>  four <span class="ot">&lt;-</span> getDigit <span class="dv">4</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> i <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> invert digit <span class="op">&lt;&lt;&lt;</span> four</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>                  <span class="op">&amp;&amp;</span> one <span class="op">&lt;&lt;&lt;</span> digit</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">||</span> i <span class="op">==</span> <span class="dv">6</span> <span class="op">&amp;&amp;</span> invert digit <span class="op">&lt;&lt;&lt;</span> one</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">||</span> i <span class="op">==</span> <span class="dv">9</span> <span class="op">&amp;&amp;</span> four <span class="op">&lt;&lt;&lt;</span> digit )</span></code></pre></div>
</div>
<p>Importantly, these deduction rules do not contain loops.</p>
<div class="named-code-block">
<p>«solution-day-8»</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="ot">decodeLine ::</span> <span class="dt">Line</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>decodeLine <span class="dt">Line</span>{<span class="op">..</span>} <span class="ot">=</span> fromDecimal <span class="op">$</span> mapMaybe (d <span class="op">!?</span>) outputValues</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> d <span class="ot">=</span> decode signalPattern</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>          fromDecimal <span class="ot">=</span> <span class="fu">foldl</span> (\a b <span class="ot">-&gt;</span> a <span class="op">*</span> <span class="dv">10</span> <span class="op">+</span> b) <span class="dv">0</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> [<span class="dt">Line</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>solutionB <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> decodeLine</span></code></pre></div>
</div>
</section>
<section id="day-9-smoke-basin" class="level1">
<h1>Day 9: Smoke Basin</h1>
<p>Lava tubes and more hydrothermal vents! I’ll be doing this in <code>Massiv</code> again. Here is a rendering of my input data.</p>
<p><img src="fig/day09-input.svg" title="The input data." class="figure" alt="The input data." /></p>
<div class="named-code-block">
<p>file:app/Day09.hs</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day09</span> <span class="kw">where</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (nub, sortBy)</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.Char</span> (ord)</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.State</span> (<span class="dt">State</span>, evalState, modify, get)</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.ByteString</span> (putStr)</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> (<span class="dt">Parser</span>, sepEndBy1, eol, digit, failOnException, readInputParsing)</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Massiv.Array</span> (<span class="dt">Array</span>, <span class="dt">Ix2</span>(..))</span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Massiv.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Massiv.Array.Stencil</span> <span class="kw">as</span> <span class="dt">A.Stencil</span></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.MultiSet</span> (<span class="dt">MultiSet</span>)</span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.MultiSet</span> <span class="kw">as</span> <span class="dt">MultiSet</span></span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Random</span> (mkStdGen, genWord8)</span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parsing<span class="op">-</span>day<span class="op">-</span><span class="dv">9</span><span class="op">&gt;&gt;</span></span>
<span id="cb64-22"><a href="#cb64-22" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">9</span><span class="op">&gt;&gt;</span></span>
<span id="cb64-23"><a href="#cb64-23" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span>
<span id="cb64-24"><a href="#cb64-24" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="fu">show</span><span class="op">-</span><span class="kw">data</span><span class="op">-</span>day<span class="op">-</span><span class="dv">9</span><span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>Today’s input data is given as digits between 0 and 9.</p>
<div class="named-code-block">
<p>«digit-array-parser»</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Array2&#39;</span> r a <span class="ot">=</span> <span class="dt">A.Array</span> r <span class="dt">A.Ix2</span> a</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Array2</span> a <span class="ot">=</span> <span class="dt">Array2&#39;</span> <span class="dt">A.U</span> a</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a><span class="ot">digitArray ::</span> <span class="dt">Parser</span> (<span class="dt">Array2</span> <span class="dt">Int</span>)</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>digitArray <span class="ot">=</span> sepEndBy1 (some digit) eol <span class="op">&gt;&gt;=</span> toArray2</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> toArray2 <span class="ot">=</span> failOnException <span class="op">.</span> A.fromListsM <span class="dt">A.Seq</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«parsing-day-9»</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>digit<span class="op">-</span>array<span class="op">-</span>parser<span class="op">&gt;&gt;</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env (<span class="dt">Array2</span> <span class="dt">Int</span>)</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day09.txt&quot;</span> digitArray</span></code></pre></div>
</div>
<p>I’ll be using <code>Massiv</code>s stencil interface to solve this. Each stencil works on a neighbourhood of four pixels directly north, south, west and east from current location:</p>
<div class="named-code-block">
<p>«solution-day-9»</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="ot">neighbours ::</span> [<span class="dt">Ix2</span>]</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>neighbours <span class="ot">=</span> [<span class="op">-</span><span class="dv">1</span> <span class="op">:.</span> <span class="dv">0</span>, <span class="dv">1</span> <span class="op">:.</span> <span class="dv">0</span>, <span class="dv">0</span> <span class="op">:.</span> <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span> <span class="op">:.</span> <span class="dv">1</span>]</span></code></pre></div>
</div>
<p>For part A, we need to find the minima in the data.</p>
<div class="named-code-block">
<p>«solution-day-9»</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="ot">findMinStencil ::</span> <span class="dt">A.Stencil</span> <span class="dt">Ix2</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>findMinStencil <span class="ot">=</span> A.Stencil.makeStencil (<span class="dt">A.Sz</span> (<span class="dv">3</span> <span class="op">:.</span> <span class="dv">3</span>)) (<span class="dv">1</span> <span class="op">:.</span> <span class="dv">1</span>) go</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go get</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">all</span> ((value <span class="op">&lt;</span>) <span class="op">.</span> get) neighbours <span class="ot">=</span> value <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span>                        <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">where</span> value <span class="ot">=</span> get (<span class="dv">0</span> <span class="op">:.</span> <span class="dv">0</span>)</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>solutionA a <span class="ot">=</span> A.sum b</span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span><span class="ot"> b ::</span> <span class="dt">Array2</span> <span class="dt">Int</span></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>          b <span class="ot">=</span> A.compute <span class="op">$</span> A.Stencil.mapStencil (<span class="dt">A.Fill</span> <span class="dv">10</span>) findMinStencil a</span></code></pre></div>
</div>
<p>In part B, we need to compute the watershed of the height map.</p>
<ol type="1">
<li>Mark minima.</li>
<li>Grow to a neighbourhood around each minimum:
<ul>
<li>stop when two patches meet</li>
<li>otherwise, repeat</li>
</ul></li>
</ol>
<p>We start by marking all minima found in part A with a unique integer identifier. I use a monadic map to give each minimum a number &gt; 0.</p>
<div class="named-code-block">
<p>«solution-day-9»</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="ot">markBasins ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Array2</span> <span class="dt">Int</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>markBasins a <span class="ot">=</span> evalState (A.mapM markNonZero a) <span class="dv">0</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span><span class="ot"> promise ::</span> <span class="dt">State</span> <span class="dt">Int</span> (<span class="dt">Array2</span> <span class="dt">Int</span>)</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>          promise <span class="ot">=</span> A.mapM markNonZero a</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a><span class="ot">          markNonZero ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>          markNonZero x</span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> x <span class="op">/=</span> <span class="dv">0</span>    <span class="ot">=</span> modify (<span class="op">+</span> <span class="dv">1</span>) <span class="op">&gt;&gt;</span> get</span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">return</span> <span class="dv">0</span></span></code></pre></div>
</div>
<p>The second step, we paint a pixel if all descending pixels have the same color. If a pixel is already colored, we leave it alone.</p>
<div class="named-code-block">
<p>«solution-day-9»</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="ot">same ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>same (a1<span class="op">:</span>a2<span class="op">:</span>as)</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a1 <span class="op">==</span> a2  <span class="ot">=</span> same (a2<span class="op">:</span>as)</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>same [a]   <span class="ot">=</span> <span class="dt">Just</span> a</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>same _     <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a><span class="ot">watershedStencil ::</span> <span class="dt">A.Stencil</span> <span class="dt">Ix2</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>watershedStencil <span class="ot">=</span> A.Stencil.makeStencil (<span class="dt">A.Sz</span> (<span class="dv">3</span> <span class="op">:.</span> <span class="dv">3</span>)) (<span class="dv">1</span> <span class="op">:.</span> <span class="dv">1</span>) go</span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go get</span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">snd</span> value <span class="op">/=</span> <span class="dv">0</span> <span class="ot">=</span> value</span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span>      <span class="ot">=</span> paint color</span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a>            <span class="kw">where</span> value      <span class="ot">=</span> get (<span class="dv">0</span> <span class="op">:.</span> <span class="dv">0</span>)</span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a>                  descending <span class="ot">=</span> <span class="fu">filter</span> (\p <span class="ot">-&gt;</span> <span class="fu">fst</span> p <span class="op">&lt;</span> <span class="fu">fst</span> value) (get <span class="op">&lt;$&gt;</span> neighbours)</span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a>                  color      <span class="ot">=</span> same <span class="op">$</span> <span class="fu">snd</span> <span class="op">&lt;$&gt;</span> descending</span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a>                  paint (<span class="dt">Just</span> c) <span class="ot">=</span> (<span class="fu">fst</span> value, c)</span>
<span id="cb70-17"><a href="#cb70-17" aria-hidden="true" tabindex="-1"></a>                  paint _        <span class="ot">=</span> value</span></code></pre></div>
</div>
<p>We keep doing this, until the watershed doesn’t change anymore. Afterwards, we need to clear pixels where the value is 9, this only happens at the edges.</p>
<div class="named-code-block">
<p>«solution-day-9»</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="ot">watershed ::</span> <span class="dt">Array2</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Array2</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>watershed <span class="ot">=</span> A.compute <span class="op">.</span> A.Stencil.mapStencil (<span class="dt">A.Fill</span> (<span class="dv">10</span>, <span class="dv">0</span>)) watershedStencil </span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a><span class="ot">fixedPoint ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>fixedPoint f x</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> x <span class="op">==</span> next <span class="ot">=</span> x</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> fixedPoint f next</span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> next <span class="ot">=</span> f x</span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a><span class="ot">computeWatershed ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Array2</span> <span class="dt">Int</span></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a>computeWatershed a <span class="ot">=</span> A.compute <span class="op">$</span> A.map <span class="fu">snd</span> erase9</span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> minima <span class="ot">=</span> A.compute <span class="op">$</span> A.Stencil.mapStencil (<span class="dt">A.Fill</span> <span class="dv">10</span>) findMinStencil a </span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a>          runWs  <span class="ot">=</span> fixedPoint watershed (A.compute <span class="op">$</span> A.zip a <span class="op">$</span> markBasins minima)</span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a>          erase9 <span class="ot">=</span> A.map (\(a, b) <span class="ot">-&gt;</span> <span class="kw">if</span> a <span class="op">==</span> <span class="dv">9</span> <span class="kw">then</span> (a, <span class="dv">0</span>) <span class="kw">else</span> (a, b)) runWs</span></code></pre></div>
</div>
<p>To get our answer, we need to measure the size of each patch, and then find the three largest ones. On Day 6 we already saw the <code>MultiSet</code> in use, now again so:</p>
<div class="named-code-block">
<p>«solution-day-9»</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="ot">count ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> <span class="dt">Int</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>count <span class="ot">=</span> A.foldMono MultiSet.singleton</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>solutionB a <span class="ot">=</span> <span class="fu">product</span> <span class="op">$</span> <span class="fu">take</span> <span class="dv">3</span> <span class="op">$</span> sortBy (<span class="fu">flip</span> <span class="fu">compare</span>)</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">$</span> <span class="fu">map</span> <span class="fu">snd</span> <span class="op">$</span> <span class="fu">filter</span> ((<span class="op">/=</span> <span class="dv">0</span>) <span class="op">.</span> <span class="fu">fst</span>)</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">$</span> MultiSet.toOccurList <span class="op">$</span> count</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">$</span> computeWatershed a</span></code></pre></div>
</div>
<p>Here is my rendering of the resulting watershed:</p>
<p><img src="fig/day09-output.svg" title="The watershed segmentation of the input data." class="figure" alt="The watershed segmentation of the input data." /></p>
</section>
<section id="day-10-syntax-scoring" class="level1">
<h1>Day 10: Syntax Scoring</h1>
<p>Yay! Parsing! We can do this really well :)</p>
<div class="named-code-block">
<p>file:app/Day10.hs</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day10</span> <span class="kw">where</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span> <span class="kw">hiding</span> (lines)</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List.Partial</span> ((!!))</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (sort, headMaybe, foldl)</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Set</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.ByteString</span> (readFile)</span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.Text</span> (lenientDecode, decodeUtf8With, lines)</span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> (<span class="dt">Parser</span>, char, eol)</span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> ( parse, <span class="dt">ParseErrorBundle</span>(..), <span class="dt">ErrorItem</span>(..)</span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>                       , <span class="dt">ParseError</span>(<span class="op">..</span>))</span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parsing<span class="op">-</span>day<span class="op">-</span><span class="dv">10</span><span class="op">&gt;&gt;</span></span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">10</span><span class="op">&gt;&gt;</span></span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>Parsing these sequences is what we have <code>Megaparsec</code> for.</p>
<div class="named-code-block">
<p>«parsing-day-10»</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bracket</span> <span class="ot">=</span> <span class="dt">Round</span> <span class="op">|</span> <span class="dt">Square</span> <span class="op">|</span> <span class="dt">Curly</span> <span class="op">|</span> <span class="dt">Angle</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Enum</span>)</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Chunk</span> <span class="ot">=</span> <span class="dt">Chunk</span> <span class="dt">Bracket</span> [<span class="dt">Chunk</span>]</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a><span class="ot">openingBracket ::</span> <span class="dt">Parser</span> <span class="dt">Bracket</span></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>openingBracket <span class="ot">=</span>  char <span class="ch">&#39;(&#39;</span> <span class="op">$&gt;</span> <span class="dt">Round</span></span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>              <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;{&#39;</span> <span class="op">$&gt;</span> <span class="dt">Curly</span></span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>              <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;[&#39;</span> <span class="op">$&gt;</span> <span class="dt">Square</span></span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>              <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;&lt;&#39;</span> <span class="op">$&gt;</span> <span class="dt">Angle</span></span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a><span class="ot">closingBracket ::</span> <span class="dt">Bracket</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> ()</span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a>closingBracket b <span class="ot">=</span> (<span class="kw">case</span> b <span class="kw">of</span></span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">Round</span>  <span class="ot">-&gt;</span> char <span class="ch">&#39;)&#39;</span></span>
<span id="cb74-16"><a href="#cb74-16" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">Square</span> <span class="ot">-&gt;</span> char <span class="ch">&#39;]&#39;</span></span>
<span id="cb74-17"><a href="#cb74-17" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">Curly</span>  <span class="ot">-&gt;</span> char <span class="ch">&#39;}&#39;</span></span>
<span id="cb74-18"><a href="#cb74-18" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">Angle</span>  <span class="ot">-&gt;</span> char <span class="ch">&#39;&gt;&#39;</span>) <span class="op">$&gt;</span> ()</span>
<span id="cb74-19"><a href="#cb74-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-20"><a href="#cb74-20" aria-hidden="true" tabindex="-1"></a><span class="ot">chunkP ::</span> <span class="dt">Parser</span> <span class="dt">Chunk</span></span>
<span id="cb74-21"><a href="#cb74-21" aria-hidden="true" tabindex="-1"></a>chunkP <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb74-22"><a href="#cb74-22" aria-hidden="true" tabindex="-1"></a>    opening <span class="ot">&lt;-</span> openingBracket</span>
<span id="cb74-23"><a href="#cb74-23" aria-hidden="true" tabindex="-1"></a>    content <span class="ot">&lt;-</span> many chunkP</span>
<span id="cb74-24"><a href="#cb74-24" aria-hidden="true" tabindex="-1"></a>    closingBracket opening</span>
<span id="cb74-25"><a href="#cb74-25" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="op">$</span> <span class="dt">Chunk</span> opening content</span>
<span id="cb74-26"><a href="#cb74-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-27"><a href="#cb74-27" aria-hidden="true" tabindex="-1"></a><span class="ot">parseLine ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">ParseErrorBundle</span> <span class="dt">Text</span> <span class="dt">Void</span>) <span class="dt">Chunk</span></span>
<span id="cb74-28"><a href="#cb74-28" aria-hidden="true" tabindex="-1"></a>parseLine <span class="ot">=</span> parse chunkP <span class="st">&quot;&quot;</span></span>
<span id="cb74-29"><a href="#cb74-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-30"><a href="#cb74-30" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="fu">read</span><span class="op">-</span><span class="fu">lines</span><span class="op">&gt;&gt;</span></span>
<span id="cb74-31"><a href="#cb74-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-32"><a href="#cb74-32" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">MonadIO</span> m) <span class="ot">=&gt;</span> m [<span class="dt">Text</span>]</span>
<span id="cb74-33"><a href="#cb74-33" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readLines</span></code></pre></div>
</div>
<div class="named-code-block">
<p>«read-lines»</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="ot">readLines ::</span> (<span class="dt">MonadIO</span> m) <span class="ot">=&gt;</span> m [<span class="dt">Text</span>]</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>readLines <span class="ot">=</span> Text.lines <span class="op">.</span> Text.decodeUtf8With Text.lenientDecode </span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>         <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> <span class="st">&quot;data/day10.txt&quot;</span></span></code></pre></div>
</div>
<p>For part A we need to look at the parser error that we get and extract the unexpected character. We can pattern match to get at the character and assume if it doesn’t match, we have unexpected end-of-input.</p>
<div class="named-code-block">
<p>«solution-day-10»</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="ot">illegalChar ::</span> <span class="dt">ParseErrorBundle</span> <span class="dt">Text</span> <span class="dt">Void</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Char</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>illegalChar e <span class="ot">=</span> <span class="kw">case</span> bundleErrors e <span class="kw">of</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">TrivialError</span> _ (<span class="dt">Just</span> (<span class="dt">Tokens</span> (c <span class="op">:|</span> _))) _) <span class="op">:|</span> _ <span class="ot">-&gt;</span> <span class="dt">Just</span> c</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>    _                                                <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
</div>
<p>Completing the score,</p>
<div class="named-code-block">
<p>«solution-day-10»</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="ot">scoreA ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>scoreA <span class="ch">&#39;)&#39;</span> <span class="ot">=</span> <span class="dv">3</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>scoreA <span class="ch">&#39;]&#39;</span> <span class="ot">=</span> <span class="dv">57</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>scoreA <span class="ch">&#39;}&#39;</span> <span class="ot">=</span> <span class="dv">1197</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>scoreA <span class="ch">&#39;&gt;&#39;</span> <span class="ot">=</span> <span class="dv">25137</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>scoreA _   <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a>solutionA <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> scoreA <span class="op">.</span> mapMaybe illegalChar</span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>          <span class="op">.</span> lefts <span class="op">.</span> <span class="fu">map</span> parseLine</span></code></pre></div>
</div>
<p>In part B we look at the characters we expected when encountering end-of-input. We need to take care here: opening brackets are always expected, so we filter on closing brackets.</p>
<div class="named-code-block">
<p>«solution-day-10»</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="ot">expectedChar ::</span> <span class="dt">ParseErrorBundle</span> <span class="dt">Text</span> <span class="dt">Void</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Char</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>expectedChar e <span class="ot">=</span> <span class="kw">case</span> bundleErrors e <span class="kw">of</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">TrivialError</span> _ (<span class="dt">Just</span> <span class="dt">EndOfInput</span>) <span class="fu">exp</span>) <span class="op">:|</span> _ <span class="ot">-&gt;</span> getExpected <span class="fu">exp</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>    _                                           <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span><span class="ot"> getExpected ::</span> <span class="dt">Set</span> (<span class="dt">ErrorItem</span> <span class="dt">Char</span>) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Char</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>          getExpected s <span class="ot">=</span> headMaybe <span class="op">$</span> <span class="fu">concatMap</span> getToken</span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>                                    <span class="op">$</span> Set.toList s</span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>          getToken (<span class="dt">Tokens</span> (t <span class="op">:|</span> ts)) <span class="ot">=</span> <span class="fu">filter</span> closingChar (t <span class="op">:</span> ts)</span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a>          getToken _                  <span class="ot">=</span> []</span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a>          closingChar <span class="ot">=</span> (<span class="ot">`elem`</span> [<span class="ch">&#39;)&#39;</span>, <span class="ch">&#39;]&#39;</span>, <span class="ch">&#39;}&#39;</span>, <span class="ch">&#39;&gt;&#39;</span>])</span></code></pre></div>
</div>
<p>To autocomplete, I keep re-parsing the string, adding characters at the end, until the parsing succeeds. In principle, this could be done nicer from the parser, by creating a sort of stack trace. However, that would polute the code for actually parsing the correct structure.</p>
<div class="named-code-block">
<p>«solution-day-10»</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="ot">autocomplete ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Text</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>autocomplete orig <span class="ot">=</span> go <span class="st">&quot;&quot;</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go suffix <span class="ot">=</span> <span class="fu">either</span> (complete suffix)</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>                             (<span class="fu">const</span> <span class="op">$</span> <span class="dt">Just</span> suffix)</span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>                             (parseLine <span class="op">$</span> orig <span class="op">&lt;&gt;</span> suffix)</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>          complete suffix err <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>              c <span class="ot">&lt;-</span> expectedChar err</span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>              go (suffix <span class="op">&lt;&gt;</span> Text.singleton c)</span></code></pre></div>
</div>
<p>For computing the score, we encounter our old friend the <code>median</code> function again.</p>
<div class="named-code-block">
<p>«median»</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="ot">median ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>median x <span class="ot">=</span> <span class="fu">sort</span> x <span class="op">!!</span> (<span class="fu">length</span> x <span class="ot">`div`</span> <span class="dv">2</span>)</span></code></pre></div>
</div>
<div class="named-code-block">
<p>«solution-day-10»</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>median<span class="op">&gt;&gt;</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a><span class="ot">scoreB ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>scoreB <span class="ot">=</span> <span class="fu">foldl</span> f <span class="dv">0</span> <span class="op">.</span> Text.unpack </span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> f i c <span class="ot">=</span> i <span class="op">*</span> <span class="dv">5</span> <span class="op">+</span> s c</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>          s <span class="ch">&#39;)&#39;</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>          s <span class="ch">&#39;]&#39;</span> <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>          s <span class="ch">&#39;}&#39;</span> <span class="ot">=</span> <span class="dv">3</span></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>          s <span class="ch">&#39;&gt;&#39;</span> <span class="ot">=</span> <span class="dv">4</span></span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a>          s _   <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a>solutionB <span class="ot">=</span> median <span class="op">.</span> <span class="fu">map</span> scoreB <span class="op">.</span> mapMaybe autocomplete</span></code></pre></div>
</div>
<section id="simpler-solution" class="level3">
<h3>Simpler solution</h3>
<p>Ok, that was fun but way too much work. There should be a much simpler solution. We can keep a stack.</p>
<div class="named-code-block">
<p>file:app/Day10Alt.hs</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day10Alt</span> <span class="kw">where</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List.Partial</span> ((!!))</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (sort, headMaybe, foldl)</span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.ByteString</span> (readFile)</span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">MonadIO</span> m) <span class="ot">=&gt;</span> m [<span class="dt">Text</span>]</span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> Text.lines <span class="op">.</span> Text.decodeUtf8With Text.lenientDecode </span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a>         <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> <span class="st">&quot;data/day10.txt&quot;</span></span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ParseResult</span> <span class="ot">=</span> <span class="dt">Unexpected</span> <span class="dt">Char</span> <span class="op">|</span> <span class="dt">AutoComplete</span> <span class="dt">Text</span> <span class="op">|</span> <span class="dt">Success</span> <span class="dt">Text</span></span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">ParseResult</span></span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true" tabindex="-1"></a>parse inp <span class="ot">=</span> go (Text.unpack inp) []</span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go [] []      <span class="ot">=</span> <span class="dt">Success</span> inp</span>
<span id="cb82-20"><a href="#cb82-20" aria-hidden="true" tabindex="-1"></a>          go [] <span class="fu">exp</span>     <span class="ot">=</span> <span class="dt">AutoComplete</span> (Text.pack <span class="fu">exp</span>)</span>
<span id="cb82-21"><a href="#cb82-21" aria-hidden="true" tabindex="-1"></a>          go (c<span class="op">:</span>cs) <span class="fu">exp</span> <span class="ot">=</span> fromMaybe (<span class="dt">Unexpected</span> c) </span>
<span id="cb82-22"><a href="#cb82-22" aria-hidden="true" tabindex="-1"></a>                                    (close (c<span class="op">:</span>cs) <span class="fu">exp</span> <span class="op">&lt;|&gt;</span> open (c<span class="op">:</span>cs) <span class="fu">exp</span>)</span>
<span id="cb82-23"><a href="#cb82-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-24"><a href="#cb82-24" aria-hidden="true" tabindex="-1"></a>          close (c<span class="op">:</span>cs) (e<span class="op">:</span><span class="fu">exp</span>)</span>
<span id="cb82-25"><a href="#cb82-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> c <span class="op">==</span> e    <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> go cs <span class="fu">exp</span></span>
<span id="cb82-26"><a href="#cb82-26" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb82-27"><a href="#cb82-27" aria-hidden="true" tabindex="-1"></a>          close (c<span class="op">:</span>cs) [] <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb82-28"><a href="#cb82-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-29"><a href="#cb82-29" aria-hidden="true" tabindex="-1"></a>          open (c<span class="op">:</span>cs) <span class="fu">exp</span></span>
<span id="cb82-30"><a href="#cb82-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> c <span class="op">==</span> <span class="ch">&#39;(&#39;</span>  <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> go cs (<span class="ch">&#39;)&#39;</span><span class="op">:</span><span class="fu">exp</span>)</span>
<span id="cb82-31"><a href="#cb82-31" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> c <span class="op">==</span> <span class="ch">&#39;[&#39;</span>  <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> go cs (<span class="ch">&#39;]&#39;</span><span class="op">:</span><span class="fu">exp</span>)</span>
<span id="cb82-32"><a href="#cb82-32" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> c <span class="op">==</span> <span class="ch">&#39;&lt;&#39;</span>  <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> go cs (<span class="ch">&#39;&gt;&#39;</span><span class="op">:</span><span class="fu">exp</span>)</span>
<span id="cb82-33"><a href="#cb82-33" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> c <span class="op">==</span> <span class="ch">&#39;{&#39;</span>  <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> go cs (<span class="ch">&#39;}&#39;</span><span class="op">:</span><span class="fu">exp</span>)</span>
<span id="cb82-34"><a href="#cb82-34" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb82-35"><a href="#cb82-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-36"><a href="#cb82-36" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb82-37"><a href="#cb82-37" aria-hidden="true" tabindex="-1"></a>solutionA <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> (score <span class="op">.</span> parse)</span>
<span id="cb82-38"><a href="#cb82-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> score (<span class="dt">Unexpected</span> <span class="ch">&#39;)&#39;</span>) <span class="ot">=</span> <span class="dv">3</span></span>
<span id="cb82-39"><a href="#cb82-39" aria-hidden="true" tabindex="-1"></a>          score (<span class="dt">Unexpected</span> <span class="ch">&#39;]&#39;</span>) <span class="ot">=</span> <span class="dv">57</span></span>
<span id="cb82-40"><a href="#cb82-40" aria-hidden="true" tabindex="-1"></a>          score (<span class="dt">Unexpected</span> <span class="ch">&#39;}&#39;</span>) <span class="ot">=</span> <span class="dv">1197</span></span>
<span id="cb82-41"><a href="#cb82-41" aria-hidden="true" tabindex="-1"></a>          score (<span class="dt">Unexpected</span> <span class="ch">&#39;&gt;&#39;</span>) <span class="ot">=</span> <span class="dv">25137</span></span>
<span id="cb82-42"><a href="#cb82-42" aria-hidden="true" tabindex="-1"></a>          score _                <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb82-43"><a href="#cb82-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-44"><a href="#cb82-44" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>median<span class="op">&gt;&gt;</span></span>
<span id="cb82-45"><a href="#cb82-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-46"><a href="#cb82-46" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb82-47"><a href="#cb82-47" aria-hidden="true" tabindex="-1"></a>solutionB <span class="ot">=</span> median <span class="op">.</span> mapMaybe (score <span class="op">.</span> parse)</span>
<span id="cb82-48"><a href="#cb82-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> score (<span class="dt">AutoComplete</span> t) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> <span class="fu">foldl</span> (\i c <span class="ot">-&gt;</span> i <span class="op">*</span> <span class="dv">5</span> <span class="op">+</span> points c) <span class="dv">0</span> (Text.unpack t)</span>
<span id="cb82-49"><a href="#cb82-49" aria-hidden="true" tabindex="-1"></a>          score _                <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb82-50"><a href="#cb82-50" aria-hidden="true" tabindex="-1"></a>          points <span class="ch">&#39;)&#39;</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb82-51"><a href="#cb82-51" aria-hidden="true" tabindex="-1"></a>          points <span class="ch">&#39;]&#39;</span> <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb82-52"><a href="#cb82-52" aria-hidden="true" tabindex="-1"></a>          points <span class="ch">&#39;}&#39;</span> <span class="ot">=</span> <span class="dv">3</span></span>
<span id="cb82-53"><a href="#cb82-53" aria-hidden="true" tabindex="-1"></a>          points <span class="ch">&#39;&gt;&#39;</span> <span class="ot">=</span> <span class="dv">4</span></span>
<span id="cb82-54"><a href="#cb82-54" aria-hidden="true" tabindex="-1"></a>          points _   <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb82-55"><a href="#cb82-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-56"><a href="#cb82-56" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
</section>
</section>
<section id="day-11-dumbo-octopus" class="level1">
<h1>Day 11: Dumbo Octopus</h1>
<p>This is clearly inspired on <a href="https://ncase.me/fireflies/">this demo of spontaneously synchronising fireflies</a>.</p>
<div class="named-code-block">
<p>file:app/Day11.hs</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day11</span> <span class="kw">where</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.ByteString</span> (putStr)</span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.State</span> (evalStateT, evalState, execState, <span class="dt">MonadState</span>, modify, get, gets)</span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Massiv.Array</span> (<span class="dt">Ix2</span>(..))</span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Massiv.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> (<span class="dt">Parser</span>, sepEndBy1, failOnException, eol, digit, readInputParsing)</span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day<span class="op">-</span><span class="dv">11</span><span class="op">&gt;&gt;</span></span>
<span id="cb83-12"><a href="#cb83-12" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">11</span><span class="op">&gt;&gt;</span></span>
<span id="cb83-13"><a href="#cb83-13" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="fu">show</span><span class="op">-</span><span class="kw">data</span><span class="op">-</span>day<span class="op">-</span><span class="dv">11</span><span class="op">&gt;&gt;</span></span>
<span id="cb83-14"><a href="#cb83-14" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>We can reuse the input parser from day 9.</p>
<div class="named-code-block">
<p>«parser-day-11»</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>digit<span class="op">-</span>array<span class="op">-</span>parser<span class="op">&gt;&gt;</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env (<span class="dt">Array2</span> <span class="dt">Int</span>)</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day11.txt&quot;</span> digitArray</span></code></pre></div>
</div>
<p>Each iteration can be divided in three steps:</p>
<ul>
<li><code>clock</code>: advance the cycle of every octopus by one</li>
<li><code>flash</code>: resolve the flashing, marking flashed octopusses</li>
<li><code>reset</code>: reset the counter for flashed octopusses</li>
</ul>
<p>I put these steps into a state monad.</p>
<div class="named-code-block">
<p>«solution-day-11»</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="ot">step ::</span> (<span class="dt">MonadState</span> (<span class="dt">Array2</span> <span class="dt">Int</span>) m) <span class="ot">=&gt;</span> m <span class="dt">Int</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>step <span class="ot">=</span> clock <span class="op">&gt;&gt;</span> flash <span class="op">&gt;&gt;</span> reset</span></code></pre></div>
</div>
<p>The <code>clock</code> advances every counter by one tick.</p>
<div class="named-code-block">
<p>«solution-day-11»</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="ot">clock ::</span> (<span class="dt">MonadState</span> (<span class="dt">Array2</span> <span class="dt">Int</span>) m) <span class="ot">=&gt;</span> m ()</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>clock <span class="ot">=</span> modify (A.compute <span class="op">.</span> A.map (<span class="op">+</span> <span class="dv">1</span>))</span></code></pre></div>
</div>
<p>To resolve the flashes, I use my friend the <em>stencil</em> again. I mark flashed octopusses by setting their counter to 1000. That way, they don’t get counted twice.</p>
<div class="named-code-block">
<p>«solution-day-11»</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="ot">home ::</span> <span class="dt">A.Ix2</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>home <span class="ot">=</span> <span class="dv">0</span> <span class="op">:.</span> <span class="dv">0</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a><span class="ot">neighbours ::</span> [<span class="dt">A.Ix2</span>]</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>neighbours <span class="ot">=</span> [ <span class="op">-</span><span class="dv">1</span> <span class="op">:.</span> <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span> <span class="op">:.</span> <span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span> <span class="op">:.</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>             , <span class="op">-</span><span class="dv">1</span> <span class="op">:.</span>  <span class="dv">0</span>,          <span class="dv">1</span> <span class="op">:.</span>  <span class="dv">0</span></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>             , <span class="op">-</span><span class="dv">1</span> <span class="op">:.</span>  <span class="dv">1</span>, <span class="dv">0</span> <span class="op">:.</span>  <span class="dv">1</span>, <span class="dv">1</span> <span class="op">:.</span>  <span class="dv">1</span> ]</span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a><span class="ot">count ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a>count f <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> (\x <span class="ot">-&gt;</span> <span class="kw">if</span> f x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>)</span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a><span class="ot">countArray ::</span> (<span class="dt">A.Unbox</span> a) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Array2</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a>countArray f <span class="ot">=</span> A.sum <span class="op">.</span> A.map (\x <span class="ot">-&gt;</span> <span class="kw">if</span> f x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>)</span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a><span class="ot">flashed ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a>flashed c <span class="ot">=</span> c <span class="op">&gt;</span> <span class="dv">9</span> <span class="op">&amp;&amp;</span> c <span class="op">&lt;</span> <span class="dv">1000</span></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-18"><a href="#cb87-18" aria-hidden="true" tabindex="-1"></a><span class="ot">flashStencil ::</span> <span class="dt">A.Stencil</span> <span class="dt">Ix2</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb87-19"><a href="#cb87-19" aria-hidden="true" tabindex="-1"></a>flashStencil <span class="ot">=</span> A.makeStencil (<span class="dt">A.Sz</span> (<span class="dv">3</span> <span class="op">:.</span> <span class="dv">3</span>)) (<span class="dv">1</span> <span class="op">:.</span> <span class="dv">1</span>) go</span>
<span id="cb87-20"><a href="#cb87-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go get <span class="ot">=</span> <span class="kw">if</span> flashed (get home) <span class="kw">then</span> <span class="dv">1000</span></span>
<span id="cb87-21"><a href="#cb87-21" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">else</span> get home <span class="op">+</span> count (flashed <span class="op">.</span> get) neighbours</span>
<span id="cb87-22"><a href="#cb87-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-23"><a href="#cb87-23" aria-hidden="true" tabindex="-1"></a><span class="ot">flash ::</span> <span class="dt">MonadState</span> (<span class="dt">Array2</span> <span class="dt">Int</span>) m <span class="ot">=&gt;</span> m ()</span>
<span id="cb87-24"><a href="#cb87-24" aria-hidden="true" tabindex="-1"></a>flash <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb87-25"><a href="#cb87-25" aria-hidden="true" tabindex="-1"></a>    n <span class="ot">&lt;-</span> gets <span class="op">$</span> countArray flashed</span>
<span id="cb87-26"><a href="#cb87-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="fu">return</span> ()</span>
<span id="cb87-27"><a href="#cb87-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> modify go <span class="op">&gt;&gt;</span> flash</span>
<span id="cb87-28"><a href="#cb87-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span><span class="ot"> go ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Array2</span> <span class="dt">Int</span></span>
<span id="cb87-29"><a href="#cb87-29" aria-hidden="true" tabindex="-1"></a>          go <span class="ot">=</span> A.compute <span class="op">.</span> A.mapStencil (<span class="dt">A.Fill</span> <span class="dv">0</span>) flashStencil</span></code></pre></div>
</div>
<p>At the <code>reset</code>, I count how many values are larger than 1000, and set them back to 0.</p>
<div class="named-code-block">
<p>«solution-day-11»</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="ot">reset ::</span> <span class="dt">MonadState</span> (<span class="dt">Array2</span> <span class="dt">Int</span>) m <span class="ot">=&gt;</span> m <span class="dt">Int</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>reset <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>    n <span class="ot">&lt;-</span> gets <span class="op">$</span> countArray (<span class="op">&gt;=</span> <span class="dv">1000</span>)</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>    modify <span class="op">$</span> A.compute <span class="op">.</span> A.map (\x <span class="ot">-&gt;</span> <span class="kw">if</span> x <span class="op">&gt;=</span> <span class="dv">1000</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> x)</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> n</span></code></pre></div>
</div>
<p>I put everything in a state monad. The parts A and B have different stopping criteria.</p>
<div class="named-code-block">
<p>«solution-day-11»</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="ot">repeatM ::</span> (<span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m [a]</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>repeatM n a <span class="ot">=</span> loop n</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> loop n</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> n <span class="op">&lt;=</span> <span class="dv">0</span>    <span class="ot">=</span> <span class="fu">pure</span> []</span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> liftA2 (<span class="op">:</span>) a (loop (n <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a>solutionA <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> evalState (repeatM <span class="dv">100</span> step)</span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a><span class="ot">countRepeatUntilM ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m <span class="dt">Int</span></span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a>countRepeatUntilM action <span class="ot">=</span> go <span class="dv">1</span></span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a>            stop <span class="ot">&lt;-</span> action</span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> stop <span class="kw">then</span> <span class="fu">return</span> n <span class="kw">else</span> go (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a>solutionB <span class="ot">=</span> evalState <span class="op">$</span> countRepeatUntilM ((<span class="op">==</span> <span class="dv">100</span>) <span class="op">&lt;$&gt;</span> step)</span></code></pre></div>
</div>
<section id="plots" class="level3">
<h3>Plots</h3>
<p>Iteration 1 through 258 (my answer) of the Dumbo Octopusses. For a long time, there is a majority period of 7 cycles. The basin has a value of 6 then, but is triggered by some event at the boundary of the basin, creating a cascade. When all octopusses synchronize the period lengthens to 10.</p>
<p><img src="fig/day11.svg" class="figure" alt="" /></p>
</section>
</section>
<section id="appendix-boiler-plate" class="level1">
<h1>Appendix: Boiler plate</h1>
<div class="named-code-block">
<p>«run-solutions»</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runA ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env ()</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>runA <span class="ot">=</span> readInput <span class="op">&gt;&gt;=</span> logInfo <span class="op">.</span> display <span class="op">.</span> tshow <span class="op">.</span> solutionA </span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a><span class="ot">runB ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env ()</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>runB <span class="ot">=</span> readInput <span class="op">&gt;&gt;=</span> logInfo <span class="op">.</span> display <span class="op">.</span> tshow <span class="op">.</span> solutionB</span></code></pre></div>
</div>
</section>
<section id="appendix-parsing" class="level1">
<h1>Appendix: Parsing</h1>
<div class="named-code-block">
<p>file:app/Parsing.hs</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Parsing</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>    ( <span class="dt">Parser</span>, hspace, string, char, readInputParsing, lexeme</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>    , integer, eol, sepEndBy1, sepBy1, failOnException, digit )</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.Char</span> (ord)</span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Set</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span></span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>    ( <span class="dt">ParseErrorBundle</span>, <span class="dt">Parsec</span>, parse, errorBundlePretty, sepEndBy1</span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>    , sepBy1, fancyFailure, <span class="dt">ErrorFancy</span>(<span class="op">..</span>) )</span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span> (hspace, string, char, eol)</span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Megaparsec.Char</span> <span class="kw">as</span> <span class="dt">C</span></span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Megaparsec.Char.Lexer</span> <span class="kw">as</span> <span class="dt">L</span></span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-18"><a href="#cb91-18" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Text</span></span>
<span id="cb91-19"><a href="#cb91-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-20"><a href="#cb91-20" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Display</span> (<span class="dt">ParseErrorBundle</span> <span class="dt">Text</span> <span class="dt">Void</span>) <span class="kw">where</span></span>
<span id="cb91-21"><a href="#cb91-21" aria-hidden="true" tabindex="-1"></a>    textDisplay <span class="ot">=</span> Text.pack <span class="op">.</span> errorBundlePretty</span>
<span id="cb91-22"><a href="#cb91-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-23"><a href="#cb91-23" aria-hidden="true" tabindex="-1"></a><span class="ot">failOnException ::</span> (<span class="dt">Exception</span> e) <span class="ot">=&gt;</span> <span class="dt">Either</span> e a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb91-24"><a href="#cb91-24" aria-hidden="true" tabindex="-1"></a>failOnException <span class="ot">=</span> <span class="fu">either</span> convertError <span class="fu">return</span></span>
<span id="cb91-25"><a href="#cb91-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> convertError <span class="ot">=</span> fancyFailure <span class="op">.</span> Set.singleton</span>
<span id="cb91-26"><a href="#cb91-26" aria-hidden="true" tabindex="-1"></a>                       <span class="op">.</span> <span class="dt">ErrorFail</span> <span class="op">.</span> displayException</span>
<span id="cb91-27"><a href="#cb91-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-28"><a href="#cb91-28" aria-hidden="true" tabindex="-1"></a><span class="ot">readInputParsing ::</span> (<span class="dt">MonadReader</span> env m, <span class="dt">MonadIO</span> m, <span class="dt">HasLogFunc</span> env)</span>
<span id="cb91-29"><a href="#cb91-29" aria-hidden="true" tabindex="-1"></a>                 <span class="ot">=&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> m a</span>
<span id="cb91-30"><a href="#cb91-30" aria-hidden="true" tabindex="-1"></a>readInputParsing file p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb91-31"><a href="#cb91-31" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">&lt;-</span> parse p file <span class="op">&lt;$&gt;</span> readFileUtf8 file</span>
<span id="cb91-32"><a href="#cb91-32" aria-hidden="true" tabindex="-1"></a>    <span class="fu">either</span> (\e <span class="ot">-&gt;</span> <span class="kw">do</span> { logError <span class="op">$</span> display e; exitFailure })</span>
<span id="cb91-33"><a href="#cb91-33" aria-hidden="true" tabindex="-1"></a>           <span class="fu">return</span> x</span>
<span id="cb91-34"><a href="#cb91-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-35"><a href="#cb91-35" aria-hidden="true" tabindex="-1"></a><span class="ot">lexeme ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb91-36"><a href="#cb91-36" aria-hidden="true" tabindex="-1"></a>lexeme <span class="ot">=</span> L.lexeme hspace</span>
<span id="cb91-37"><a href="#cb91-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-38"><a href="#cb91-38" aria-hidden="true" tabindex="-1"></a><span class="ot">integer ::</span> <span class="dt">Parser</span> <span class="dt">Int</span></span>
<span id="cb91-39"><a href="#cb91-39" aria-hidden="true" tabindex="-1"></a>integer <span class="ot">=</span> lexeme L.decimal</span>
<span id="cb91-40"><a href="#cb91-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-41"><a href="#cb91-41" aria-hidden="true" tabindex="-1"></a><span class="ot">digit ::</span> <span class="dt">Parser</span> <span class="dt">Int</span></span>
<span id="cb91-42"><a href="#cb91-42" aria-hidden="true" tabindex="-1"></a>digit <span class="ot">=</span> toValue <span class="op">&lt;$&gt;</span> C.digitChar</span>
<span id="cb91-43"><a href="#cb91-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> toValue c <span class="ot">=</span> <span class="fu">ord</span> c <span class="op">-</span> <span class="fu">ord</span> <span class="ch">&#39;0&#39;</span></span></code></pre></div>
</div>
</section>
        </div>
         <div class="col-3 col-s-3 menu" id="menu">
                <nav id="TOC" role="doc-toc">
                                <h2 id="toc-title">Contents</h2>
                                <ul>
                                <li><a href="#advent-of-code-2021">Advent of Code 2021</a></li>
                                <li><a href="#day-1-sonar-sweep">Day 1: Sonar Sweep</a></li>
                                <li><a href="#day-2-dive">Day 2: Dive!</a></li>
                                <li><a href="#day-3-binary-diagnostic">Day 3: Binary Diagnostic</a></li>
                                <li><a href="#day-4-giant-squid">Day 4: Giant Squid</a></li>
                                <li><a href="#day-5-hydrothermal-venture">Day 5: Hydrothermal Venture</a></li>
                                <li><a href="#day-6-lanternfish">Day 6: Lanternfish</a></li>
                                <li><a href="#day-7-the-treachery-of-whales">Day 7: The Treachery of Whales</a></li>
                                <li><a href="#day-8-seven-segment-search">Day 8: Seven Segment Search</a></li>
                                <li><a href="#day-9-smoke-basin">Day 9: Smoke Basin</a></li>
                                <li><a href="#day-10-syntax-scoring">Day 10: Syntax Scoring</a></li>
                                <li><a href="#day-11-dumbo-octopus">Day 11: Dumbo Octopus</a></li>
                                <li><a href="#appendix-boiler-plate">Appendix: Boiler plate</a></li>
                                <li><a href="#appendix-parsing">Appendix: Parsing</a></li>
                                </ul>
                </nav>
        </div> 
</div>
<div class="footer">
</div>
</body>
<!-- This script scrolls the page to top when a link in the TOC is clicked. -->
<script>
   var elems = document.getElementById("TOC").querySelectorAll("a");
   for (var i = 0; i < elems.length; ++i) {
      elems[i].addEventListener("click", clickFunc);
   }
   function clickFunc(e) {
      e.preventDefault();
      window.location.hash = this.hash;
      window.scrollTo(0, 0); 
   }
</script>
   <!-- Set the default landing page. Sections are set display: none by default
        except for the one that is currently the location hash. -->
   <script type="text/javascript">
           if (document.location.hash == "" || document.location.hash == "#") {
                document.location.hash = "#advent-of-code-2021";
                window.scrollTo(0, 0); 
           }
  </script>
</html>
