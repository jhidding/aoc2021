<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Johan Hidding" />
  <title>Advent of Code 2021</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      { color: #cccccc; background-color: #332244; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ffcfaf; } /* Alert */
    code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
    code span.at { } /* Attribute */
    code span.bn { color: #dca3a3; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #f0dfaf; } /* ControlFlow */
    code span.ch { color: #dca3a3; } /* Char */
    code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
    code span.co { color: #7f9f7f; } /* Comment */
    code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
    code span.do { color: #7f9f7f; } /* Documentation */
    code span.dt { color: #dfdfbf; } /* DataType */
    code span.dv { color: #dcdccc; } /* DecVal */
    code span.er { color: #c3bf9f; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #c0bed1; } /* Float */
    code span.fu { color: #efef8f; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
    code span.kw { color: #f0dfaf; } /* Keyword */
    code span.op { color: #f0efd0; } /* Operator */
    code span.ot { color: #efef8f; } /* Other */
    code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
    code span.sc { color: #dca3a3; } /* SpecialChar */
    code span.ss { color: #cc9393; } /* SpecialString */
    code span.st { color: #cc9393; } /* String */
    code span.va { } /* Variable */
    code span.vs { color: #cc9393; } /* VerbatimString */
    code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
  </style>
  <link rel="stylesheet" href="dark.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Advent of Code 2021</h1>
<p class="subtitle">solutions, literally in Haskell</p>
<p class="author">Johan Hidding</p>
</header>
<div class="row">
        <div class="col-6 col-s-9" id="main">
<p><a href="https://entangled.github.io/"><img src="https://img.shields.io/badge/entangled-Use%20the%20source!-%2300aeff" alt="Entangled badge" /></a> <a href="https://github.com/jhidding/aoc2021/"><img src="https://img.shields.io/badge/github-clone%20me-%44ee55ff" alt="Github badge" /></a></p>
<section id="advent-of-code-2021" class="level1">
<h1>Advent of Code 2021</h1>
<p>This year I will publish my solutions for Advent of Code in Haskell, using Entangled to do <strong>Literate Programming</strong>.</p>
<section id="advent-of-code" class="level2">
<h2>Advent of Code</h2>
<p><a href="https://www.adventofcode.com">Advent of Code</a> is an anual coding challenge keeping nerds off the street for the entire merry month of decemeber. This is officially the best way to learn a new programming language or improve on your existing skills.</p>
<div class="warning">
<blockquote>
<h3 id="spoiler-warning">Spoiler warning</h3>
<p>If you’re still trying to solve AOC2021, this site contains spoilers.</p>
</blockquote>
</div>
</section>
<section id="entangled" class="level2">
<h2>Entangled</h2>
<p><a href="https://entangled.github.io">Entangled</a> is a tool for Literate Programming. My challenge for this years’ Advent of Code is to create a set of beautifull solutions, that are completely documented in a literate form. The idea is that the code you see here is the complete solution to a problem. Think of Entangled as a content-management system for code blocks in your Markdown documents. The code blocks are assembled into compilable code, while changes are also tracked back to your markdown files. This means you can still debug and work with your favourite IDE.</p>
</section>
<section id="instructions" class="level2">
<h2>Instructions</h2>
<p>To run this code, I recommend installing Haskell using the <a href="https://www.haskell.org/ghcup/">GHCUp installer</a>. Run all solutions:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">cabal</span> run x2021 <span class="at">--</span> <span class="at">-a</span></span></code></pre></div>
</section>
<section id="generic-remarks" class="level2">
<h2>Generic remarks</h2>
<p>All solutions use the <code>RIO</code> library to replace the standard <code>Prelude</code>. This saves a long list of standard imports and is much better suited to modern Haskell practices. Most of the input parsing is done through <code>Megaparsec</code>, for which I have a submodule that contains some common types and functions, see the <a href="#appendix-boiler-plate">boilerplate section</a>.</p>
</section>
<section id="license" class="level2">
<h2>License</h2>
<p>This code is licensed under the Apache v2 license, see <code>LICENSE</code> file in this repository.</p>
</section>
</section>
<section id="day-1-sonar-sweep" class="level1">
<h1>Day 1: Sonar Sweep</h1>
<p>It seems we are going on a deep dive this year! We are given the height data of a sonar sweep of the bottom of the sea.</p>
<div class="named-code-block">
<p>file:app/Day01.hs</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day01</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> m [<span class="dt">Int</span>]</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    text <span class="ot">&lt;-</span> Text.lines <span class="op">&lt;$&gt;</span> readFileUtf8 <span class="st">&quot;data/day01.txt&quot;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="op">$</span> mapMaybe (readMaybe <span class="op">.</span> Text.unpack) text</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">1</span><span class="op">&gt;&gt;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p><img src="fig/day01.svg" title="My input data" class="figure" alt="My input data" /></p>
<p>The question is: how often do we find this sequence ascending? We may solve this by computing the difference between each consecutive element in the input list. Then we need to know the number of possitive numbers in the difference list:</p>
<div class="named-code-block">
<p>«solution-day-1»</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>solutionA <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> (<span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">.</span> diff</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> diff (a1<span class="op">:</span>a2<span class="op">:</span>as) <span class="ot">=</span> a2 <span class="op">-</span> a1 <span class="op">:</span> diff (a2<span class="op">:</span>as)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>          diff _          <span class="ot">=</span> []</span></code></pre></div>
</div>
<p>In the second part we need to do a sliding sum over the list of input numbers, reducing the problem to that of part A:</p>
<div class="named-code-block">
<p>«solution-day-1»</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>solutionB <span class="ot">=</span> solutionA <span class="op">.</span> slidingSum</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> slidingSum (a1<span class="op">:</span>a2<span class="op">:</span>a3<span class="op">:</span>as) <span class="ot">=</span> a1 <span class="op">+</span> a2 <span class="op">+</span> a3 <span class="op">:</span> slidingSum (a2<span class="op">:</span>a3<span class="op">:</span>as)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>          slidingSum _             <span class="ot">=</span> []</span></code></pre></div>
</div>
<p>In hindsight, a more efficient solution would be:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>solutionB <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> (<span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">.</span> diff3</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> diff3 (a1<span class="op">:</span>a2<span class="op">:</span>a3<span class="op">:</span>a4<span class="op">:</span>as) <span class="ot">=</span> a4 <span class="op">-</span> a1 <span class="op">:</span> diff3 (a2<span class="op">:</span>a3<span class="op">:</span>a4<span class="op">:</span>as)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>          diff3 _                <span class="ot">=</span> []</span></code></pre></div>
<p>The middle terms in the finite difference drop out.</p>
</section>
<section id="day-2-dive" class="level1">
<h1>Day 2: Dive!</h1>
<p>We are given our first mini instruction set! We need to steer the submarine using an instruction set <code>forward</code>, <code>down</code> or <code>up</code> with a number attached. We get to do our first parsing of this year (yay!).</p>
<div class="named-code-block">
<p>file:app/Day02.hs</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day02</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (foldl)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> (readInputParsing, <span class="dt">Parser</span>, lexeme, string, integer, sepEndBy1, eol)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">2</span><span class="op">&gt;&gt;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>We start by defining a datatype and the associated parser:</p>
<div class="named-code-block">
<p>«solution-day-2»</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Instruction</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">GoForward</span> <span class="dt">Int</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">GoUp</span> <span class="dt">Int</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">GoDown</span> <span class="dt">Int</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="ot">instructions ::</span> <span class="dt">Parser</span> [<span class="dt">Instruction</span>]</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>instructions <span class="ot">=</span> sepEndBy1 (lexeme direction <span class="op">&lt;*&gt;</span> integer) eol</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> direction <span class="ot">=</span>   (string <span class="st">&quot;forward&quot;</span> <span class="op">$&gt;</span> <span class="dt">GoForward</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>                    <span class="op">&lt;|&gt;</span> (string <span class="st">&quot;up&quot;</span>      <span class="op">$&gt;</span> <span class="dt">GoUp</span>)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>                    <span class="op">&lt;|&gt;</span> (string <span class="st">&quot;down&quot;</span>    <span class="op">$&gt;</span> <span class="dt">GoDown</span>)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">MonadIO</span> m, <span class="dt">MonadReader</span> env m, <span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> m [<span class="dt">Instruction</span>]</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day02.txt&quot;</span> instructions</span></code></pre></div>
</div>
<p>In the first part, we are asked to do some Turtle movement. We can reduce the set of instructions in a <code>foldl</code> if we define a function that updates the position for each move:</p>
<div class="named-code-block">
<p>«solution-day-2»</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Pos</span> <span class="ot">=</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="ot">moveA ::</span> <span class="dt">Pos</span> <span class="ot">-&gt;</span> <span class="dt">Instruction</span> <span class="ot">-&gt;</span> <span class="dt">Pos</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>moveA (x, y) (<span class="dt">GoForward</span> dx) <span class="ot">=</span> (x <span class="op">+</span> dx, y)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>moveA (x, y) (<span class="dt">GoUp</span> dy)      <span class="ot">=</span> (x, y <span class="op">-</span> dy)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>moveA (x, y) (<span class="dt">GoDown</span> dy)    <span class="ot">=</span> (x, y <span class="op">+</span> dy)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> [<span class="dt">Instruction</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>solutionA inst <span class="ot">=</span> x <span class="op">*</span> y</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> (x, y) <span class="ot">=</span> <span class="fu">foldl</span> moveA (<span class="dv">0</span>, <span class="dv">0</span>) inst</span></code></pre></div>
</div>
<p>In the second part, the interpretation of the instructions changes slightly, but the only thing we have to change is the <code>moveA</code> function and the corresponding accumulator data type (I’m using <code>NamedFieldPuns</code> and <code>RecordWildCards</code>, which I prefer over lenses in these simple cases):</p>
<div class="named-code-block">
<p>«solution-day-2»</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Navigation</span> <span class="ot">=</span> <span class="dt">Navigation</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> navDepth ::</span> <span class="dt">Int</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> navAim   ::</span> <span class="dt">Int</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> navPos   ::</span> <span class="dt">Int</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="ot">moveB ::</span> <span class="dt">Navigation</span> <span class="ot">-&gt;</span> <span class="dt">Instruction</span> <span class="ot">-&gt;</span> <span class="dt">Navigation</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>moveB n<span class="op">@</span><span class="dt">Navigation</span>{<span class="op">..</span>} (<span class="dt">GoForward</span> x) <span class="ot">=</span> n{ navPos <span class="ot">=</span> navPos <span class="op">+</span> x</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>                                        , navDepth <span class="ot">=</span> navDepth <span class="op">+</span> navAim <span class="op">*</span> x }</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>moveB n<span class="op">@</span><span class="dt">Navigation</span>{<span class="op">..</span>} (<span class="dt">GoUp</span> x)      <span class="ot">=</span> n{ navAim <span class="ot">=</span> navAim <span class="op">-</span> x }</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>moveB n<span class="op">@</span><span class="dt">Navigation</span>{<span class="op">..</span>} (<span class="dt">GoDown</span> x)    <span class="ot">=</span> n{ navAim <span class="ot">=</span> navAim <span class="op">+</span> x }</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> [<span class="dt">Instruction</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>solutionB inst <span class="ot">=</span> navPos <span class="op">*</span> navDepth</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> <span class="dt">Navigation</span>{<span class="op">..</span>} <span class="ot">=</span> <span class="fu">foldl</span> moveB (<span class="dt">Navigation</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span>) inst</span></code></pre></div>
</div>
</section>
<section id="day-3-binary-diagnostic" class="level1">
<h1>Day 3: Binary Diagnostic</h1>
<div class="named-code-block">
<p>file:app/Day03.hs</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day03</span> <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List.Partial</span> (foldl1)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> (<span class="dt">Parser</span>, sepEndBy1, char, eol, readInputParsing)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">Vector</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Vector</span> (<span class="dt">Vector</span>)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">3</span><span class="op">&gt;&gt;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>Because of part 2 of this puzzle, I chose to put the bit sequence in a <code>Vector</code>.</p>
<div class="named-code-block">
<p>«solution-day-3»</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Bits</span> <span class="ot">=</span> <span class="dt">Vector</span> <span class="dt">Int</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ot">bitSequence ::</span> <span class="dt">Parser</span> [<span class="dt">Bits</span>]</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>bitSequence <span class="ot">=</span> sepEndBy1 bits eol</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span><span class="ot"> bits ::</span> <span class="dt">Parser</span> <span class="dt">Bits</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>          bits <span class="ot">=</span> Vector.fromList</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>               <span class="op">&lt;$&gt;</span> some (   (char <span class="ch">&#39;0&#39;</span> <span class="op">$&gt;</span> <span class="dv">0</span>)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>                        <span class="op">&lt;|&gt;</span> (char <span class="ch">&#39;1&#39;</span> <span class="op">$&gt;</span> <span class="dv">1</span>))</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env [<span class="dt">Bits</span>]</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day03.txt&quot;</span> bitSequence</span></code></pre></div>
</div>
<p>We need to compute the most common digit for each bit position. I solve this by rounding of the mean bit value.</p>
<div class="named-code-block">
<p>«solution-day-3»</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fromBinary ::</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>fromBinary <span class="ot">=</span> go <span class="dv">0</span> <span class="op">.</span> Vector.toList</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go n (b<span class="op">:</span>bs) <span class="ot">=</span> go (<span class="dv">2</span><span class="op">*</span>n <span class="op">+</span> b) bs</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>          go n []     <span class="ot">=</span> n</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="ot">invertBinary ::</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>invertBinary <span class="ot">=</span> Vector.map (<span class="dv">1</span> <span class="op">-</span>)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="ot">mostCommon ::</span> [<span class="dt">Bits</span>] <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>mostCommon b <span class="ot">=</span> Vector.map ((<span class="ot">`div`</span> <span class="fu">length</span> b) <span class="op">.</span> (<span class="op">*</span> <span class="dv">2</span>))</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>             <span class="op">$</span> <span class="fu">foldl1</span> (Vector.zipWith (<span class="op">+</span>)) b</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="ot">leastCommon ::</span> [<span class="dt">Bits</span>] <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>leastCommon <span class="ot">=</span> invertBinary <span class="op">.</span> mostCommon</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> [<span class="dt">Bits</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>solutionA input <span class="ot">=</span> gammaRate <span class="op">*</span> epsilonRate</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> gammaRate   <span class="ot">=</span> fromBinary mc</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>          epsilonRate <span class="ot">=</span> fromBinary <span class="op">$</span> invertBinary mc</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>          mc <span class="ot">=</span> mostCommon input</span></code></pre></div>
</div>
<p>In the second part we need to filter down on a single bit in each iteration. The most or least common bit value needs to be computed every time, as it changes when bit sequences are filtered out.</p>
<div class="named-code-block">
<p>«solution-day-3»</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">findRating ::</span> ([<span class="dt">Bits</span>] <span class="ot">-&gt;</span> <span class="dt">Bits</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Bits</span>] <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>findRating _ _   [b]  <span class="ot">=</span> b</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>findRating f idx bits <span class="ot">=</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    findRating f (idx <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">$</span> <span class="fu">filter</span> (\b <span class="ot">-&gt;</span> b <span class="op">Vector.!?</span> idx <span class="op">==</span> mc <span class="op">Vector.!?</span> idx) bits</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> mc <span class="ot">=</span> f bits</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="ot">oxygenGeneratorRating ::</span> [<span class="dt">Bits</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>oxygenGeneratorRating <span class="ot">=</span> fromBinary <span class="op">.</span> findRating mostCommon <span class="dv">0</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="ot">co2ScrubberRating ::</span> [<span class="dt">Bits</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>co2ScrubberRating <span class="ot">=</span> fromBinary <span class="op">.</span> findRating leastCommon <span class="dv">0</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> [<span class="dt">Bits</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>solutionB bits <span class="ot">=</span> oxygenGeneratorRating bits <span class="op">*</span> co2ScrubberRating bits</span></code></pre></div>
</div>
</section>
<section id="day-4-giant-squid" class="level1">
<h1>Day 4: Giant Squid</h1>
<p>We’re playing Bingo with a giant squid. This is why I love advent of Code!</p>
<p>Doing contrived array arithmetic is not seen as the strong suit of Haskell. Solving this in Python with NumPy would seem so much easier. I will use the nice <code>Massiv</code> library, that implements multi-dimensional arrays, fancy indexing, stencil operations etc.</p>
<div class="named-code-block">
<p>file:app/Day04.hs</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day04</span> <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span> <span class="kw">hiding</span> (try)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (partition, headMaybe, lastMaybe)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> ( <span class="dt">Parser</span>, sepEndBy1, sepBy1, char, hspace, eol</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>               , integer, lexeme, readInputParsing</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>               , failOnException )</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Massiv.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="kw">data</span><span class="op">-</span>types<span class="op">-</span>day<span class="op">-</span><span class="dv">4</span><span class="op">&gt;&gt;</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day<span class="op">-</span><span class="dv">4</span><span class="op">&gt;&gt;</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">4</span><span class="op">&gt;&gt;</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>We need to have integers that we can mark when we play Bingo. I’ll make a generic <code>Mark</code> container, that contains an extra boolean flag.</p>
<div class="named-code-block">
<p>«data-types-day-4»</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Mark</span> a <span class="ot">=</span> <span class="dt">Mark</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> marked ::</span> <span class="dt">Bool</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> markValue ::</span> a</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="ot">markEq ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Mark</span> a <span class="ot">-&gt;</span> <span class="dt">Mark</span> a</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>markEq v <span class="dt">Mark</span>{ <span class="op">..</span> }</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> v <span class="op">==</span> markValue <span class="ot">=</span> <span class="dt">Mark</span> <span class="dt">True</span>   markValue</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span>      <span class="ot">=</span> <span class="dt">Mark</span> marked markValue</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="ot">unmarked ::</span> <span class="dt">Mark</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>unmarked <span class="ot">=</span> <span class="fu">not</span> <span class="op">.</span> marked</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Board</span> <span class="ot">=</span> <span class="dt">A.Array</span> <span class="dt">A.B</span> <span class="dt">A.Ix2</span> (<span class="dt">Mark</span> <span class="dt">Int</span>)</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bingo</span> <span class="ot">=</span> <span class="dt">Bingo</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> draws ::</span> [<span class="dt">Int</span>]</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> boards ::</span> [<span class="dt">Board</span>]</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
</div>
<p>Next, we need to parse the input data.</p>
<div class="named-code-block">
<p>«parser-day-4»</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">drawsP ::</span> <span class="dt">Parser</span> [<span class="dt">Int</span>]</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>drawsP <span class="ot">=</span> sepBy1 integer (lexeme <span class="op">$</span> char <span class="ch">&#39;,&#39;</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="ot">boardP ::</span> <span class="dt">Parser</span> <span class="dt">Board</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>boardP <span class="ot">=</span> sepEndBy1 row eol <span class="op">&gt;&gt;=</span> toBoard</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> whitespace <span class="ot">=</span> lexeme (<span class="fu">return</span> ())</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>          row <span class="ot">=</span> whitespace <span class="op">&gt;&gt;</span> some (<span class="dt">Mark</span> <span class="dt">False</span> <span class="op">&lt;$&gt;</span> integer)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>          toBoard <span class="ot">=</span> failOnException <span class="op">.</span> A.fromListsM <span class="dt">A.Seq</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="ot">bingoP ::</span> <span class="dt">Parser</span> <span class="dt">Bingo</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>bingoP <span class="ot">=</span> <span class="dt">Bingo</span> <span class="op">&lt;$&gt;</span> drawsP <span class="op">&lt;*</span> eol <span class="op">&lt;*</span> eol <span class="op">&lt;*&gt;</span> sepEndBy1 boardP eol</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env <span class="dt">Bingo</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day04.txt&quot;</span> bingoP</span></code></pre></div>
</div>
<p>We win at Bingo if a row of column on a board is fully marked. The <code>Massiv</code> library provides the nice functions <code>outerSlices</code> and <code>innerSlices</code>, allowing us to traverse all rows and columns:</p>
<div class="named-code-block">
<p>«solution-day-4»</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">win ::</span> <span class="dt">Board</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>win b <span class="ot">=</span> rows <span class="op">||</span> columns</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> rows    <span class="ot">=</span> <span class="fu">any</span> (<span class="fu">all</span> marked) (A.outerSlices b)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>          columns <span class="ot">=</span> <span class="fu">any</span> (<span class="fu">all</span> marked) (A.innerSlices b)</span></code></pre></div>
</div>
<p>Each time a number is called we mark all matching values:</p>
<div class="named-code-block">
<p>«solution-day-4»</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">markBoard ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Board</span> <span class="ot">-&gt;</span> <span class="dt">Board</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>markBoard n b <span class="ot">=</span> markEq n <span class="op">&lt;$&gt;</span> b</span></code></pre></div>
</div>
<p>For part A we need to figure out, the first board to win and the last number that was called. I won’t pretend this is the first implementation I came up with. After also solving part B, it turns out this is the most elegant and generic way to do it. The function <code>winners</code> generates a list of <code>(Int, Board)</code> pairs, giving in order each board winning and on what number:</p>
<div class="named-code-block">
<p>«solution-day-4»</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">winSeq ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Board</span>] <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Board</span>)]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>winSeq []       _       <span class="ot">=</span> []</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>winSeq _        []      <span class="ot">=</span> []</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>winSeq (d<span class="op">:</span>draws) boards <span class="ot">=</span> <span class="fu">map</span> (d,) winners <span class="op">&lt;&gt;</span> winSeq draws losers</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> (winners, losers) <span class="ot">=</span> partition win <span class="op">$</span> markBoard d <span class="op">&lt;$&gt;</span> boards</span></code></pre></div>
</div>
<p>Now, to get the first winner, we can just get the <code>head</code> of the list of all winners:</p>
<div class="named-code-block">
<p>«solution-day-4»</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">score ::</span> (<span class="dt">Int</span>, <span class="dt">Board</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>score (n, b) <span class="ot">=</span> n <span class="op">*</span> <span class="fu">sum</span> (unmarkedValues <span class="op">$</span> A.toList b)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> unmarkedValues <span class="ot">=</span> <span class="fu">map</span> markValue <span class="op">.</span> <span class="fu">filter</span> unmarked</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> <span class="dt">Bingo</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>solutionA <span class="dt">Bingo</span>{<span class="op">..</span>} <span class="ot">=</span> score <span class="op">&lt;$&gt;</span> headMaybe (winSeq draws boards)</span></code></pre></div>
</div>
<p>For part B we need to know the last board to win, which is now a trivial ajustment:</p>
<div class="named-code-block">
<p>«solution-day-4»</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> <span class="dt">Bingo</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>solutionB <span class="dt">Bingo</span>{<span class="op">..</span>} <span class="ot">=</span> score <span class="op">&lt;$&gt;</span> lastMaybe (winSeq draws boards)</span></code></pre></div>
</div>
</section>
<section id="day-5-hydrothermal-venture" class="level1">
<h1>Day 5: Hydrothermal Venture</h1>
<p>We need to plot a map of hydrothermal vents on a grid. We are given lists of coordinates in the form <code>x1,y1 -&gt; x2,y2</code>. Since we are plotting on 2D grids again, I reach for my friend <code>Massiv</code>. Today, we’ll see how to program in Haskell like its Fortran 77.</p>
<div class="named-code-block">
<p>file:app/Day05.hs</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day05</span> <span class="kw">where</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span> <span class="kw">hiding</span> (try)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.ByteString</span> (putStr)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List.Partial</span> (foldl1)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (partition, headMaybe, lastMaybe)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> ( <span class="dt">Parser</span>, sepEndBy1, sepBy1, char, hspace, eol</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>               , integer, lexeme, readInputParsing</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>               , string )</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Massiv.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Massiv.Array.Mutable</span> <span class="kw">as</span> <span class="dt">MA</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="kw">data</span><span class="op">-</span>types<span class="op">-</span>day<span class="op">-</span><span class="dv">5</span><span class="op">&gt;&gt;</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day<span class="op">-</span><span class="dv">5</span><span class="op">&gt;&gt;</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">5</span><span class="op">&gt;&gt;</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>extra<span class="op">-</span>day<span class="op">-</span><span class="dv">5</span><span class="op">&gt;&gt;</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p><img src="fig/day05-input.svg" title="My input data" class="figure" alt="My input data" /></p>
<p>I like to have position variables that I can treat like applicatives.</p>
<div class="named-code-block">
<p>«data-types-day-5»</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Vec2</span> a <span class="ot">=</span> <span class="dt">Vec2</span> (a, a)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Vec2</span> a) <span class="kw">where</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">show</span> (<span class="dt">Vec2</span> (x, y)) <span class="ot">=</span> <span class="st">&quot;(&quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> x <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> y <span class="op">&lt;&gt;</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Vec2</span> <span class="kw">where</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Vec2</span> (x, y)) <span class="ot">=</span> <span class="dt">Vec2</span> (f x, f y)</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Vec2</span> <span class="kw">where</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">Vec2</span> (x, x)</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    liftA2 f (<span class="dt">Vec2</span> (ax, ay)) (<span class="dt">Vec2</span> (bx, by)) <span class="ot">=</span> <span class="dt">Vec2</span> (f ax bx, f ay by)</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Pos</span> <span class="ot">=</span> <span class="dt">Vec2</span> <span class="dt">Int</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="ot">pos ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Pos</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>pos x y <span class="ot">=</span> <span class="dt">Vec2</span> (x, y)</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Line</span> <span class="ot">=</span> (<span class="dt">Pos</span>, <span class="dt">Pos</span>)</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a><span class="ot">makeLine ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Line</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>makeLine x1 y1 x2 y2 <span class="ot">=</span> (pos x1 y1, pos x2 y2)</span></code></pre></div>
</div>
<p>Now we can parse the list of lines:</p>
<div class="named-code-block">
<p>«parser-day-5»</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lineP ::</span> <span class="dt">Parser</span> <span class="dt">Line</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>lineP <span class="ot">=</span> makeLine <span class="op">&lt;$&gt;</span> integer <span class="op">&lt;*</span> lexeme (char <span class="ch">&#39;,&#39;</span>) <span class="op">&lt;*&gt;</span> integer</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>                 <span class="op">&lt;*</span>  lexeme (string <span class="st">&quot;-&gt;&quot;</span>)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>                 <span class="op">&lt;*&gt;</span> integer <span class="op">&lt;*</span> lexeme (char <span class="ch">&#39;,&#39;</span>) <span class="op">&lt;*&gt;</span> integer</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env [<span class="dt">Line</span>]</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day05.txt&quot;</span> (sepEndBy1 lineP eol)</span></code></pre></div>
</div>
<p>We need to plot the lines on a diagram. I will be using the <code>ST</code> monad to do mutations on the diagram sequentially.</p>
<div class="named-code-block">
<p>«data-types-day-5»</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Diagram</span> <span class="ot">=</span> <span class="dt">A.Array</span> <span class="dt">A.P</span> <span class="dt">A.Ix2</span> <span class="dt">Int</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">MutDiagram</span> s <span class="ot">=</span> <span class="dt">MA.MArray</span> s <span class="dt">A.P</span> <span class="dt">A.Ix2</span> <span class="dt">Int</span></span></code></pre></div>
</div>
<p>We need to know the min/max coordinates of the lines.</p>
<div class="named-code-block">
<p>«solution-day-5»</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lineMinMax ::</span> <span class="dt">Line</span> <span class="ot">-&gt;</span> (<span class="dt">Pos</span>, <span class="dt">Pos</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>lineMinMax (a, b) <span class="ot">=</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> a <span class="op">&lt;*&gt;</span> b, <span class="fu">max</span> <span class="op">&lt;$&gt;</span> a <span class="op">&lt;*&gt;</span> b)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="ot">totalMinMax ::</span> [<span class="dt">Line</span>] <span class="ot">-&gt;</span> (<span class="dt">Pos</span>, <span class="dt">Pos</span>)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>totalMinMax ls <span class="ot">=</span> <span class="fu">foldl1</span> minMax <span class="op">$</span> lineMinMax <span class="op">&lt;$&gt;</span> ls</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> minMax (a, b) (c, d) <span class="ot">=</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> a <span class="op">&lt;*&gt;</span> c, <span class="fu">max</span> <span class="op">&lt;$&gt;</span> b <span class="op">&lt;*&gt;</span> d)</span></code></pre></div>
</div>
<section id="part-a" class="level3">
<h3>Part A</h3>
<p>In part A, we only need to treat the lines that are vertical or horizontal. We can write a routine that plots the line on the diagram, given a list of coordinates:</p>
<div class="named-code-block">
<p>«solution-day-5»</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">plotCoords ::</span> <span class="dt">MutDiagram</span> s <span class="ot">-&gt;</span> [<span class="dt">A.Ix2</span>] <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>plotCoords d <span class="ot">=</span> <span class="fu">mapM_</span> (MA.modify_ d (<span class="fu">return</span> <span class="op">.</span> (<span class="op">+</span> <span class="dv">1</span>)))</span></code></pre></div>
</div>
<p>Now we need to generate the list of coordinates, taking care that origin and end point can be flipped. I make a generic function that splits on several cases:</p>
<div class="named-code-block">
<p>«solution-day-5»</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">range</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="fu">range</span> a b</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a <span class="op">&gt;</span> b <span class="ot">=</span> <span class="fu">reverse</span> [b <span class="op">..</span> a]</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> [a <span class="op">..</span> b]</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="ot">lineCoords ::</span> <span class="dt">Line</span> <span class="ot">-&gt;</span> [<span class="dt">A.Ix2</span>]</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>lineCoords l</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>day<span class="op">-</span><span class="dv">5</span><span class="op">-</span>line<span class="op">-</span>cases<span class="op">&gt;&gt;</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;Illegal line: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> l</span></code></pre></div>
</div>
<section id="horizontal" class="level4">
<h4>Horizontal</h4>
<div class="named-code-block">
<p>«day-5-line-cases»</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> horizontal l <span class="ot">=</span> horizontalCoords l</span></code></pre></div>
</div>
<div class="named-code-block">
<p>«solution-day-5»</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">horizontal ::</span> <span class="dt">Line</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>horizontal (<span class="dt">Vec2</span> (_, ay), <span class="dt">Vec2</span> (_, by)) <span class="ot">=</span> ay <span class="op">==</span> by</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="ot">horizontalCoords ::</span> <span class="dt">Line</span> <span class="ot">-&gt;</span> [<span class="dt">A.Ix2</span>]</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>horizontalCoords (<span class="dt">Vec2</span> (ax, y), <span class="dt">Vec2</span> (bx, _))</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> A.toIx2 <span class="op">.</span> (,y) <span class="op">&lt;$&gt;</span> <span class="fu">range</span> ax bx</span></code></pre></div>
</div>
</section>
<section id="vertical" class="level4">
<h4>Vertical</h4>
<div class="named-code-block">
<p>«day-5-line-cases»</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> vertical l <span class="ot">=</span> verticalCoords l</span></code></pre></div>
</div>
<div class="named-code-block">
<p>«solution-day-5»</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">vertical ::</span> <span class="dt">Line</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>vertical (<span class="dt">Vec2</span> (ax, _), <span class="dt">Vec2</span> (bx, _)) <span class="ot">=</span> ax <span class="op">==</span> bx</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="ot">verticalCoords ::</span> <span class="dt">Line</span> <span class="ot">-&gt;</span> [<span class="dt">A.Ix2</span>]</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>verticalCoords (<span class="dt">Vec2</span> (x, ay), <span class="dt">Vec2</span> (_, by))</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> A.toIx2 <span class="op">.</span> (x,) <span class="op">&lt;$&gt;</span> <span class="fu">range</span> ay by</span></code></pre></div>
</div>
<p>Now, for the solution:</p>
<div class="named-code-block">
<p>«solution-day-5»</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ot">plotLines ::</span> [<span class="dt">Line</span>] <span class="ot">-&gt;</span> <span class="dt">Diagram</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>plotLines l <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    arr <span class="ot">&lt;-</span> MA.newMArray (<span class="dt">A.Sz2</span> <span class="dv">1000</span> <span class="dv">1000</span>) <span class="dv">0</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mapM_</span> (plotCoords arr <span class="op">.</span> lineCoords) l</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    MA.freezeS arr</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> [<span class="dt">Line</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>solutionA <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> (<span class="op">&gt;</span> <span class="dv">1</span>) <span class="op">.</span> A.toList </span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>          <span class="op">.</span> plotLines <span class="op">.</span> <span class="fu">filter</span> (<span class="fu">not</span> <span class="op">.</span> diagonal)</span></code></pre></div>
</div>
</section>
</section>
<section id="part-b" class="level3">
<h3>Part B</h3>
<p>Adding the case of diagonal lines:</p>
<div class="named-code-block">
<p>«day-5-line-cases»</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> diagonal l <span class="ot">=</span> diagonalCoords l</span></code></pre></div>
</div>
<div class="named-code-block">
<p>«solution-day-5»</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="ot">diagonal ::</span> <span class="dt">Line</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>diagonal (<span class="dt">Vec2</span> (ax, ay), <span class="dt">Vec2</span> (bx, by))</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="fu">abs</span> (ax <span class="op">-</span> bx) <span class="op">==</span> <span class="fu">abs</span> (ay <span class="op">-</span> by)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="ot">diagonalCoords ::</span> <span class="dt">Line</span> <span class="ot">-&gt;</span> [<span class="dt">A.Ix2</span>]</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>diagonalCoords (<span class="dt">Vec2</span> (ax, ay), <span class="dt">Vec2</span> (bx, by))</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> A.toIx2 <span class="op">&lt;$&gt;</span> <span class="fu">zip</span> (<span class="fu">range</span> ax bx) (<span class="fu">range</span> ay by)</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> [<span class="dt">Line</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>solutionB <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> (<span class="op">&gt;</span> <span class="dv">1</span>) <span class="op">.</span> A.toList <span class="op">.</span> plotLines</span></code></pre></div>
</div>
<p><img src="fig/day05-output.svg" title="My output data" class="figure" alt="My output data" /></p>
</section>
</section>
<section id="day-6-lanternfish" class="level1">
<h1>Day 6: Lanternfish</h1>
<p>We need to simulate the number of lanternfish, each with a timer, spawning new lanternfish etc. Since we have an exponential growth process, to simulate this naively would be stupid, which is kind of the point of the exercise. We only have nine possible states for each fish, so instead we can tally <strong>how many</strong> lanternfish exist in each state. It turns out however, that programming it the stupid way first, turns this innocent looking exercise into a nice lesson on <strong>Constraint Kinds</strong>.</p>
<div class="named-code-block">
<p>file:app/Day06.hs</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day06</span> <span class="kw">where</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (foldl)</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List.Partial</span> (last)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> ( <span class="dt">Parser</span>, readInputParsing, sepEndBy1</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>               , lexeme, char, integer)</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.Map</span> (<span class="dt">Map</span>, (!?))</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>imports<span class="op">-</span>day<span class="op">-</span><span class="dv">6</span><span class="op">&gt;&gt;</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day<span class="op">-</span><span class="dv">6</span><span class="op">&gt;&gt;</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">6</span><span class="op">&gt;&gt;</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>As always, we first parse the input:</p>
<div class="named-code-block">
<p>«parser-day-6»</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="ot">csvInts ::</span> <span class="dt">Parser</span> [<span class="dt">Int</span>]</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>csvInts <span class="ot">=</span> sepEndBy1 integer (lexeme (char <span class="ch">&#39;,&#39;</span>))</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env [<span class="dt">Int</span>]</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day06.txt&quot;</span> csvInts</span></code></pre></div>
</div>
<p>The point of the exercise is that we can have a naive solution, which I implement here just for fun:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rules ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>rules clock</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> clock <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> [<span class="dv">8</span>, <span class="dv">6</span>]</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span>  <span class="ot">=</span> [clock <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="ot">step ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>step <span class="ot">=</span> (<span class="op">&gt;&gt;=</span> rules)</span></code></pre></div>
<p>We then iterate the <code>step</code> any number of times and get the length of the result:</p>
<div class="named-code-block">
<p>«solution-day-6»</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">iterate</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="fu">iterate</span> n f x</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> n <span class="op">==</span> <span class="dv">0</span>    <span class="ot">=</span> [x]</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> x <span class="op">:</span> <span class="fu">iterate</span> (n <span class="op">-</span> <span class="dv">1</span>) f (f x)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>solutionA <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">last</span> <span class="op">.</span> <span class="fu">iterate</span> <span class="dv">80</span> step</span></code></pre></div>
</div>
<p>The problem is that this solution doesn’t scale very well. To solve this more efficiently, we should keep track of how many fish are present in each state, then we can solve this problem in constant memory.</p>
<p>For tallying the amount of lanternfish in each state, I like to use a <code>Map Int Int</code>.</p>
<div class="named-code-block">
<p>«tally»</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Tally</span> a <span class="ot">=</span> <span class="dt">Tally</span> {<span class="ot"> tallyMap ::</span> <span class="dt">Map</span> a <span class="dt">Integer</span> }</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
</div>
<p>Now we can implement <code>Semigroup</code> and <code>Monoid</code>:</p>
<div class="named-code-block">
<p>«tally»</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Tally</span> a) <span class="kw">where</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Tally</span> a <span class="op">&lt;&gt;</span> <span class="dt">Tally</span> b <span class="ot">=</span> <span class="dt">Tally</span> <span class="op">$</span> Map.unionWith (<span class="op">+</span>) a b</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Tally</span> a) <span class="kw">where</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Tally</span> <span class="fu">mempty</span></span></code></pre></div>
</div>
<p>Now we could do something like,</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="ot">multiply ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tally</span> a</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>multiply items n <span class="ot">=</span> <span class="fu">foldMap</span> (\k <span class="ot">-&gt;</span> <span class="dt">Tally</span> <span class="op">$</span> Map.singleton k n) items</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="fu">concatMap</span><span class="ot"> ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> <span class="dt">Tally</span> a <span class="ot">-&gt;</span> <span class="dt">Tally</span> a</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="fu">concatMap</span> f (<span class="dt">Tally</span> a) <span class="ot">=</span> Map.foldMapWithKey (multiply <span class="op">.</span> f) a</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="ot">step ::</span> <span class="dt">Tally</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tally</span> <span class="dt">Int</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>step <span class="ot">=</span> <span class="fu">concatMap</span> rules</span></code></pre></div>
<p>However, things could be even pretier if we could define something like <code>Applicative</code> on <code>Tally</code>.</p>
<section id="associated-constraint-types" class="level2">
<h2>Associated Constraint Types</h2>
<p>What if we could implement the naive version of this problem in such a way that we can easily scale it up later? We could say:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rules ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Semigroup</span> (f <span class="dt">Int</span>)) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> f <span class="dt">Int</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>rules clock</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> clock <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="fu">pure</span> <span class="dv">8</span> <span class="op">&lt;&gt;</span> <span class="fu">pure</span> <span class="dv">6</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span>  <span class="ot">=</span> <span class="fu">pure</span> (clock <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>But this comes with another problem: our intended container <code>Tally</code> can never be a <code>Functor</code> or <code>Applicative</code>, since it only works on sortable <code>Ord</code> types. This kind of problem can only be solved if we are allowed associated constraint types with our class implementation. For this to work you need to enable the <code>TypeFamilies</code> and <code>ConstraintKinds</code> language extensions enabled.</p>
<p>We have to reimplement the <code>Functor &gt; Applicative &gt; Monad</code> stack.</p>
<div class="named-code-block">
<p>«tally»</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">CFunctor</span> f <span class="kw">where</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">ElemCt</span> f<span class="ot"> a ::</span> <span class="dt">Constraint</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    cmap ::</span> (<span class="dt">ElemCt</span> f a, <span class="dt">ElemCt</span> f b) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">CFunctor</span> f <span class="ot">=&gt;</span> <span class="dt">CApplicative</span> f <span class="kw">where</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    cpure ::</span> (<span class="dt">ElemCt</span> f a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    cliftA2 ::</span> (<span class="dt">ElemCt</span> f a, <span class="dt">ElemCt</span> f b, <span class="dt">ElemCt</span> f c)</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>            <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</span></code></pre></div>
</div>
<p>It is already impossible to implement the constraint version of <code>&lt;*&gt;</code> from the type signature. The default implementation of <code>cliftA2 id</code> assumes <code>ElemCt f (b -&gt; c)</code> which we can never guarantee. There is no problem however defining <code>CMonad</code>.</p>
<div class="named-code-block">
<p>«tally»</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">CApplicative</span> f <span class="ot">=&gt;</span> <span class="dt">CMonad</span> f <span class="kw">where</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    cbind ::</span> (<span class="dt">ElemCt</span> f a, <span class="dt">ElemCt</span> f b) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
</div>
<p>With these type classes in place, we can rewrite the solution to todays problem once again:</p>
<div class="named-code-block">
<p>«solution-day-6»</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rules ::</span> (<span class="dt">CApplicative</span> f, <span class="dt">ElemCt</span> f <span class="dt">Int</span>, <span class="dt">Semigroup</span> (f <span class="dt">Int</span>)) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> f <span class="dt">Int</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>rules fish</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> fish <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> cpure <span class="dv">8</span> <span class="op">&lt;&gt;</span> cpure <span class="dv">6</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> cpure (fish <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="ot">step ::</span> (<span class="dt">CMonad</span> f, <span class="dt">ElemCt</span> f <span class="dt">Int</span>, <span class="dt">Semigroup</span> (f <span class="dt">Int</span>)) <span class="ot">=&gt;</span> f <span class="dt">Int</span> <span class="ot">-&gt;</span> f <span class="dt">Int</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>step <span class="ot">=</span> cbind rules</span></code></pre></div>
</div>
<section id="implementation-for-list" class="level3">
<h3>Implementation for List</h3>
<p>There is the little annoyance that we need to be able to signal an <code>Empty</code> constraint:</p>
<div class="named-code-block">
<p>«tally»</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">EmptyCt</span> a</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">EmptyCt</span> a</span></code></pre></div>
</div>
<p>We now need to implement <code>CMonad</code> on lists and we should have our first naive implementation back in working order.</p>
<div class="named-code-block">
<p>«tally»</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">CFunctor</span> [] <span class="kw">where</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">ElemCt</span> [] a <span class="ot">=</span> <span class="dt">EmptyCt</span> a</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    cmap <span class="ot">=</span> <span class="fu">fmap</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">CApplicative</span> [] <span class="kw">where</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    cpure <span class="ot">=</span> <span class="fu">pure</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    cliftA2 <span class="ot">=</span> liftA2</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">CMonad</span> [] <span class="kw">where</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    cbind <span class="ot">=</span> (<span class="op">=&lt;&lt;</span>)</span></code></pre></div>
</div>
<p>This even means we could have <code>do</code> notation on constraint monads without loss of generality!</p>
</section>
<section id="implementation-for-tally" class="level3">
<h3>Implementation for <code>Tally</code></h3>
<div class="named-code-block">
<p>«tally»</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">CFunctor</span> <span class="dt">Tally</span> <span class="kw">where</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">ElemCt</span> <span class="dt">Tally</span> a <span class="ot">=</span> <span class="dt">Ord</span> a</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>    cmap f (<span class="dt">Tally</span> a) <span class="ot">=</span> Map.foldMapWithKey (\k v <span class="ot">-&gt;</span> <span class="dt">Tally</span> (Map.singleton (f k) v)) a</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="ot">multiply ::</span> <span class="dt">Tally</span> a <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Tally</span> a</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>multiply (<span class="dt">Tally</span> a) n <span class="ot">=</span> <span class="dt">Tally</span> (Map.map (<span class="op">*</span> n) a)</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">CApplicative</span> <span class="dt">Tally</span> <span class="kw">where</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    cpure a <span class="ot">=</span> <span class="dt">Tally</span> <span class="op">$</span> Map.singleton a <span class="dv">1</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>    cliftA2 f (<span class="dt">Tally</span> a) b <span class="ot">=</span> Map.foldMapWithKey</span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>            (\k v <span class="ot">-&gt;</span> multiply (cmap (f k) b) v) a</span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">CMonad</span> <span class="dt">Tally</span> <span class="kw">where</span></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>    cbind f (<span class="dt">Tally</span> a) <span class="ot">=</span> Map.foldMapWithKey (multiply <span class="op">.</span> f) a</span></code></pre></div>
</div>
<p>Notice that the implementation of <code>cliftA2</code> is as if the elements were all stored in a list. This is motivated by the linear property that <code>(f &lt;*&gt; a) &lt;&gt; (f &lt;*&gt; b) == f &lt;*&gt; (a &lt;&gt; b)</code>. We don’t need <code>cliftA2</code> in our problem, but I included it here for completeness.</p>
<div class="named-code-block">
<p>«tally»</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="ot">size ::</span> <span class="dt">Tally</span> a <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>size (<span class="dt">Tally</span> a) <span class="ot">=</span> <span class="fu">sum</span> <span class="op">$</span> Map.elems a</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="ot">singleton ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tally</span> a</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>singleton <span class="ot">=</span> cpure</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="ot">fromList ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Tally</span> a</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>fromList <span class="ot">=</span> <span class="fu">foldMap</span> cpure</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a><span class="ot">distinct ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tally</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>distinct (<span class="dt">Tally</span> a) <span class="ot">=</span> Map.keys a</span></code></pre></div>
</div>
<div class="named-code-block">
<p>file:app/Tally.hs</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Tally</span> <span class="kw">where</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Constraint</span> (<span class="dt">Constraint</span>)</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>tally<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«imports-day-6»</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Tally</span> (<span class="dt">Tally</span>, <span class="dt">CFunctor</span>(..), <span class="dt">CApplicative</span>(..), <span class="dt">CMonad</span>(..), <span class="dt">ElemCt</span>)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Tally</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«solution-day-6»</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>solutionB <span class="ot">=</span> Tally.size <span class="op">.</span> <span class="fu">last</span> <span class="op">.</span> <span class="fu">iterate</span> <span class="dv">256</span> step <span class="op">.</span> Tally.fromList</span></code></pre></div>
</div>
</section>
</section>
</section>
<section id="day-7-the-treachery-of-whales" class="level1">
<h1>Day 7: The Treachery of Whales</h1>
<p>But I like whales! We need to minimize a cost function. We have a list of integers, so we can reuse the parser from Day 6.</p>
<div class="named-code-block">
<p>file:app/Day07.hs</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day07</span> <span class="kw">where</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (sort)</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List.Partial</span> ((!!))</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> ( <span class="dt">Parser</span>, readInputParsing, sepEndBy1</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>               , lexeme, char, integer)</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day<span class="op">-</span><span class="dv">7</span><span class="op">&gt;&gt;</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">7</span><span class="op">&gt;&gt;</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«parser-day-7»</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="ot">csvInts ::</span> <span class="dt">Parser</span> [<span class="dt">Int</span>]</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>csvInts <span class="ot">=</span> sepEndBy1 integer (lexeme (char <span class="ch">&#39;,&#39;</span>))</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env [<span class="dt">Int</span>]</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day07.txt&quot;</span> csvInts</span></code></pre></div>
</div>
<p>We minimize the function,</p>
<p><span class="math display">\[f_a(x) = \sum_{i=1}^N |c_i - x|.\]</span></p>
<p>We know that the solution should be translation invariant. For <span class="math inline">\(N=2\)</span> the cost function is equal at any point in between, only for <span class="math inline">\(N=3\)</span> do we start to get a minimum, at the center most point. That would suggest a median. If we remove the outer two most points, the answer stays the same, repeat and we arrive at the center most point. Proven! Since we’re only interested in the value attained at the minimum, it doesn’t matter if we take the upper or lower median for even length sequences.</p>
<div class="named-code-block">
<p>«solution-day-7»</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="ot">costFuncA ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>costFuncA cs x <span class="ot">=</span> <span class="fu">sum</span> (<span class="fu">map</span> (<span class="fu">abs</span> <span class="op">.</span> (x <span class="op">-</span>)) cs)</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="ot">median ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>median x <span class="ot">=</span> <span class="fu">sort</span> x <span class="op">!!</span> (<span class="fu">length</span> x <span class="ot">`div`</span> <span class="dv">2</span>)</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>solutionA as <span class="ot">=</span> (loc, costFuncA as loc)</span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> loc <span class="ot">=</span> <span class="fu">sort</span> as <span class="op">!!</span> (<span class="fu">length</span> as <span class="ot">`div`</span> <span class="dv">2</span>)</span></code></pre></div>
</div>
<p>For part B, we get a distance function that goes like <span class="math inline">\(\sum_{i=1}^d d = d (d + 1) / 2\)</span>, where <span class="math inline">\(d = |c_i - x|.\)</span> We arrive at a minimum at the mean <span class="math inline">\(x = \langle c_i \rangle\)</span>, and I can prove it. The cost function now is,</p>
<p><span class="math display">\[f_b(x) = \sum_{i=1}^N |c_i - x| (|c_i -x| + 1) / 2 = \sum_{i=1}^N \frac{1}{2}(c_i - x)^2 + \frac{1}{2}|c_i - x|.\]</span></p>
<p>For the square part, we have that the minimum of <span class="math inline">\(\sum (c_i - x)^2\)</span> is found at,</p>
<p><span class="math display">\[\partial_x \sum (c_i - x)^2 / 2 = \sum x - c_i = Nx - \sum c_i = 0,\]</span></p>
<p>so <span class="math inline">\(x = \sum c_i / N = \langle c_i \rangle\)</span>, which is where we actually found our answer. The residual term of</p>
<p><span class="math display">\[\sum |c_i - x| / 2\]</span></p>
<p>is not differentiable, but we know how fast it grows. Since we have increments of 1, the quadratic term always grows equal or faster. Again, we’re only interested in the value, not the location of the minimum, so there we have it.</p>
<div class="named-code-block">
<p>«solution-day-7»</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="ot">costFuncB ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>costFuncB cs x <span class="ot">=</span> <span class="fu">sum</span> (<span class="fu">map</span> f cs)</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> f c <span class="ot">=</span> <span class="fu">abs</span> (x <span class="op">-</span> c) <span class="op">*</span> (<span class="fu">abs</span> (x <span class="op">-</span> c) <span class="op">+</span> <span class="dv">1</span>) <span class="ot">`div`</span> <span class="dv">2</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="ot">mean ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>mean x <span class="ot">=</span> <span class="fu">sum</span> x <span class="ot">`div`</span> <span class="fu">length</span> x</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>solutionB x <span class="ot">=</span> (loc, costFuncB x loc)</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> loc <span class="ot">=</span> mean x</span></code></pre></div>
</div>
</section>
<section id="day-8-seven-segment-search" class="level1">
<h1>Day 8: Seven Segment Search</h1>
<p>Oh boy. This was a really nice puzzle. I think I managed to put the solution into readable code also.</p>
<div class="named-code-block">
<p>file:app/Day08.hs</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day08</span> <span class="kw">where</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (foldl, find)</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Map.Lazy</span> (<span class="dt">Map</span>, (!?))</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Lazy</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Tuple</span> (swap)</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Set</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> ( <span class="dt">Parser</span>, readInputParsing, sepEndBy1</span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>               , lexeme, char, eol)</span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> (takeWhile1P)</span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="kw">data</span><span class="op">-</span>types<span class="op">-</span>day<span class="op">-</span><span class="dv">8</span><span class="op">&gt;&gt;</span></span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day<span class="op">-</span><span class="dv">8</span><span class="op">&gt;&gt;</span></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">8</span><span class="op">&gt;&gt;</span></span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>I’ll define a <code>Digit</code> as a <code>Set Char</code> and add some operations. We get the number 8 for free, and we can use it to invert other digits.</p>
<div class="named-code-block">
<p>«data-types-day-8»</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Digit</span> <span class="ot">=</span> <span class="dt">Digit</span> {<span class="ot"> digitSet ::</span> <span class="dt">Set</span> <span class="dt">Char</span> }</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Ord</span>, <span class="dt">Eq</span>)</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">Digit</span> <span class="kw">where</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Digit</span> a <span class="op">&lt;&gt;</span> <span class="dt">Digit</span> b <span class="ot">=</span> <span class="dt">Digit</span> <span class="op">$</span> (a <span class="dt">Set</span><span class="op">.</span>\\ b) <span class="ot">`Set.union`</span> (b <span class="dt">Set</span><span class="op">.</span>\\ a)</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Digit</span> <span class="kw">where</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Digit</span> <span class="fu">mempty</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a><span class="ot">eight ::</span> <span class="dt">Digit</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>eight <span class="ot">=</span> <span class="dt">Digit</span> <span class="op">$</span> Set.fromList [<span class="ch">&#39;a&#39;</span><span class="op">..</span><span class="ch">&#39;g&#39;</span>]</span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;&lt;&lt;) ::</span> <span class="dt">Digit</span> <span class="ot">-&gt;</span> <span class="dt">Digit</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a><span class="dt">Digit</span> a <span class="op">&lt;&lt;&lt;</span> <span class="dt">Digit</span> b <span class="ot">=</span> a <span class="ot">`Set.isSubsetOf`</span> b</span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>(\\)<span class="ot"> ::</span> <span class="dt">Digit</span> <span class="ot">-&gt;</span> <span class="dt">Digit</span> <span class="ot">-&gt;</span> <span class="dt">Digit</span></span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a><span class="dt">Digit</span> a \\ <span class="dt">Digit</span> b <span class="ot">=</span> <span class="dt">Digit</span> <span class="op">$</span> a <span class="dt">Set</span><span class="op">.</span>\\ b</span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-19"><a href="#cb59-19" aria-hidden="true" tabindex="-1"></a><span class="ot">invert ::</span> <span class="dt">Digit</span> <span class="ot">-&gt;</span> <span class="dt">Digit</span></span>
<span id="cb59-20"><a href="#cb59-20" aria-hidden="true" tabindex="-1"></a>invert <span class="ot">=</span> (eight \\)</span>
<span id="cb59-21"><a href="#cb59-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-22"><a href="#cb59-22" aria-hidden="true" tabindex="-1"></a><span class="ot">numberOfSegments ::</span> <span class="dt">Digit</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb59-23"><a href="#cb59-23" aria-hidden="true" tabindex="-1"></a>numberOfSegments (<span class="dt">Digit</span> a) <span class="ot">=</span> Set.size a</span>
<span id="cb59-24"><a href="#cb59-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-25"><a href="#cb59-25" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Line</span> <span class="ot">=</span> <span class="dt">Line</span></span>
<span id="cb59-26"><a href="#cb59-26" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> signalPattern ::</span> [<span class="dt">Digit</span>]</span>
<span id="cb59-27"><a href="#cb59-27" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> outputValues  ::</span> [<span class="dt">Digit</span>]</span>
<span id="cb59-28"><a href="#cb59-28" aria-hidden="true" tabindex="-1"></a>    } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
</div>
<p>Made a superfluous parser for the characters ‘a’ through ‘g’.</p>
<div class="named-code-block">
<p>«parser-day-8»</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="ot">word ::</span> <span class="dt">Parser</span> <span class="dt">Text</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>word <span class="ot">=</span> lexeme <span class="op">$</span> takeWhile1P (<span class="dt">Just</span> <span class="st">&quot;letter a-g&quot;</span>) (\c <span class="ot">-&gt;</span> c <span class="op">&gt;=</span> <span class="ch">&#39;a&#39;</span> <span class="op">&amp;&amp;</span> c <span class="op">&lt;=</span> <span class="ch">&#39;g&#39;</span>)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="ot">charSet ::</span> <span class="dt">Parser</span> <span class="dt">Digit</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>charSet <span class="ot">=</span> <span class="dt">Digit</span> <span class="op">.</span> Set.fromList <span class="op">.</span> Text.unpack <span class="op">&lt;$&gt;</span> word</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a><span class="ot">lineP ::</span> <span class="dt">Parser</span> <span class="dt">Line</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>lineP <span class="ot">=</span> <span class="dt">Line</span> <span class="op">&lt;$&gt;</span> some charSet <span class="op">&lt;*</span> lexeme (char <span class="ch">&#39;|&#39;</span>) <span class="op">&lt;*&gt;</span> some charSet</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env [<span class="dt">Line</span>]</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day08.txt&quot;</span> (sepEndBy1 lineP eol)</span></code></pre></div>
</div>
<p>Part A is very simple.</p>
<div class="named-code-block">
<p>«solution-day-8»</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> [<span class="dt">Line</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>solutionA <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> ((<span class="ot">`elem`</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">7</span>]) <span class="op">.</span> numberOfSegments)</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>                   <span class="op">.</span> <span class="fu">concatMap</span> outputValues</span></code></pre></div>
</div>
<p>Part B is not simple. To find the correct mapping we have to play around with deducing digits from the digits we already know. I used a <strong>lazy</strong> <code>Map Int (Maybe Digit)</code> to represent the partially decoded map. In the end I call <code>Map.mapMaybe</code> which is strict, because it needs to do pattern matching. In this lazy approach we need to make sure that all entries to the map are there, but the values are not evaluated until needed. We have a <code>match</code> function that checks if a digit matches a certain number.</p>
<div class="named-code-block">
<p>«solution-day-8»</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Decoding</span> <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">Digit</span> <span class="dt">Int</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="ot">invertMap ::</span> (<span class="dt">Ord</span> k, <span class="dt">Ord</span> v) <span class="ot">=&gt;</span> <span class="dt">Map</span> k v <span class="ot">-&gt;</span> <span class="dt">Map</span> v k</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>invertMap <span class="ot">=</span> Map.fromList <span class="op">.</span> <span class="fu">map</span> swap <span class="op">.</span> Map.toList</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a><span class="ot">generateMap ::</span> (<span class="dt">Ord</span> k) <span class="ot">=&gt;</span> (k <span class="ot">-&gt;</span> v) <span class="ot">-&gt;</span> [k] <span class="ot">-&gt;</span> <span class="dt">Map</span> k v</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>generateMap f <span class="ot">=</span> Map.fromList <span class="op">.</span> <span class="fu">map</span> (\k <span class="ot">-&gt;</span> (k, f k))</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a><span class="ot">decode ::</span> [<span class="dt">Digit</span>] <span class="ot">-&gt;</span> <span class="dt">Decoding</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>decode digits <span class="ot">=</span> invertMap <span class="op">$</span> Map.mapMaybe <span class="fu">id</span> decodedMap</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> decodedMap <span class="ot">=</span> generateMap (\i <span class="ot">-&gt;</span> find (match i) digits) [<span class="dv">0</span><span class="op">..</span><span class="dv">9</span>]</span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>          getDigit <span class="ot">=</span> join <span class="op">.</span> (decodedMap <span class="op">!?</span>)</span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>          match i digit</span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>              <span class="op">&lt;&lt;</span>digit<span class="op">-</span>decode<span class="op">-</span>cases<span class="op">&gt;&gt;</span></span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>              <span class="op">|</span> <span class="fu">otherwise</span>            <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a>              <span class="kw">where</span> l <span class="ot">=</span> numberOfSegments digit</span></code></pre></div>
</div>
<p>The easy cases were already pointed to in part A:</p>
<div class="named-code-block">
<p>«digit-decode-cases»</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> i <span class="op">==</span> <span class="dv">1</span>             <span class="ot">=</span> l <span class="op">==</span> <span class="dv">2</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> i <span class="op">==</span> <span class="dv">4</span>             <span class="ot">=</span> l <span class="op">==</span> <span class="dv">4</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> i <span class="op">==</span> <span class="dv">7</span>             <span class="ot">=</span> l <span class="op">==</span> <span class="dv">3</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> i <span class="op">==</span> <span class="dv">8</span>             <span class="ot">=</span> l <span class="op">==</span> <span class="dv">7</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> i <span class="ot">`elem`</span> [<span class="dv">0</span>, <span class="dv">6</span>, <span class="dv">9</span>] <span class="ot">=</span> l <span class="op">==</span> <span class="dv">6</span> <span class="op">&amp;&amp;</span> </span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>digit<span class="op">-</span><span class="dv">6</span><span class="op">-</span>segments<span class="op">&gt;&gt;</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> i <span class="ot">`elem`</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>] <span class="ot">=</span> l <span class="op">==</span> <span class="dv">5</span> <span class="op">&amp;&amp;</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>digit<span class="op">-</span><span class="dv">5</span><span class="op">-</span>segments<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>In the case of five segments, i.e. numbers 2, 3 and 5, we can make the following deductions:</p>
<ul>
<li>digit 1 is a subset of 3 but not of 2 and 5</li>
<li>digit 2 contains the segment that is not in 6</li>
<li>digit 5 does not contain the segment that is not in 6</li>
</ul>
<div class="named-code-block">
<p>«digit-5-segments»</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>fromMaybe <span class="dt">False</span> ( <span class="kw">do</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>  one <span class="ot">&lt;-</span> getDigit <span class="dv">1</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>  six <span class="ot">&lt;-</span> getDigit <span class="dv">6</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> i <span class="op">==</span> <span class="dv">3</span> <span class="op">&amp;&amp;</span> one <span class="op">&lt;&lt;&lt;</span> digit</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">||</span> i <span class="op">==</span> <span class="dv">2</span> <span class="op">&amp;&amp;</span> invert six <span class="op">&lt;&lt;&lt;</span> digit</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>                  <span class="op">&amp;&amp;</span> <span class="fu">not</span> (one <span class="op">&lt;&lt;&lt;</span> digit)</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">||</span> i <span class="op">==</span> <span class="dv">5</span> <span class="op">&amp;&amp;</span> <span class="fu">not</span> (invert six <span class="op">&lt;&lt;&lt;</span> digit)</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>                  <span class="op">&amp;&amp;</span> <span class="fu">not</span> (one <span class="op">&lt;&lt;&lt;</span> digit) )</span></code></pre></div>
</div>
<p>In the case of six segments, i.e. numbers 0, 6 and 9, we can make the following deductions:</p>
<ul>
<li>the inverse of digit 0 (center segment) is in 4 and 1 is a subset of 0</li>
<li>the inverse of digit 6 is in 1</li>
<li>the digit 4 is a subset of digit 9</li>
</ul>
<div class="named-code-block">
<p>«digit-6-segments»</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>fromMaybe <span class="dt">False</span> ( <span class="kw">do</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>  one  <span class="ot">&lt;-</span> getDigit <span class="dv">1</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>  four <span class="ot">&lt;-</span> getDigit <span class="dv">4</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> i <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> invert digit <span class="op">&lt;&lt;&lt;</span> four</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>                  <span class="op">&amp;&amp;</span> one <span class="op">&lt;&lt;&lt;</span> digit</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">||</span> i <span class="op">==</span> <span class="dv">6</span> <span class="op">&amp;&amp;</span> invert digit <span class="op">&lt;&lt;&lt;</span> one</span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">||</span> i <span class="op">==</span> <span class="dv">9</span> <span class="op">&amp;&amp;</span> four <span class="op">&lt;&lt;&lt;</span> digit )</span></code></pre></div>
</div>
<p>Importantly, these deduction rules do not contain loops.</p>
<div class="named-code-block">
<p>«solution-day-8»</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="ot">decodeLine ::</span> <span class="dt">Line</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>decodeLine <span class="dt">Line</span>{<span class="op">..</span>} <span class="ot">=</span> fromDecimal <span class="op">$</span> mapMaybe (d <span class="op">!?</span>) outputValues</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> d <span class="ot">=</span> decode signalPattern</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>          fromDecimal <span class="ot">=</span> <span class="fu">foldl</span> (\a b <span class="ot">-&gt;</span> a <span class="op">*</span> <span class="dv">10</span> <span class="op">+</span> b) <span class="dv">0</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> [<span class="dt">Line</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>solutionB <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> decodeLine</span></code></pre></div>
</div>
</section>
<section id="day-9-smoke-basin" class="level1">
<h1>Day 9: Smoke Basin</h1>
<p>Lava tubes and more hydrothermal vents! I’ll be doing this in <code>Massiv</code> again. Here is a rendering of my input data.</p>
<p><img src="fig/day9-input.svg" title="The input data." class="figure" alt="The input data." /></p>
<div class="named-code-block">
<p>file:app/Day09.hs</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day09</span> <span class="kw">where</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (nub, sortBy)</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.Char</span> (ord)</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.State</span> (<span class="dt">State</span>, evalState, modify, get)</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.ByteString</span> (putStr)</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> (digitArray, readInputParsing)</span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Massiv.Array</span> (<span class="dt">Array</span>, <span class="dt">Ix2</span>(..))</span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Massiv.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Massiv.Array.Stencil</span> <span class="kw">as</span> <span class="dt">A.Stencil</span></span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.MultiSet</span> (<span class="dt">MultiSet</span>)</span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.MultiSet</span> <span class="kw">as</span> <span class="dt">MultiSet</span></span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-19"><a href="#cb67-19" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Random</span> (mkStdGen, genWord8)</span>
<span id="cb67-20"><a href="#cb67-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-21"><a href="#cb67-21" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parsing<span class="op">-</span>day<span class="op">-</span><span class="dv">9</span><span class="op">&gt;&gt;</span></span>
<span id="cb67-22"><a href="#cb67-22" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">9</span><span class="op">&gt;&gt;</span></span>
<span id="cb67-23"><a href="#cb67-23" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span>
<span id="cb67-24"><a href="#cb67-24" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="fu">show</span><span class="op">-</span><span class="kw">data</span><span class="op">-</span>day<span class="op">-</span><span class="dv">9</span><span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>Today’s input data is given as digits between 0 and 9.</p>
<div class="named-code-block">
<p>«digit-array-parser»</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Array2&#39;</span> r a <span class="ot">=</span> <span class="dt">A.Array</span> r <span class="dt">A.Ix2</span> a</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Array2</span> a <span class="ot">=</span> <span class="dt">Array2&#39;</span> <span class="dt">A.U</span> a</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="ot">digitArray ::</span> <span class="dt">Parser</span> (<span class="dt">Array2</span> <span class="dt">Int</span>)</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>digitArray <span class="ot">=</span> sepEndBy1 (some digit) eol <span class="op">&gt;&gt;=</span> toArray2</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> toArray2 <span class="ot">=</span> failOnException <span class="op">.</span> A.fromListsM <span class="dt">A.Seq</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«parsing-day-9»</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Array2&#39;</span> r a <span class="ot">=</span> <span class="dt">A.Array</span> r <span class="dt">A.Ix2</span> a</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Array2</span> a <span class="ot">=</span> <span class="dt">Array2&#39;</span> <span class="dt">A.U</span> a</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env (<span class="dt">Array2</span> <span class="dt">Int</span>)</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day09.txt&quot;</span> digitArray</span></code></pre></div>
</div>
<p>I’ll be using <code>Massiv</code>s stencil interface to solve this. Each stencil works on a neighbourhood of four pixels directly north, south, west and east from current location:</p>
<div class="named-code-block">
<p>«solution-day-9»</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="ot">neighbours ::</span> [<span class="dt">Ix2</span>]</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>neighbours <span class="ot">=</span> [<span class="op">-</span><span class="dv">1</span> <span class="op">:.</span> <span class="dv">0</span>, <span class="dv">1</span> <span class="op">:.</span> <span class="dv">0</span>, <span class="dv">0</span> <span class="op">:.</span> <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span> <span class="op">:.</span> <span class="dv">1</span>]</span></code></pre></div>
</div>
<p>For part A, we need to find the minima in the data.</p>
<div class="named-code-block">
<p>«solution-day-9»</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="ot">findMinStencil ::</span> <span class="dt">A.Stencil</span> <span class="dt">Ix2</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>findMinStencil <span class="ot">=</span> A.Stencil.makeStencil (<span class="dt">A.Sz</span> (<span class="dv">3</span> <span class="op">:.</span> <span class="dv">3</span>)) (<span class="dv">1</span> <span class="op">:.</span> <span class="dv">1</span>) go</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go get</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">all</span> ((value <span class="op">&lt;</span>) <span class="op">.</span> get) neighbours <span class="ot">=</span> value <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span>                        <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">where</span> value <span class="ot">=</span> get (<span class="dv">0</span> <span class="op">:.</span> <span class="dv">0</span>)</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>solutionA a <span class="ot">=</span> A.sum b</span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span><span class="ot"> b ::</span> <span class="dt">Array2</span> <span class="dt">Int</span></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a>          b <span class="ot">=</span> A.compute <span class="op">$</span> A.Stencil.mapStencil (<span class="dt">A.Fill</span> <span class="dv">10</span>) findMinStencil a</span></code></pre></div>
</div>
<p>In part B, we need to compute the watershed of the height map.</p>
<ol type="1">
<li>Mark minima.</li>
<li>Grow to a neighbourhood around each minimum:
<ul>
<li>stop when two patches meet</li>
<li>otherwise, repeat</li>
</ul></li>
</ol>
<p>We start by marking all minima found in part A with a unique integer identifier. I use a monadic map to give each minimum a number &gt; 0.</p>
<div class="named-code-block">
<p>«solution-day-9»</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="ot">markBasins ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Array2</span> <span class="dt">Int</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>markBasins a <span class="ot">=</span> evalState (A.mapM markNonZero a) <span class="dv">0</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span><span class="ot"> promise ::</span> <span class="dt">State</span> <span class="dt">Int</span> (<span class="dt">Array2</span> <span class="dt">Int</span>)</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>          promise <span class="ot">=</span> A.mapM markNonZero a</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a><span class="ot">          markNonZero ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>          markNonZero x</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> x <span class="op">/=</span> <span class="dv">0</span>    <span class="ot">=</span> modify (<span class="op">+</span> <span class="dv">1</span>) <span class="op">&gt;&gt;</span> get</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">return</span> <span class="dv">0</span></span></code></pre></div>
</div>
<p>The second step, we paint a pixel if all descending pixels have the same color. If a pixel is already colored, we leave it alone.</p>
<div class="named-code-block">
<p>«solution-day-9»</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="ot">same ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>same (a1<span class="op">:</span>a2<span class="op">:</span>as)</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a1 <span class="op">==</span> a2  <span class="ot">=</span> same (a2<span class="op">:</span>as)</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>same [a]   <span class="ot">=</span> <span class="dt">Just</span> a</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>same _     <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a><span class="ot">watershedStencil ::</span> <span class="dt">A.Stencil</span> <span class="dt">Ix2</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>watershedStencil <span class="ot">=</span> A.Stencil.makeStencil (<span class="dt">A.Sz</span> (<span class="dv">3</span> <span class="op">:.</span> <span class="dv">3</span>)) (<span class="dv">1</span> <span class="op">:.</span> <span class="dv">1</span>) go</span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go get</span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">snd</span> value <span class="op">/=</span> <span class="dv">0</span> <span class="ot">=</span> value</span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span>      <span class="ot">=</span> paint color</span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>            <span class="kw">where</span> value      <span class="ot">=</span> get (<span class="dv">0</span> <span class="op">:.</span> <span class="dv">0</span>)</span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a>                  descending <span class="ot">=</span> <span class="fu">filter</span> (\p <span class="ot">-&gt;</span> <span class="fu">fst</span> p <span class="op">&lt;</span> <span class="fu">fst</span> value) (get <span class="op">&lt;$&gt;</span> neighbours)</span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a>                  color      <span class="ot">=</span> same <span class="op">$</span> <span class="fu">snd</span> <span class="op">&lt;$&gt;</span> descending</span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a>                  paint (<span class="dt">Just</span> c) <span class="ot">=</span> (<span class="fu">fst</span> value, c)</span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true" tabindex="-1"></a>                  paint _        <span class="ot">=</span> value</span></code></pre></div>
</div>
<p>We keep doing this, until the watershed doesn’t change anymore. Afterwards, we need to clear pixels where the value is 9, this only happens at the edges.</p>
<div class="named-code-block">
<p>«solution-day-9»</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="ot">watershed ::</span> <span class="dt">Array2</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Array2</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>watershed <span class="ot">=</span> A.compute <span class="op">.</span> A.Stencil.mapStencil (<span class="dt">A.Fill</span> (<span class="dv">10</span>, <span class="dv">0</span>)) watershedStencil </span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="ot">fixedPoint ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>fixedPoint f x</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> x <span class="op">==</span> next <span class="ot">=</span> x</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> fixedPoint f next</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> next <span class="ot">=</span> f x</span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a><span class="ot">computeWatershed ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Array2</span> <span class="dt">Int</span></span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>computeWatershed a <span class="ot">=</span> A.compute <span class="op">$</span> A.map <span class="fu">snd</span> erase9</span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> minima <span class="ot">=</span> A.compute <span class="op">$</span> A.Stencil.mapStencil (<span class="dt">A.Fill</span> <span class="dv">10</span>) findMinStencil a </span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a>          runWs  <span class="ot">=</span> fixedPoint watershed (A.compute <span class="op">$</span> A.zip a <span class="op">$</span> markBasins minima)</span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a>          erase9 <span class="ot">=</span> A.map (\(a, b) <span class="ot">-&gt;</span> <span class="kw">if</span> a <span class="op">==</span> <span class="dv">9</span> <span class="kw">then</span> (a, <span class="dv">0</span>) <span class="kw">else</span> (a, b)) runWs</span></code></pre></div>
</div>
<p>To get our answer, we need to measure the size of each patch, and then find the three largest ones. On Day 6 we already saw the <code>MultiSet</code> in use, now again so:</p>
<div class="named-code-block">
<p>«solution-day-9»</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="ot">count ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> <span class="dt">Int</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>count <span class="ot">=</span> A.foldMono MultiSet.singleton</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>solutionB a <span class="ot">=</span> <span class="fu">product</span> <span class="op">$</span> <span class="fu">take</span> <span class="dv">3</span> <span class="op">$</span> sortBy (<span class="fu">flip</span> <span class="fu">compare</span>)</span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">$</span> <span class="fu">map</span> <span class="fu">snd</span> <span class="op">$</span> <span class="fu">filter</span> ((<span class="op">/=</span> <span class="dv">0</span>) <span class="op">.</span> <span class="fu">fst</span>)</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">$</span> MultiSet.toOccurList <span class="op">$</span> count</span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">$</span> computeWatershed a</span></code></pre></div>
</div>
<p>Here is my rendering of the resulting watershed:</p>
<p><img src="fig/day9-output.svg" title="The watershed segmentation of the input data." class="figure" alt="The watershed segmentation of the input data." /></p>
</section>
<section id="day-10-syntax-scoring" class="level1">
<h1>Day 10: Syntax Scoring</h1>
<p>Yay! Parsing! We can do this really well. First I’ll do a really stupid thing, and solve this by looking at <code>ParserErrorBundle</code> objects returned by <code>Megaparsec</code>. This was a nice exercise but a really stupid way to solve this days problem. At the end I have a better solution, basically using a stack.</p>
<div class="named-code-block">
<p>file:app/Day10.hs</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day10</span> <span class="kw">where</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span> <span class="kw">hiding</span> (lines)</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List.Partial</span> ((!!))</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (sort, headMaybe, foldl)</span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Set</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.ByteString</span> (readFile)</span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.Text</span> (lenientDecode, decodeUtf8With, lines)</span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> (<span class="dt">Parser</span>, char, eol)</span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> ( parse, <span class="dt">ParseErrorBundle</span>(..), <span class="dt">ErrorItem</span>(..)</span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a>                       , <span class="dt">ParseError</span>(<span class="op">..</span>))</span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parsing<span class="op">-</span>day<span class="op">-</span><span class="dv">10</span><span class="op">&gt;&gt;</span></span>
<span id="cb76-15"><a href="#cb76-15" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">10</span><span class="op">&gt;&gt;</span></span>
<span id="cb76-16"><a href="#cb76-16" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>Parsing these sequences is what we have <code>Megaparsec</code> for.</p>
<div class="named-code-block">
<p>«parsing-day-10»</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bracket</span> <span class="ot">=</span> <span class="dt">Round</span> <span class="op">|</span> <span class="dt">Square</span> <span class="op">|</span> <span class="dt">Curly</span> <span class="op">|</span> <span class="dt">Angle</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Enum</span>)</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Chunk</span> <span class="ot">=</span> <span class="dt">Chunk</span> <span class="dt">Bracket</span> [<span class="dt">Chunk</span>]</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a><span class="ot">openingBracket ::</span> <span class="dt">Parser</span> <span class="dt">Bracket</span></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>openingBracket <span class="ot">=</span>  char <span class="ch">&#39;(&#39;</span> <span class="op">$&gt;</span> <span class="dt">Round</span></span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a>              <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;{&#39;</span> <span class="op">$&gt;</span> <span class="dt">Curly</span></span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>              <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;[&#39;</span> <span class="op">$&gt;</span> <span class="dt">Square</span></span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a>              <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;&lt;&#39;</span> <span class="op">$&gt;</span> <span class="dt">Angle</span></span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true" tabindex="-1"></a><span class="ot">closingBracket ::</span> <span class="dt">Bracket</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> ()</span>
<span id="cb77-14"><a href="#cb77-14" aria-hidden="true" tabindex="-1"></a>closingBracket b <span class="ot">=</span> (<span class="kw">case</span> b <span class="kw">of</span></span>
<span id="cb77-15"><a href="#cb77-15" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">Round</span>  <span class="ot">-&gt;</span> char <span class="ch">&#39;)&#39;</span></span>
<span id="cb77-16"><a href="#cb77-16" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">Square</span> <span class="ot">-&gt;</span> char <span class="ch">&#39;]&#39;</span></span>
<span id="cb77-17"><a href="#cb77-17" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">Curly</span>  <span class="ot">-&gt;</span> char <span class="ch">&#39;}&#39;</span></span>
<span id="cb77-18"><a href="#cb77-18" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">Angle</span>  <span class="ot">-&gt;</span> char <span class="ch">&#39;&gt;&#39;</span>) <span class="op">$&gt;</span> ()</span>
<span id="cb77-19"><a href="#cb77-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-20"><a href="#cb77-20" aria-hidden="true" tabindex="-1"></a><span class="ot">chunkP ::</span> <span class="dt">Parser</span> <span class="dt">Chunk</span></span>
<span id="cb77-21"><a href="#cb77-21" aria-hidden="true" tabindex="-1"></a>chunkP <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb77-22"><a href="#cb77-22" aria-hidden="true" tabindex="-1"></a>    opening <span class="ot">&lt;-</span> openingBracket</span>
<span id="cb77-23"><a href="#cb77-23" aria-hidden="true" tabindex="-1"></a>    content <span class="ot">&lt;-</span> many chunkP</span>
<span id="cb77-24"><a href="#cb77-24" aria-hidden="true" tabindex="-1"></a>    closingBracket opening</span>
<span id="cb77-25"><a href="#cb77-25" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="op">$</span> <span class="dt">Chunk</span> opening content</span>
<span id="cb77-26"><a href="#cb77-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-27"><a href="#cb77-27" aria-hidden="true" tabindex="-1"></a><span class="ot">parseLine ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">ParseErrorBundle</span> <span class="dt">Text</span> <span class="dt">Void</span>) <span class="dt">Chunk</span></span>
<span id="cb77-28"><a href="#cb77-28" aria-hidden="true" tabindex="-1"></a>parseLine <span class="ot">=</span> parse chunkP <span class="st">&quot;&quot;</span></span>
<span id="cb77-29"><a href="#cb77-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-30"><a href="#cb77-30" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="fu">read</span><span class="op">-</span><span class="fu">lines</span><span class="op">&gt;&gt;</span></span>
<span id="cb77-31"><a href="#cb77-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-32"><a href="#cb77-32" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">MonadIO</span> m) <span class="ot">=&gt;</span> m [<span class="dt">Text</span>]</span>
<span id="cb77-33"><a href="#cb77-33" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readLines</span></code></pre></div>
</div>
<div class="named-code-block">
<p>«read-lines»</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="ot">readLines ::</span> (<span class="dt">MonadIO</span> m) <span class="ot">=&gt;</span> m [<span class="dt">Text</span>]</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>readLines <span class="ot">=</span> Text.lines <span class="op">.</span> Text.decodeUtf8With Text.lenientDecode </span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>         <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> <span class="st">&quot;data/day10.txt&quot;</span></span></code></pre></div>
</div>
<p>For part A we need to look at the parser error that we get and extract the unexpected character. We can pattern match to get at the character and assume if it doesn’t match, we have unexpected end-of-input.</p>
<div class="named-code-block">
<p>«solution-day-10»</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="ot">illegalChar ::</span> <span class="dt">ParseErrorBundle</span> <span class="dt">Text</span> <span class="dt">Void</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Char</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>illegalChar e <span class="ot">=</span> <span class="kw">case</span> bundleErrors e <span class="kw">of</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">TrivialError</span> _ (<span class="dt">Just</span> (<span class="dt">Tokens</span> (c <span class="op">:|</span> _))) _) <span class="op">:|</span> _ <span class="ot">-&gt;</span> <span class="dt">Just</span> c</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>    _                                                <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
</div>
<p>Completing the score,</p>
<div class="named-code-block">
<p>«solution-day-10»</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="ot">scoreA ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>scoreA <span class="ch">&#39;)&#39;</span> <span class="ot">=</span> <span class="dv">3</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>scoreA <span class="ch">&#39;]&#39;</span> <span class="ot">=</span> <span class="dv">57</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>scoreA <span class="ch">&#39;}&#39;</span> <span class="ot">=</span> <span class="dv">1197</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>scoreA <span class="ch">&#39;&gt;&#39;</span> <span class="ot">=</span> <span class="dv">25137</span></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>scoreA _   <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>solutionA <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> scoreA <span class="op">.</span> mapMaybe illegalChar</span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a>          <span class="op">.</span> lefts <span class="op">.</span> <span class="fu">map</span> parseLine</span></code></pre></div>
</div>
<p>In part B we look at the characters we expected when encountering end-of-input. We need to take care here: opening brackets are always expected, so we filter on closing brackets.</p>
<div class="named-code-block">
<p>«solution-day-10»</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="ot">expectedChar ::</span> <span class="dt">ParseErrorBundle</span> <span class="dt">Text</span> <span class="dt">Void</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Char</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>expectedChar e <span class="ot">=</span> <span class="kw">case</span> bundleErrors e <span class="kw">of</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">TrivialError</span> _ (<span class="dt">Just</span> <span class="dt">EndOfInput</span>) <span class="fu">exp</span>) <span class="op">:|</span> _ <span class="ot">-&gt;</span> getExpected <span class="fu">exp</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>    _                                           <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span><span class="ot"> getExpected ::</span> <span class="dt">Set</span> (<span class="dt">ErrorItem</span> <span class="dt">Char</span>) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Char</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>          getExpected s <span class="ot">=</span> headMaybe <span class="op">$</span> <span class="fu">concatMap</span> getToken</span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>                                    <span class="op">$</span> Set.toList s</span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>          getToken (<span class="dt">Tokens</span> (t <span class="op">:|</span> ts)) <span class="ot">=</span> <span class="fu">filter</span> closingChar (t <span class="op">:</span> ts)</span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>          getToken _                  <span class="ot">=</span> []</span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a>          closingChar <span class="ot">=</span> (<span class="ot">`elem`</span> [<span class="ch">&#39;)&#39;</span>, <span class="ch">&#39;]&#39;</span>, <span class="ch">&#39;}&#39;</span>, <span class="ch">&#39;&gt;&#39;</span>])</span></code></pre></div>
</div>
<p>To autocomplete, I keep re-parsing the string, adding characters at the end, until the parsing succeeds. In principle, this could be done nicer from the parser, by creating a sort of stack trace. However, that would polute the code for actually parsing the correct structure.</p>
<div class="named-code-block">
<p>«solution-day-10»</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="ot">autocomplete ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Text</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>autocomplete orig <span class="ot">=</span> go <span class="st">&quot;&quot;</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go suffix <span class="ot">=</span> <span class="fu">either</span> (complete suffix)</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>                             (<span class="fu">const</span> <span class="op">$</span> <span class="dt">Just</span> suffix)</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>                             (parseLine <span class="op">$</span> orig <span class="op">&lt;&gt;</span> suffix)</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>          complete suffix err <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>              c <span class="ot">&lt;-</span> expectedChar err</span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>              go (suffix <span class="op">&lt;&gt;</span> Text.singleton c)</span></code></pre></div>
</div>
<p>For computing the score, we encounter our old friend the <code>median</code> function again.</p>
<div class="named-code-block">
<p>«median»</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="ot">median ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>median x <span class="ot">=</span> <span class="fu">sort</span> x <span class="op">!!</span> (<span class="fu">length</span> x <span class="ot">`div`</span> <span class="dv">2</span>)</span></code></pre></div>
</div>
<div class="named-code-block">
<p>«solution-day-10»</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>median<span class="op">&gt;&gt;</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a><span class="ot">scoreB ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>scoreB <span class="ot">=</span> <span class="fu">foldl</span> f <span class="dv">0</span> <span class="op">.</span> Text.unpack </span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> f i c <span class="ot">=</span> i <span class="op">*</span> <span class="dv">5</span> <span class="op">+</span> s c</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>          s <span class="ch">&#39;)&#39;</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>          s <span class="ch">&#39;]&#39;</span> <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>          s <span class="ch">&#39;}&#39;</span> <span class="ot">=</span> <span class="dv">3</span></span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>          s <span class="ch">&#39;&gt;&#39;</span> <span class="ot">=</span> <span class="dv">4</span></span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>          s _   <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a>solutionB <span class="ot">=</span> median <span class="op">.</span> <span class="fu">map</span> scoreB <span class="op">.</span> mapMaybe autocomplete</span></code></pre></div>
</div>
<section id="simpler-solution" class="level3">
<h3>Simpler solution</h3>
<p>Ok, that was fun but way too much work. There should be a much simpler solution. We can keep a stack.</p>
<div class="named-code-block">
<p>file:app/Day10Alt.hs</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day10Alt</span> <span class="kw">where</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List.Partial</span> ((!!))</span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (sort, headMaybe, foldl)</span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.ByteString</span> (readFile)</span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">MonadIO</span> m) <span class="ot">=&gt;</span> m [<span class="dt">Text</span>]</span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> Text.lines <span class="op">.</span> Text.decodeUtf8With Text.lenientDecode </span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a>         <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> <span class="st">&quot;data/day10.txt&quot;</span></span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ParseResult</span> <span class="ot">=</span> <span class="dt">Unexpected</span> <span class="dt">Char</span> <span class="op">|</span> <span class="dt">AutoComplete</span> <span class="dt">Text</span> <span class="op">|</span> <span class="dt">Success</span> <span class="dt">Text</span></span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-17"><a href="#cb85-17" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">ParseResult</span></span>
<span id="cb85-18"><a href="#cb85-18" aria-hidden="true" tabindex="-1"></a>parse inp <span class="ot">=</span> go (Text.unpack inp) []</span>
<span id="cb85-19"><a href="#cb85-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go [] []      <span class="ot">=</span> <span class="dt">Success</span> inp</span>
<span id="cb85-20"><a href="#cb85-20" aria-hidden="true" tabindex="-1"></a>          go [] <span class="fu">exp</span>     <span class="ot">=</span> <span class="dt">AutoComplete</span> (Text.pack <span class="fu">exp</span>)</span>
<span id="cb85-21"><a href="#cb85-21" aria-hidden="true" tabindex="-1"></a>          go (c<span class="op">:</span>cs) <span class="fu">exp</span> <span class="ot">=</span> fromMaybe (<span class="dt">Unexpected</span> c) </span>
<span id="cb85-22"><a href="#cb85-22" aria-hidden="true" tabindex="-1"></a>                                    (close (c<span class="op">:</span>cs) <span class="fu">exp</span> <span class="op">&lt;|&gt;</span> open (c<span class="op">:</span>cs) <span class="fu">exp</span>)</span>
<span id="cb85-23"><a href="#cb85-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-24"><a href="#cb85-24" aria-hidden="true" tabindex="-1"></a>          close (c<span class="op">:</span>cs) (e<span class="op">:</span><span class="fu">exp</span>)</span>
<span id="cb85-25"><a href="#cb85-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> c <span class="op">==</span> e    <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> go cs <span class="fu">exp</span></span>
<span id="cb85-26"><a href="#cb85-26" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb85-27"><a href="#cb85-27" aria-hidden="true" tabindex="-1"></a>          close (c<span class="op">:</span>cs) [] <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb85-28"><a href="#cb85-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-29"><a href="#cb85-29" aria-hidden="true" tabindex="-1"></a>          open (c<span class="op">:</span>cs) <span class="fu">exp</span></span>
<span id="cb85-30"><a href="#cb85-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> c <span class="op">==</span> <span class="ch">&#39;(&#39;</span>  <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> go cs (<span class="ch">&#39;)&#39;</span><span class="op">:</span><span class="fu">exp</span>)</span>
<span id="cb85-31"><a href="#cb85-31" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> c <span class="op">==</span> <span class="ch">&#39;[&#39;</span>  <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> go cs (<span class="ch">&#39;]&#39;</span><span class="op">:</span><span class="fu">exp</span>)</span>
<span id="cb85-32"><a href="#cb85-32" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> c <span class="op">==</span> <span class="ch">&#39;&lt;&#39;</span>  <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> go cs (<span class="ch">&#39;&gt;&#39;</span><span class="op">:</span><span class="fu">exp</span>)</span>
<span id="cb85-33"><a href="#cb85-33" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> c <span class="op">==</span> <span class="ch">&#39;{&#39;</span>  <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> go cs (<span class="ch">&#39;}&#39;</span><span class="op">:</span><span class="fu">exp</span>)</span>
<span id="cb85-34"><a href="#cb85-34" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb85-35"><a href="#cb85-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-36"><a href="#cb85-36" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb85-37"><a href="#cb85-37" aria-hidden="true" tabindex="-1"></a>solutionA <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> (score <span class="op">.</span> parse)</span>
<span id="cb85-38"><a href="#cb85-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> score (<span class="dt">Unexpected</span> <span class="ch">&#39;)&#39;</span>) <span class="ot">=</span> <span class="dv">3</span></span>
<span id="cb85-39"><a href="#cb85-39" aria-hidden="true" tabindex="-1"></a>          score (<span class="dt">Unexpected</span> <span class="ch">&#39;]&#39;</span>) <span class="ot">=</span> <span class="dv">57</span></span>
<span id="cb85-40"><a href="#cb85-40" aria-hidden="true" tabindex="-1"></a>          score (<span class="dt">Unexpected</span> <span class="ch">&#39;}&#39;</span>) <span class="ot">=</span> <span class="dv">1197</span></span>
<span id="cb85-41"><a href="#cb85-41" aria-hidden="true" tabindex="-1"></a>          score (<span class="dt">Unexpected</span> <span class="ch">&#39;&gt;&#39;</span>) <span class="ot">=</span> <span class="dv">25137</span></span>
<span id="cb85-42"><a href="#cb85-42" aria-hidden="true" tabindex="-1"></a>          score _                <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb85-43"><a href="#cb85-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-44"><a href="#cb85-44" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>median<span class="op">&gt;&gt;</span></span>
<span id="cb85-45"><a href="#cb85-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-46"><a href="#cb85-46" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb85-47"><a href="#cb85-47" aria-hidden="true" tabindex="-1"></a>solutionB <span class="ot">=</span> median <span class="op">.</span> mapMaybe (score <span class="op">.</span> parse)</span>
<span id="cb85-48"><a href="#cb85-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> score (<span class="dt">AutoComplete</span> t) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> <span class="fu">foldl</span> (\i c <span class="ot">-&gt;</span> i <span class="op">*</span> <span class="dv">5</span> <span class="op">+</span> points c) <span class="dv">0</span> (Text.unpack t)</span>
<span id="cb85-49"><a href="#cb85-49" aria-hidden="true" tabindex="-1"></a>          score _                <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb85-50"><a href="#cb85-50" aria-hidden="true" tabindex="-1"></a>          points <span class="ch">&#39;)&#39;</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb85-51"><a href="#cb85-51" aria-hidden="true" tabindex="-1"></a>          points <span class="ch">&#39;]&#39;</span> <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb85-52"><a href="#cb85-52" aria-hidden="true" tabindex="-1"></a>          points <span class="ch">&#39;}&#39;</span> <span class="ot">=</span> <span class="dv">3</span></span>
<span id="cb85-53"><a href="#cb85-53" aria-hidden="true" tabindex="-1"></a>          points <span class="ch">&#39;&gt;&#39;</span> <span class="ot">=</span> <span class="dv">4</span></span>
<span id="cb85-54"><a href="#cb85-54" aria-hidden="true" tabindex="-1"></a>          points _   <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb85-55"><a href="#cb85-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-56"><a href="#cb85-56" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
</section>
</section>
<section id="day-11-dumbo-octopus" class="level1">
<h1>Day 11: Dumbo Octopus</h1>
<p>This is clearly inspired on <a href="https://ncase.me/fireflies/">this demo of spontaneously synchronising fireflies</a>.</p>
<div class="named-code-block">
<p>file:app/Day11.hs</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day11</span> <span class="kw">where</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.ByteString</span> (putStr)</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.State</span> (evalStateT, evalState, execState, <span class="dt">MonadState</span>, modify, get, gets)</span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Massiv.Array</span> (<span class="dt">Ix2</span>(..))</span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Massiv.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> (digitArray, readInputParsing)</span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day<span class="op">-</span><span class="dv">11</span><span class="op">&gt;&gt;</span></span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">11</span><span class="op">&gt;&gt;</span></span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="fu">show</span><span class="op">-</span><span class="kw">data</span><span class="op">-</span>day<span class="op">-</span><span class="dv">11</span><span class="op">&gt;&gt;</span></span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>We can reuse the input parser from day 9.</p>
<div class="named-code-block">
<p>«parser-day-11»</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Array2&#39;</span> r a <span class="ot">=</span> <span class="dt">A.Array</span> r <span class="dt">A.Ix2</span> a</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Array2</span> a <span class="ot">=</span> <span class="dt">Array2&#39;</span> <span class="dt">A.U</span> a</span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env (<span class="dt">Array2</span> <span class="dt">Int</span>)</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day11.txt&quot;</span> digitArray</span></code></pre></div>
</div>
<p>Each iteration can be divided in three steps:</p>
<ul>
<li><code>clock</code>: advance the cycle of every octopus by one</li>
<li><code>flash</code>: resolve the flashing, marking flashed octopusses</li>
<li><code>reset</code>: reset the counter for flashed octopusses</li>
</ul>
<p>I put these steps into a state monad.</p>
<div class="named-code-block">
<p>«solution-day-11»</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="ot">step ::</span> (<span class="dt">MonadState</span> (<span class="dt">Array2</span> <span class="dt">Int</span>) m) <span class="ot">=&gt;</span> m <span class="dt">Int</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>step <span class="ot">=</span> clock <span class="op">&gt;&gt;</span> flash <span class="op">&gt;&gt;</span> reset</span></code></pre></div>
</div>
<p>The <code>clock</code> advances every counter by one tick.</p>
<div class="named-code-block">
<p>«solution-day-11»</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="ot">clock ::</span> (<span class="dt">MonadState</span> (<span class="dt">Array2</span> <span class="dt">Int</span>) m) <span class="ot">=&gt;</span> m ()</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>clock <span class="ot">=</span> modify (A.compute <span class="op">.</span> A.map (<span class="op">+</span> <span class="dv">1</span>))</span></code></pre></div>
</div>
<p>To resolve the flashes, I use my friend the <em>stencil</em> again. I mark flashed octopusses by setting their counter to 1000. That way, they don’t get counted twice.</p>
<div class="named-code-block">
<p>«solution-day-11»</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="ot">home ::</span> <span class="dt">A.Ix2</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>home <span class="ot">=</span> <span class="dv">0</span> <span class="op">:.</span> <span class="dv">0</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a><span class="ot">neighbours ::</span> [<span class="dt">A.Ix2</span>]</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>neighbours <span class="ot">=</span> [ <span class="op">-</span><span class="dv">1</span> <span class="op">:.</span> <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span> <span class="op">:.</span> <span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span> <span class="op">:.</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>             , <span class="op">-</span><span class="dv">1</span> <span class="op">:.</span>  <span class="dv">0</span>,          <span class="dv">1</span> <span class="op">:.</span>  <span class="dv">0</span></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>             , <span class="op">-</span><span class="dv">1</span> <span class="op">:.</span>  <span class="dv">1</span>, <span class="dv">0</span> <span class="op">:.</span>  <span class="dv">1</span>, <span class="dv">1</span> <span class="op">:.</span>  <span class="dv">1</span> ]</span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a><span class="ot">count ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a>count f <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> (\x <span class="ot">-&gt;</span> <span class="kw">if</span> f x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>)</span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true" tabindex="-1"></a><span class="ot">countArray ::</span> (<span class="dt">A.Unbox</span> a) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Array2</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true" tabindex="-1"></a>countArray f <span class="ot">=</span> A.sum <span class="op">.</span> A.map (\x <span class="ot">-&gt;</span> <span class="kw">if</span> f x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>)</span>
<span id="cb90-14"><a href="#cb90-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-15"><a href="#cb90-15" aria-hidden="true" tabindex="-1"></a><span class="ot">flashed ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb90-16"><a href="#cb90-16" aria-hidden="true" tabindex="-1"></a>flashed c <span class="ot">=</span> c <span class="op">&gt;</span> <span class="dv">9</span> <span class="op">&amp;&amp;</span> c <span class="op">&lt;</span> <span class="dv">1000</span></span>
<span id="cb90-17"><a href="#cb90-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-18"><a href="#cb90-18" aria-hidden="true" tabindex="-1"></a><span class="ot">flashStencil ::</span> <span class="dt">A.Stencil</span> <span class="dt">Ix2</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb90-19"><a href="#cb90-19" aria-hidden="true" tabindex="-1"></a>flashStencil <span class="ot">=</span> A.makeStencil (<span class="dt">A.Sz</span> (<span class="dv">3</span> <span class="op">:.</span> <span class="dv">3</span>)) (<span class="dv">1</span> <span class="op">:.</span> <span class="dv">1</span>) go</span>
<span id="cb90-20"><a href="#cb90-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go get <span class="ot">=</span> <span class="kw">if</span> flashed (get home) <span class="kw">then</span> <span class="dv">1000</span></span>
<span id="cb90-21"><a href="#cb90-21" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">else</span> get home <span class="op">+</span> count (flashed <span class="op">.</span> get) neighbours</span>
<span id="cb90-22"><a href="#cb90-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-23"><a href="#cb90-23" aria-hidden="true" tabindex="-1"></a><span class="ot">flash ::</span> <span class="dt">MonadState</span> (<span class="dt">Array2</span> <span class="dt">Int</span>) m <span class="ot">=&gt;</span> m ()</span>
<span id="cb90-24"><a href="#cb90-24" aria-hidden="true" tabindex="-1"></a>flash <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb90-25"><a href="#cb90-25" aria-hidden="true" tabindex="-1"></a>    n <span class="ot">&lt;-</span> gets <span class="op">$</span> countArray flashed</span>
<span id="cb90-26"><a href="#cb90-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="fu">return</span> ()</span>
<span id="cb90-27"><a href="#cb90-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> modify go <span class="op">&gt;&gt;</span> flash</span>
<span id="cb90-28"><a href="#cb90-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span><span class="ot"> go ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Array2</span> <span class="dt">Int</span></span>
<span id="cb90-29"><a href="#cb90-29" aria-hidden="true" tabindex="-1"></a>          go <span class="ot">=</span> A.compute <span class="op">.</span> A.mapStencil (<span class="dt">A.Fill</span> <span class="dv">0</span>) flashStencil</span></code></pre></div>
</div>
<p>At the <code>reset</code>, I count how many values are larger than 1000, and set them back to 0.</p>
<div class="named-code-block">
<p>«solution-day-11»</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="ot">reset ::</span> <span class="dt">MonadState</span> (<span class="dt">Array2</span> <span class="dt">Int</span>) m <span class="ot">=&gt;</span> m <span class="dt">Int</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>reset <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>    n <span class="ot">&lt;-</span> gets <span class="op">$</span> countArray (<span class="op">&gt;=</span> <span class="dv">1000</span>)</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>    modify <span class="op">$</span> A.compute <span class="op">.</span> A.map (\x <span class="ot">-&gt;</span> <span class="kw">if</span> x <span class="op">&gt;=</span> <span class="dv">1000</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> x)</span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> n</span></code></pre></div>
</div>
<p>I put everything in a state monad. The parts A and B have different stopping criteria.</p>
<div class="named-code-block">
<p>«solution-day-11»</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="ot">repeatM ::</span> (<span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m [a]</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>repeatM n a <span class="ot">=</span> loop n</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> loop n</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> n <span class="op">&lt;=</span> <span class="dv">0</span>    <span class="ot">=</span> <span class="fu">pure</span> []</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> liftA2 (<span class="op">:</span>) a (loop (n <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a>solutionA <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> evalState (repeatM <span class="dv">100</span> step)</span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a><span class="ot">countRepeatUntilM ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m <span class="dt">Int</span></span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a>countRepeatUntilM action <span class="ot">=</span> go <span class="dv">1</span></span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true" tabindex="-1"></a>            stop <span class="ot">&lt;-</span> action</span>
<span id="cb92-14"><a href="#cb92-14" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> stop <span class="kw">then</span> <span class="fu">return</span> n <span class="kw">else</span> go (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb92-15"><a href="#cb92-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-16"><a href="#cb92-16" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb92-17"><a href="#cb92-17" aria-hidden="true" tabindex="-1"></a>solutionB <span class="ot">=</span> evalState <span class="op">$</span> countRepeatUntilM ((<span class="op">==</span> <span class="dv">100</span>) <span class="op">&lt;$&gt;</span> step)</span></code></pre></div>
</div>
<section id="plots" class="level3">
<h3>Plots</h3>
<p>Iteration 1 through 258 (my answer) of the Dumbo Octopusses. For a long time, there is a majority period of 7 cycles. The basin has a value of 6 then, but is triggered by some event at the boundary of the basin, creating a cascade. When all octopusses synchronize the period lengthens to 10.</p>
<p><img src="fig/day11.svg" class="figure" alt="" /></p>
</section>
</section>
<section id="day-12-passage-pathing" class="level1">
<h1>Day 12: Passage Pathing</h1>
<p>Graphs! The fun times we live in :). We’re getting a map of caves. This is my input:</p>
<p><img src="fig/day12-map.svg" class="figure" alt="" /></p>
<div class="named-code-block">
<p>file:app/Day12.hs</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day12</span> <span class="kw">where</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span> <span class="kw">hiding</span> (try)</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.Map</span> ((!?))</span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.Set</span> ((\\))</span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Set</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> (<span class="dt">Parser</span>, string, char, eol, sepEndBy1, readInputParsing)</span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.Char</span> (isLower, isUpper)</span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> (takeWhile1P, try)</span>
<span id="cb93-13"><a href="#cb93-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-14"><a href="#cb93-14" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day<span class="op">-</span><span class="dv">12</span><span class="op">&gt;&gt;</span></span>
<span id="cb93-15"><a href="#cb93-15" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">12</span><span class="op">&gt;&gt;</span></span>
<span id="cb93-16"><a href="#cb93-16" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>I distinguish the <code>Start</code>, <code>End</code> caves and <code>Big</code> and <code>Small</code> during parsing.</p>
<div class="named-code-block">
<p>«parser-day-12»</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Cave</span> <span class="ot">=</span> <span class="dt">Start</span> <span class="op">|</span> <span class="dt">End</span> <span class="op">|</span> <span class="dt">Big</span> <span class="dt">Text</span> <span class="op">|</span> <span class="dt">Small</span> <span class="dt">Text</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Cave</span> <span class="kw">where</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">show</span> <span class="dt">Start</span> <span class="ot">=</span> <span class="st">&quot;start&quot;</span></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">show</span> <span class="dt">End</span> <span class="ot">=</span> <span class="st">&quot;end&quot;</span></span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">show</span> (<span class="dt">Big</span> c) <span class="ot">=</span> Text.unpack c</span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">show</span> (<span class="dt">Small</span> c) <span class="ot">=</span> Text.unpack c</span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Link</span> <span class="ot">=</span> <span class="dt">Link</span> <span class="dt">Cave</span> <span class="dt">Cave</span></span>
<span id="cb94-11"><a href="#cb94-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span>
<span id="cb94-12"><a href="#cb94-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-13"><a href="#cb94-13" aria-hidden="true" tabindex="-1"></a><span class="ot">caveP ::</span> <span class="dt">Parser</span> <span class="dt">Cave</span></span>
<span id="cb94-14"><a href="#cb94-14" aria-hidden="true" tabindex="-1"></a>caveP <span class="ot">=</span>  (<span class="dt">Start</span> <span class="op">&lt;$</span>  try (string <span class="st">&quot;start&quot;</span>))</span>
<span id="cb94-15"><a href="#cb94-15" aria-hidden="true" tabindex="-1"></a>     <span class="op">&lt;|&gt;</span> (<span class="dt">End</span>   <span class="op">&lt;$</span>  try (string <span class="st">&quot;end&quot;</span> ))</span>
<span id="cb94-16"><a href="#cb94-16" aria-hidden="true" tabindex="-1"></a>     <span class="op">&lt;|&gt;</span> (<span class="dt">Big</span>   <span class="op">&lt;$&gt;</span> takeWhile1P (<span class="dt">Just</span> <span class="st">&quot;A-Z&quot;</span>) <span class="fu">isUpper</span>)</span>
<span id="cb94-17"><a href="#cb94-17" aria-hidden="true" tabindex="-1"></a>     <span class="op">&lt;|&gt;</span> (<span class="dt">Small</span> <span class="op">&lt;$&gt;</span> takeWhile1P (<span class="dt">Just</span> <span class="st">&quot;a-z&quot;</span>) <span class="fu">isLower</span>)</span>
<span id="cb94-18"><a href="#cb94-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-19"><a href="#cb94-19" aria-hidden="true" tabindex="-1"></a><span class="ot">linkP ::</span> <span class="dt">Parser</span> <span class="dt">Link</span></span>
<span id="cb94-20"><a href="#cb94-20" aria-hidden="true" tabindex="-1"></a>linkP <span class="ot">=</span> <span class="dt">Link</span> <span class="op">&lt;$&gt;</span> caveP <span class="op">&lt;*</span> char <span class="ch">&#39;-&#39;</span> <span class="op">&lt;*&gt;</span> caveP</span>
<span id="cb94-21"><a href="#cb94-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-22"><a href="#cb94-22" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env [<span class="dt">Link</span>]</span>
<span id="cb94-23"><a href="#cb94-23" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day12.txt&quot;</span> (sepEndBy1 linkP eol)</span></code></pre></div>
</div>
<p>From the list of <code>Link</code> we can extract a <code>CaveMap</code>.</p>
<div class="named-code-block">
<p>«solution-day-12»</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">CaveMap</span> <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">Cave</span> [<span class="dt">Cave</span>]</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a><span class="ot">routing ::</span> [<span class="dt">Link</span>] <span class="ot">-&gt;</span> <span class="dt">CaveMap</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>routing <span class="ot">=</span> Map.unionsWith (<span class="op">&lt;&gt;</span>) <span class="op">.</span> <span class="fu">map</span> linkToMap</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> linkToMap (<span class="dt">Link</span> a b) <span class="ot">=</span> Map.fromList [(a, [b]), (b, [a])]</span></code></pre></div>
</div>
<p>With part B in mind, we need to have an abstract <code>Cave</code> container with two methods, <code>visit</code> and <code>allowed</code>.</p>
<div class="named-code-block">
<p>«solution-day-12»</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">CaveSet</span> s <span class="kw">where</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    visit   ::</span> <span class="dt">Cave</span> <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    allowed ::</span> <span class="dt">Cave</span> <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
</div>
<p>In part A, we can use a <code>Set Cave</code> to keep track of all the caves we visited:</p>
<ul>
<li>A big cave is always allowed, so we do not enter it into the set.</li>
<li>Any other cave is only allowed once.</li>
</ul>
<div class="named-code-block">
<p>«solution-day-12»</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">CaveSet</span> (<span class="dt">Set</span> <span class="dt">Cave</span>) <span class="kw">where</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>    visit (<span class="dt">Big</span> _) s <span class="ot">=</span> s</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>    visit c       s <span class="ot">=</span> Set.insert c s</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>    allowed         <span class="ot">=</span> Set.notMember</span></code></pre></div>
</div>
<p>I find all possible routes recursively, using <code>concatMap</code>.</p>
<div class="named-code-block">
<p>«solution-day-12»</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="ot">findRoutesTo ::</span> (<span class="dt">CaveSet</span> s) <span class="ot">=&gt;</span> <span class="dt">CaveMap</span> <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Cave</span> <span class="ot">-&gt;</span> <span class="dt">Cave</span> <span class="ot">-&gt;</span> [[<span class="dt">Cave</span>]]</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>findRoutesTo caveMap visited end start</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> start <span class="op">==</span> end <span class="ot">=</span> [[end]]</span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span>    <span class="ot">=</span> <span class="fu">map</span> (start <span class="op">:</span>) <span class="op">$</span> <span class="fu">concatMap</span> recur nextRooms</span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> visited&#39;   <span class="ot">=</span> visit start visited</span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>          recur      <span class="ot">=</span> findRoutesTo caveMap visited&#39; end</span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a>          nextRooms  <span class="ot">=</span> <span class="fu">filter</span> (<span class="ot">`allowed`</span> visited&#39;)</span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a>                     <span class="op">$</span> fromMaybe [] (caveMap <span class="op">!?</span> start)</span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-10"><a href="#cb98-10" aria-hidden="true" tabindex="-1"></a><span class="ot">findRoutesA ::</span> <span class="dt">CaveMap</span> <span class="ot">-&gt;</span> [[<span class="dt">Cave</span>]]</span>
<span id="cb98-11"><a href="#cb98-11" aria-hidden="true" tabindex="-1"></a>findRoutesA caveMap <span class="ot">=</span> findRoutesTo caveMap (Set.empty <span class="op">@</span><span class="dt">Cave</span>) <span class="dt">End</span> <span class="dt">Start</span></span>
<span id="cb98-12"><a href="#cb98-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-13"><a href="#cb98-13" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> [<span class="dt">Link</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb98-14"><a href="#cb98-14" aria-hidden="true" tabindex="-1"></a>solutionA <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> findRoutesA <span class="op">.</span> routing</span></code></pre></div>
</div>
<p>Now for part B. We need a container that allows one item to appear twice. I call this <code>AugmentedSet</code>. All I need to do is implement <code>CaveSet</code> on this new container and we’re done!</p>
<div class="named-code-block">
<p>«solution-day-12»</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AugmentedSet</span> a <span class="ot">=</span> <span class="dt">AugmentedSet</span> (<span class="dt">Set</span> a) (<span class="dt">Maybe</span> a)</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">CaveSet</span> (<span class="dt">AugmentedSet</span> <span class="dt">Cave</span>) <span class="kw">where</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>    visit (<span class="dt">Big</span> _) s <span class="ot">=</span> s</span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a>    visit (<span class="dt">Small</span> c) (<span class="dt">AugmentedSet</span> s <span class="dt">Nothing</span>)</span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> <span class="dt">Small</span> c <span class="ot">`Set.member`</span> s <span class="ot">=</span> <span class="dt">AugmentedSet</span> s (<span class="dt">Just</span> (<span class="dt">Small</span> c))</span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> <span class="fu">otherwise</span>              <span class="ot">=</span> <span class="dt">AugmentedSet</span> (Set.insert (<span class="dt">Small</span> c) s) <span class="dt">Nothing</span></span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a>    visit c (<span class="dt">AugmentedSet</span> s m)</span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> c <span class="ot">`Set.member`</span> s       <span class="ot">=</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;Cave &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> c <span class="op">&lt;&gt;</span> <span class="st">&quot; was already passed&quot;</span></span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> <span class="fu">otherwise</span>              <span class="ot">=</span> <span class="dt">AugmentedSet</span> (Set.insert c s) m</span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-13"><a href="#cb99-13" aria-hidden="true" tabindex="-1"></a>    allowed (<span class="dt">Small</span> c) (<span class="dt">AugmentedSet</span> s <span class="dt">Nothing</span>) <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb99-14"><a href="#cb99-14" aria-hidden="true" tabindex="-1"></a>    allowed i (<span class="dt">AugmentedSet</span> s _) <span class="ot">=</span> i <span class="ot">`Set.notMember`</span> s</span>
<span id="cb99-15"><a href="#cb99-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-16"><a href="#cb99-16" aria-hidden="true" tabindex="-1"></a><span class="ot">findRoutesB ::</span> <span class="dt">CaveMap</span> <span class="ot">-&gt;</span> [[<span class="dt">Cave</span>]]</span>
<span id="cb99-17"><a href="#cb99-17" aria-hidden="true" tabindex="-1"></a>findRoutesB caveMap <span class="ot">=</span> findRoutesTo caveMap emptySet <span class="dt">End</span> <span class="dt">Start</span></span>
<span id="cb99-18"><a href="#cb99-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> emptySet <span class="ot">=</span> <span class="dt">AugmentedSet</span> <span class="op">@</span><span class="dt">Cave</span> Set.empty <span class="dt">Nothing</span></span>
<span id="cb99-19"><a href="#cb99-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-20"><a href="#cb99-20" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> [<span class="dt">Link</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb99-21"><a href="#cb99-21" aria-hidden="true" tabindex="-1"></a>solutionB <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> findRoutesB <span class="op">.</span> routing</span></code></pre></div>
</div>
</section>
<section id="day-13-transparent-origami" class="level1">
<h1>Day 13: Transparent Origami</h1>
<p>We need to fold a piece of transparent paper with dots on it.</p>
<div class="named-code-block">
<p>file:app/Day13.hs</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day13</span> <span class="kw">where</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.ByteString</span> (putStr)</span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List.Partial</span> (head)</span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Set</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> (readInputParsing, <span class="dt">Parser</span>, string, sepEndBy1, eol, integer, char)</span>
<span id="cb100-9"><a href="#cb100-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Massiv.Array</span> (<span class="dt">Ix2</span>(..))</span>
<span id="cb100-10"><a href="#cb100-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Print</span> ( printLn, printCoords )</span>
<span id="cb100-11"><a href="#cb100-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-12"><a href="#cb100-12" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day<span class="op">-</span><span class="dv">13</span><span class="op">&gt;&gt;</span></span>
<span id="cb100-13"><a href="#cb100-13" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day<span class="op">-</span><span class="dv">13</span><span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>As always, we have a parser:</p>
<div class="named-code-block">
<p>«parser-day-13»</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Input</span> <span class="ot">=</span> <span class="dt">Input</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> inputCoordinates ::</span> [<span class="dt">Ix2</span>]</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> foldInstructions ::</span> [<span class="dt">FoldInstruction</span>] }</span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FoldInstruction</span> <span class="ot">=</span> <span class="dt">FoldInstruction</span> <span class="dt">Axis</span> <span class="dt">Int</span></span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Axis</span> <span class="ot">=</span> <span class="dt">XAxis</span> <span class="op">|</span> <span class="dt">YAxis</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-11"><a href="#cb101-11" aria-hidden="true" tabindex="-1"></a><span class="ot">inputP ::</span> <span class="dt">Parser</span> <span class="dt">Input</span></span>
<span id="cb101-12"><a href="#cb101-12" aria-hidden="true" tabindex="-1"></a>inputP <span class="ot">=</span> <span class="dt">Input</span> <span class="op">&lt;$&gt;</span> coordinatesP <span class="op">&lt;*</span> eol <span class="op">&lt;*&gt;</span> foldInstructionsP</span>
<span id="cb101-13"><a href="#cb101-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-14"><a href="#cb101-14" aria-hidden="true" tabindex="-1"></a><span class="ot">coordinatesP ::</span> <span class="dt">Parser</span> [<span class="dt">Ix2</span>]</span>
<span id="cb101-15"><a href="#cb101-15" aria-hidden="true" tabindex="-1"></a>coordinatesP <span class="ot">=</span> sepEndBy1 ((<span class="op">:.</span>) <span class="op">&lt;$&gt;</span> integer <span class="op">&lt;*</span> char <span class="ch">&#39;,&#39;</span> <span class="op">&lt;*&gt;</span> integer) eol</span>
<span id="cb101-16"><a href="#cb101-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-17"><a href="#cb101-17" aria-hidden="true" tabindex="-1"></a><span class="ot">foldInstructionsP ::</span> <span class="dt">Parser</span> [<span class="dt">FoldInstruction</span>]</span>
<span id="cb101-18"><a href="#cb101-18" aria-hidden="true" tabindex="-1"></a>foldInstructionsP <span class="ot">=</span> sepEndBy1 foldInstructionP eol</span>
<span id="cb101-19"><a href="#cb101-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> foldInstructionP <span class="ot">=</span> string <span class="st">&quot;fold along &quot;</span> <span class="op">$&gt;</span> <span class="dt">FoldInstruction</span></span>
<span id="cb101-20"><a href="#cb101-20" aria-hidden="true" tabindex="-1"></a>                          <span class="op">&lt;*&gt;</span> axisP <span class="op">&lt;*</span> char <span class="ch">&#39;=&#39;</span> <span class="op">&lt;*&gt;</span> integer</span>
<span id="cb101-21"><a href="#cb101-21" aria-hidden="true" tabindex="-1"></a>          axisP <span class="ot">=</span>  (<span class="dt">XAxis</span> <span class="op">&lt;$</span> char <span class="ch">&#39;x&#39;</span>)</span>
<span id="cb101-22"><a href="#cb101-22" aria-hidden="true" tabindex="-1"></a>               <span class="op">&lt;|&gt;</span> (<span class="dt">YAxis</span> <span class="op">&lt;$</span> char <span class="ch">&#39;y&#39;</span>)</span>
<span id="cb101-23"><a href="#cb101-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-24"><a href="#cb101-24" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env <span class="dt">Input</span></span>
<span id="cb101-25"><a href="#cb101-25" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day13.txt&quot;</span> inputP</span></code></pre></div>
</div>
<p>For each fold we need to transform the coordinates.</p>
<div class="named-code-block">
<p>«solution-day-13»</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foldTransform ::</span> <span class="dt">FoldInstruction</span> <span class="ot">-&gt;</span> <span class="dt">Ix2</span> <span class="ot">-&gt;</span> <span class="dt">Ix2</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>foldTransform (<span class="dt">FoldInstruction</span> <span class="dt">XAxis</span> loc) (x <span class="op">:.</span> y)</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> x <span class="op">&gt;</span> loc   <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> loc <span class="op">-</span> x <span class="op">:.</span> y</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> x <span class="op">:.</span> y</span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>foldTransform (<span class="dt">FoldInstruction</span> <span class="dt">YAxis</span> loc) (x <span class="op">:.</span> y)</span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> y <span class="op">&gt;</span> loc   <span class="ot">=</span> x <span class="op">:.</span> <span class="dv">2</span> <span class="op">*</span> loc <span class="op">-</span> y</span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> x <span class="op">:.</span> y</span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-9"><a href="#cb102-9" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> <span class="dt">Input</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb102-10"><a href="#cb102-10" aria-hidden="true" tabindex="-1"></a>solutionA <span class="dt">Input</span>{<span class="op">..</span>} <span class="ot">=</span> Set.size</span>
<span id="cb102-11"><a href="#cb102-11" aria-hidden="true" tabindex="-1"></a>                    <span class="op">$</span> Set.map (foldTransform <span class="op">$</span> <span class="fu">head</span> foldInstructions)</span>
<span id="cb102-12"><a href="#cb102-12" aria-hidden="true" tabindex="-1"></a>                    <span class="op">$</span> Set.fromList inputCoordinates</span></code></pre></div>
</div>
<p>Now we need to fold the folds.</p>
<div class="named-code-block">
<p>«solution-day-13»</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foldAllFolds ::</span> <span class="dt">Input</span> <span class="ot">-&gt;</span> [<span class="dt">Ix2</span>]</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>foldAllFolds <span class="dt">Input</span>{<span class="op">..</span>} <span class="ot">=</span> Set.toList <span class="op">$</span> foldl&#39; makeFold </span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>                                             (Set.fromList inputCoordinates)</span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>                                             foldInstructions</span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> makeFold s i <span class="ot">=</span> Set.map (foldTransform i) s</span></code></pre></div>
</div>
<p>Apparently the answer is in visualizing the result, so I’ll print out the coordinates and plot them with Gnuplot.</p>
<div class="named-code-block">
<p>«solution-day-13»</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runA ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env ()</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>runA <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>    inp <span class="ot">&lt;-</span> readInput</span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>    printLn <span class="op">$</span> <span class="st">&quot;# &quot;</span> <span class="op">&lt;&gt;</span> tshow (solutionA inp)</span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a><span class="ot">runB ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env ()</span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a>runB <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a>    inp <span class="ot">&lt;-</span> readInput</span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true" tabindex="-1"></a>    printCoords (foldAllFolds inp)</span></code></pre></div>
</div>
<p><img src="fig/day13-code.svg" class="figure" alt="" /></p>
</section>
<section id="day-14-extended-polymerization" class="level1">
<h1>Day 14: Extended Polymerization</h1>
<div class="named-code-block">
<p>file:app/Day14.hs</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day14</span> <span class="kw">where</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (iterate, sortOn)</span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List.Partial</span> (tail, init, head, last, (!!))</span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.Map</span> ((!?))</span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Lazy</span> <span class="kw">as</span> <span class="dt">LazyMap</span></span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> (<span class="dt">Parser</span>, readInputParsing, sepEndBy1, eol, string)</span>
<span id="cb105-10"><a href="#cb105-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span> (upperChar)</span>
<span id="cb105-11"><a href="#cb105-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.MultiSet</span> (<span class="dt">MultiSet</span>, occur, findMin, findMax)</span>
<span id="cb105-12"><a href="#cb105-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.MultiSet</span> <span class="kw">as</span> <span class="dt">MultiSet</span></span>
<span id="cb105-13"><a href="#cb105-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-14"><a href="#cb105-14" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LazyMap</span> <span class="ot">=</span> <span class="dt">LazyMap.Map</span></span>
<span id="cb105-15"><a href="#cb105-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-16"><a href="#cb105-16" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day14<span class="op">&gt;&gt;</span></span>
<span id="cb105-17"><a href="#cb105-17" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day14<span class="op">&gt;&gt;</span></span>
<span id="cb105-18"><a href="#cb105-18" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«parser-day14»</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Input</span> <span class="ot">=</span> <span class="dt">Input</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> axiom ::</span> [<span class="dt">Char</span>]</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> rules ::</span> <span class="dt">Map</span> (<span class="dt">Char</span>, <span class="dt">Char</span>) <span class="dt">Char</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>    } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a><span class="ot">axiomP ::</span> <span class="dt">Parser</span> [<span class="dt">Char</span>]</span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>axiomP <span class="ot">=</span> some upperChar <span class="op">&lt;*</span> eol</span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a><span class="ot">ruleP ::</span> <span class="dt">Parser</span> ((<span class="dt">Char</span>, <span class="dt">Char</span>), <span class="dt">Char</span>)</span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a>ruleP <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> ((,) <span class="op">&lt;$&gt;</span> upperChar <span class="op">&lt;*&gt;</span> upperChar)</span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">&lt;*</span>  string <span class="st">&quot; -&gt; &quot;</span> <span class="op">&lt;*&gt;</span> upperChar</span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-13"><a href="#cb106-13" aria-hidden="true" tabindex="-1"></a><span class="ot">inputP ::</span> <span class="dt">Parser</span> <span class="dt">Input</span></span>
<span id="cb106-14"><a href="#cb106-14" aria-hidden="true" tabindex="-1"></a>inputP <span class="ot">=</span> <span class="dt">Input</span> <span class="op">&lt;$&gt;</span> axiomP <span class="op">&lt;*</span> eol <span class="op">&lt;*&gt;</span> (Map.fromList <span class="op">&lt;$&gt;</span> sepEndBy1 ruleP eol)</span>
<span id="cb106-15"><a href="#cb106-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-16"><a href="#cb106-16" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env <span class="dt">Input</span></span>
<span id="cb106-17"><a href="#cb106-17" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day14.txt&quot;</span> inputP</span></code></pre></div>
</div>
<div class="named-code-block">
<p>«solution-day14»</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="ot">pairs ::</span> [a] <span class="ot">-&gt;</span> [(a, a)]</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>pairs [] <span class="ot">=</span> []</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>pairs xs <span class="ot">=</span> <span class="fu">zip</span> xs (<span class="fu">tail</span> xs)</span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">GlueList</span> a <span class="ot">=</span> <span class="dt">GlueList</span> {<span class="ot"> fromGlueList ::</span> [a] }</span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> (<span class="dt">GlueList</span> a) <span class="kw">where</span></span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">GlueList</span> (x<span class="op">:</span>xs) <span class="op">&lt;&gt;</span> <span class="dt">GlueList</span> (_<span class="op">:</span>y)  <span class="ot">=</span> <span class="dt">GlueList</span> <span class="op">$</span> (x<span class="op">:</span>xs) <span class="op">&lt;&gt;</span> y</span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">GlueList</span> x <span class="op">&lt;&gt;</span> <span class="dt">GlueList</span> [] <span class="ot">=</span> <span class="dt">GlueList</span> x</span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">GlueList</span> [] <span class="op">&lt;&gt;</span> <span class="dt">GlueList</span> y <span class="ot">=</span> <span class="dt">GlueList</span> y</span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">GlueList</span> a) <span class="kw">where</span></span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">GlueList</span> <span class="fu">mempty</span></span>
<span id="cb107-14"><a href="#cb107-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-15"><a href="#cb107-15" aria-hidden="true" tabindex="-1"></a><span class="ot">step ::</span> <span class="dt">Map</span> (<span class="dt">Char</span>, <span class="dt">Char</span>) <span class="dt">Char</span> <span class="ot">-&gt;</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>]</span>
<span id="cb107-16"><a href="#cb107-16" aria-hidden="true" tabindex="-1"></a>step rules <span class="ot">=</span> fromGlueList <span class="op">.</span> <span class="fu">foldMap</span> insertChar <span class="op">.</span> pairs</span>
<span id="cb107-17"><a href="#cb107-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> insertChar (a, b) <span class="ot">=</span> <span class="kw">case</span> rules <span class="op">!?</span> (a, b) <span class="kw">of</span></span>
<span id="cb107-18"><a href="#cb107-18" aria-hidden="true" tabindex="-1"></a>                                <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">GlueList</span> [a, b]</span>
<span id="cb107-19"><a href="#cb107-19" aria-hidden="true" tabindex="-1"></a>                                <span class="dt">Just</span> c  <span class="ot">-&gt;</span> <span class="dt">GlueList</span> [a, c, b]</span>
<span id="cb107-20"><a href="#cb107-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-21"><a href="#cb107-21" aria-hidden="true" tabindex="-1"></a><span class="ot">countDiff ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb107-22"><a href="#cb107-22" aria-hidden="true" tabindex="-1"></a>countDiff [] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb107-23"><a href="#cb107-23" aria-hidden="true" tabindex="-1"></a>countDiff cs <span class="ot">=</span> <span class="fu">snd</span> (<span class="fu">last</span> counts) <span class="op">-</span> <span class="fu">snd</span> (<span class="fu">head</span> counts)</span>
<span id="cb107-24"><a href="#cb107-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> counts <span class="ot">=</span> sortOn <span class="fu">snd</span> <span class="op">$</span> MultiSet.toOccurList <span class="op">$</span> MultiSet.fromList cs</span>
<span id="cb107-25"><a href="#cb107-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-26"><a href="#cb107-26" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> <span class="dt">Input</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb107-27"><a href="#cb107-27" aria-hidden="true" tabindex="-1"></a>solutionA <span class="dt">Input</span> {<span class="op">..</span>} <span class="ot">=</span> countDiff <span class="op">$</span> (<span class="op">!!</span> <span class="dv">10</span>) <span class="op">$</span> <span class="fu">iterate</span> (step rules) axiom</span>
<span id="cb107-28"><a href="#cb107-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-29"><a href="#cb107-29" aria-hidden="true" tabindex="-1"></a><span class="ot">countMap ::</span> <span class="dt">Map</span> (<span class="dt">Char</span>, <span class="dt">Char</span>) <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">LazyMap</span> ((<span class="dt">Char</span>, <span class="dt">Char</span>), <span class="dt">Int</span>) (<span class="dt">MultiSet</span> <span class="dt">Char</span>)</span>
<span id="cb107-30"><a href="#cb107-30" aria-hidden="true" tabindex="-1"></a>countMap rules <span class="ot">=</span> m</span>
<span id="cb107-31"><a href="#cb107-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> m <span class="ot">=</span> LazyMap.fromList [ (((c1, c2), d), f c1 c2 d) </span>
<span id="cb107-32"><a href="#cb107-32" aria-hidden="true" tabindex="-1"></a>                               <span class="op">|</span> c1 <span class="ot">&lt;-</span> [<span class="ch">&#39;A&#39;</span><span class="op">..</span><span class="ch">&#39;Z&#39;</span>]</span>
<span id="cb107-33"><a href="#cb107-33" aria-hidden="true" tabindex="-1"></a>                               , c2 <span class="ot">&lt;-</span> [<span class="ch">&#39;A&#39;</span><span class="op">..</span><span class="ch">&#39;Z&#39;</span>]</span>
<span id="cb107-34"><a href="#cb107-34" aria-hidden="true" tabindex="-1"></a>                               , d <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="op">..</span><span class="dv">40</span>]]</span>
<span id="cb107-35"><a href="#cb107-35" aria-hidden="true" tabindex="-1"></a><span class="ot">          f ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> <span class="dt">Char</span></span>
<span id="cb107-36"><a href="#cb107-36" aria-hidden="true" tabindex="-1"></a>          f c1 _ <span class="dv">0</span>  <span class="ot">=</span> MultiSet.singleton c1</span>
<span id="cb107-37"><a href="#cb107-37" aria-hidden="true" tabindex="-1"></a>          f c1 c3 d <span class="ot">=</span> <span class="kw">case</span> rules <span class="op">!?</span> (c1, c3) <span class="kw">of</span></span>
<span id="cb107-38"><a href="#cb107-38" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> MultiSet.singleton c1</span>
<span id="cb107-39"><a href="#cb107-39" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">Just</span> c2 <span class="ot">-&gt;</span> m <span class="op">LazyMap.!</span> ((c1, c2), d <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb107-40"><a href="#cb107-40" aria-hidden="true" tabindex="-1"></a>                                <span class="op">&lt;&gt;</span> m <span class="op">LazyMap.!</span> ((c2, c3), d <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb107-41"><a href="#cb107-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-42"><a href="#cb107-42" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> <span class="dt">Input</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb107-43"><a href="#cb107-43" aria-hidden="true" tabindex="-1"></a>solutionB <span class="dt">Input</span>{<span class="op">..</span>} <span class="ot">=</span> <span class="fu">snd</span> (<span class="fu">last</span> counts) <span class="op">-</span> <span class="fu">snd</span> (<span class="fu">head</span> counts)</span>
<span id="cb107-44"><a href="#cb107-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> counts <span class="ot">=</span> sortOn <span class="fu">snd</span> <span class="op">$</span> MultiSet.toOccurList </span>
<span id="cb107-45"><a href="#cb107-45" aria-hidden="true" tabindex="-1"></a>                 <span class="op">$</span> MultiSet.singleton (<span class="fu">last</span> axiom)</span>
<span id="cb107-46"><a href="#cb107-46" aria-hidden="true" tabindex="-1"></a>                 <span class="op">&lt;&gt;</span> <span class="fu">foldMap</span> (\p <span class="ot">-&gt;</span> m <span class="op">LazyMap.!</span> (p, <span class="dv">40</span>)) (pairs axiom)</span>
<span id="cb107-47"><a href="#cb107-47" aria-hidden="true" tabindex="-1"></a>          m <span class="ot">=</span> countMap rules</span></code></pre></div>
</div>
</section>
<section id="day-15-chiton" class="level1">
<h1>Day 15: Chiton</h1>
<p>We are given a map and need to compute the shortest path from the top left to the right bottom. The algorithm to use here is <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra’s algorithm</a>.</p>
<p>I implemented two versions: one for abstract cases, and one on a grid.</p>
<div class="named-code-block">
<p>file:app/Dijkstra.hs</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Dijkstra</span> (minDist, minDistArray2) <span class="kw">where</span></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List.Partial</span> (foldl1&#39;)</span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Set</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.Map</span> ((!?))</span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.PQueue.Min</span> <span class="kw">as</span> <span class="dt">Q</span></span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>dijkstra<span class="op">-</span>imports<span class="op">&gt;&gt;</span></span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>dijkstra<span class="op">-</span>generic<span class="op">&gt;&gt;</span></span>
<span id="cb108-14"><a href="#cb108-14" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>dijkstra<span class="op">-</span>array<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>To put elements on a priority-queue, I defined a <code>newtype</code> that sorts on the second element of a tuple.</p>
<div class="named-code-block">
<p>«dijkstra-generic»</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">DistLoc</span> i a <span class="ot">=</span> <span class="dt">DistLoc</span> (i, a)</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Eq</span>)</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Eq</span> i) <span class="ot">=&gt;</span> <span class="dt">Ord</span> (<span class="dt">DistLoc</span> i a) <span class="kw">where</span></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">compare</span> (<span class="dt">DistLoc</span> (_, x)) (<span class="dt">DistLoc</span> (_, y)) <span class="ot">=</span> <span class="fu">compare</span> x y</span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a><span class="ot">toLoc ::</span> <span class="dt">DistLoc</span> i a <span class="ot">-&gt;</span> i</span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a>toLoc (<span class="dt">DistLoc</span> (l, _)) <span class="ot">=</span> l</span></code></pre></div>
</div>
<p>The generic algorithm looks rather horrible, I won’t bother you with it.</p>
<section id="array-version" class="level3">
<h3>Array version</h3>
<p>For our case with path-finding on a grid. We can have a much more efficient implementation than the generic one.</p>
<div class="named-code-block">
<p>«dijkstra-imports»</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Massiv.Array</span> (<span class="dt">Ix2</span>(..))</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Massiv.Array</span> <span class="kw">as</span> <span class="dt">A</span></span></code></pre></div>
</div>
<p>The entire algorithm now runs in the <code>ST</code> monad, so that we can do array mutation.</p>
<div class="named-code-block">
<p>«dijkstra-array»</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Array2&#39;</span> r a <span class="ot">=</span> <span class="dt">A.Array</span> r <span class="dt">Ix2</span> a</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Array2</span> a <span class="ot">=</span> <span class="dt">Array2&#39;</span> <span class="dt">A.U</span> a</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>condM<span class="op">&gt;&gt;</span></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a><span class="ot">minDistArray2 ::</span> <span class="kw">forall</span> a<span class="op">.</span> (<span class="dt">Ord</span> a, <span class="dt">Num</span> a, <span class="dt">Bounded</span> a, <span class="dt">A.Unbox</span> a, <span class="dt">A.Manifest</span> <span class="dt">A.U</span> a)</span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>              <span class="ot">=&gt;</span> <span class="dt">Array2</span> a <span class="ot">-&gt;</span> (<span class="dt">Ix2</span> <span class="ot">-&gt;</span> [<span class="dt">Ix2</span>]) <span class="ot">-&gt;</span> <span class="dt">Ix2</span> <span class="ot">-&gt;</span> <span class="dt">Ix2</span> <span class="ot">-&gt;</span> a</span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a>minDistArray2 cost neighbours start end <span class="ot">=</span> runST go</span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span><span class="ot"> go ::</span> <span class="kw">forall</span> s<span class="op">.</span> <span class="dt">ST</span> s a</span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true" tabindex="-1"></a>        go <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb111-11"><a href="#cb111-11" aria-hidden="true" tabindex="-1"></a>          <span class="op">&lt;&lt;</span>dijkstra<span class="op">-</span>array<span class="op">-</span><span class="fu">init</span><span class="op">&gt;&gt;</span></span>
<span id="cb111-12"><a href="#cb111-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-13"><a href="#cb111-13" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span></span>
<span id="cb111-14"><a href="#cb111-14" aria-hidden="true" tabindex="-1"></a>              <span class="op">&lt;&lt;</span>dijkstra<span class="op">-</span>array<span class="op">-</span>distloc<span class="op">&gt;&gt;</span></span>
<span id="cb111-15"><a href="#cb111-15" aria-hidden="true" tabindex="-1"></a>              <span class="op">&lt;&lt;</span>dijkstra<span class="op">-</span>array<span class="op">-</span>recur<span class="op">&gt;&gt;</span></span>
<span id="cb111-16"><a href="#cb111-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-17"><a href="#cb111-17" aria-hidden="true" tabindex="-1"></a>          recur Q.empty start</span>
<span id="cb111-18"><a href="#cb111-18" aria-hidden="true" tabindex="-1"></a>          <span class="kw">where</span> size <span class="ot">=</span> A.size cost</span></code></pre></div>
</div>
<section id="init" class="level4">
<h4>Init</h4>
<p>The algorithm is initialised with the <code>unvisited</code> set, encoded as an array of bools, and the tentative distances, stored in another array (of int).</p>
<div class="named-code-block">
<p>«dijkstra-array-init»</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>unvisited <span class="ot">&lt;-</span> A.newMArray <span class="op">@</span><span class="dt">A.U</span> <span class="op">@</span><span class="dt">Bool</span> size <span class="dt">True</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>dist      <span class="ot">&lt;-</span> A.newMArray <span class="op">@</span><span class="dt">A.U</span> <span class="op">@</span>a size <span class="fu">maxBound</span></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>A.write_ dist start <span class="dv">0</span></span></code></pre></div>
</div>
</section>
<section id="estimating-distance" class="level4">
<h4>Estimating distance</h4>
<p>Distance is estimated as the minimum of the last known estimate and the distance from the current node plus the confirmed total distance to the current node.</p>
<div class="named-code-block">
<p>«dijkstra-array-distloc»</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="ot">distLoc ::</span> <span class="dt">Ix2</span> <span class="ot">-&gt;</span> <span class="dt">Ix2</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">DistLoc</span> <span class="dt">Ix2</span> a)</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>distLoc i j <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>    v <span class="ot">&lt;-</span> A.readM dist j</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">&lt;-</span> A.readM dist i</span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="op">$</span> <span class="dt">DistLoc</span> (j, <span class="fu">min</span> v (x <span class="op">+</span> (cost <span class="op">A.!</span> j)))</span></code></pre></div>
</div>
</section>
<section id="recursion" class="level4">
<h4>Recursion</h4>
<p>The recursion keeps the priority-queue of nodes to visit. There are three cases:</p>
<ul>
<li>The node is the end node: we’re done.</li>
<li>The node was already visited: we can skip it.</li>
<li>Otherwise, set the current node to visited, check the neighbours, compute distances for them, update the priority queue and recurse.</li>
</ul>
<div class="named-code-block">
<p>«dijkstra-array-recur»</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="ot">recur ::</span> <span class="dt">Q.MinQueue</span> (<span class="dt">DistLoc</span> <span class="dt">Ix2</span> a) <span class="ot">-&gt;</span> <span class="dt">Ix2</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s a</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>recur q pos <span class="ot">=</span> condM</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>  [ (<span class="fu">pure</span> <span class="op">$</span> pos <span class="op">==</span> end, A.readM dist end)</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>  , (A.readM unvisited pos, <span class="kw">do</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>       A.write_ unvisited pos <span class="dt">False</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>       unvisitedNeighbours <span class="ot">&lt;-</span> filterM (A.readM unvisited) (neighbours pos)</span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>       newDists <span class="ot">&lt;-</span> <span class="fu">mapM</span> (distLoc pos) unvisitedNeighbours</span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a>       <span class="fu">mapM_</span> (\(<span class="dt">DistLoc</span> (i, x)) <span class="ot">-&gt;</span> A.write_ dist i x) newDists</span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a>       <span class="kw">let</span> q&#39; <span class="ot">=</span> foldl&#39; (<span class="fu">flip</span> Q.insert) (Q.deleteMin q) newDists</span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a>       recur q&#39; (toLoc <span class="op">$</span> Q.findMin q&#39;))</span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a>  , (otherwiseM, <span class="kw">do</span></span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a>       <span class="kw">let</span> q&#39; <span class="ot">=</span> Q.deleteMin q</span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a>       recur q&#39; (toLoc <span class="op">$</span> Q.findMin q&#39;)) ]</span></code></pre></div>
</div>
<p>Here <code>condM</code> is a little helper function to write monadic conditions.</p>
<div class="named-code-block">
<p>«condM»</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="ot">condM ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> [(m <span class="dt">Bool</span>, m a)] <span class="ot">-&gt;</span> m a</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>condM ((<span class="fu">pred</span>, action)<span class="op">:</span> cs) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>    c <span class="ot">&lt;-</span> <span class="fu">pred</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> c <span class="kw">then</span> action <span class="kw">else</span> condM cs</span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>condM [] <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;no matching conditions&quot;</span></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a><span class="ot">otherwiseM ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m <span class="dt">Bool</span></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a>otherwiseM <span class="ot">=</span> <span class="fu">pure</span> <span class="dt">True</span></span></code></pre></div>
</div>
</section>
</section>
<section id="solution" class="level3">
<h3>Solution</h3>
<div class="named-code-block">
<p>file:app/Day15.hs</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day15</span> <span class="kw">where</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Massiv.Array</span> (<span class="dt">Ix2</span>(..))</span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Massiv.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> (readInputParsing, digitArray)</span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Dijkstra</span> (minDistArray2, minDist)</span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day15<span class="op">&gt;&gt;</span></span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day15<span class="op">&gt;&gt;</span></span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>We again reuse the parser from day 9.</p>
<div class="named-code-block">
<p>«parser-day15»</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Array2&#39;</span> r a <span class="ot">=</span> <span class="dt">A.Array</span> r <span class="dt">A.Ix2</span> a</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Array2</span> a <span class="ot">=</span> <span class="dt">Array2&#39;</span> <span class="dt">A.U</span> a</span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env (<span class="dt">Array2</span> <span class="dt">Int</span>)</span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day15.txt&quot;</span> digitArray</span></code></pre></div>
</div>
<p>With Dijkstra’s algorithm in place, the solution is not too hard.</p>
<div class="named-code-block">
<p>«solution-day15»</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="ot">neighbours ::</span> (<span class="dt">A.Unbox</span> a) <span class="ot">=&gt;</span> <span class="dt">Array2</span> a <span class="ot">-&gt;</span> <span class="dt">Ix2</span> <span class="ot">-&gt;</span> [<span class="dt">Ix2</span>]</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>neighbours x i <span class="ot">=</span> <span class="fu">filter</span> (isJust <span class="op">.</span> (x <span class="op">A.!?</span>)) <span class="op">$</span> <span class="fu">map</span> (<span class="op">+</span> i) n</span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> n <span class="ot">=</span> [<span class="op">-</span><span class="dv">1</span> <span class="op">:.</span> <span class="dv">0</span>, <span class="dv">1</span> <span class="op">:.</span> <span class="dv">0</span>, <span class="dv">0</span> <span class="op">:.</span> <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span> <span class="op">:.</span> <span class="dv">1</span>]</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a><span class="ot">distance ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Ix2</span> <span class="ot">-&gt;</span> <span class="dt">Ix2</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>distance x _ i <span class="ot">=</span> x <span class="op">A.!?</span> i</span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a><span class="ot">endPoint ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Ix2</span></span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>endPoint x <span class="ot">=</span> A.unSz (A.size x) <span class="op">-</span> (<span class="dv">1</span> <span class="op">:.</span> <span class="dv">1</span>)</span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-11"><a href="#cb118-11" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb118-12"><a href="#cb118-12" aria-hidden="true" tabindex="-1"></a>solutionA inp <span class="ot">=</span> minDistArray2 inp (neighbours inp) (<span class="dv">0</span> <span class="op">:.</span> <span class="dv">0</span>) (endPoint inp)</span>
<span id="cb118-13"><a href="#cb118-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-14"><a href="#cb118-14" aria-hidden="true" tabindex="-1"></a><span class="ot">scaleUp ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Array2</span> <span class="dt">Int</span></span>
<span id="cb118-15"><a href="#cb118-15" aria-hidden="true" tabindex="-1"></a>scaleUp x <span class="ot">=</span> stack <span class="dv">2</span> (stack <span class="dv">1</span> x)</span>
<span id="cb118-16"><a href="#cb118-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> stack axis row <span class="ot">=</span> foldl&#39; (\r t <span class="ot">-&gt;</span> A.compute <span class="op">$</span> A.append&#39; axis r t) row</span>
<span id="cb118-17"><a href="#cb118-17" aria-hidden="true" tabindex="-1"></a>                         <span class="op">$</span> <span class="fu">map</span> (\h <span class="ot">-&gt;</span> A.map (inc h) row) [<span class="dv">1</span><span class="op">..</span><span class="dv">4</span>]</span>
<span id="cb118-18"><a href="#cb118-18" aria-hidden="true" tabindex="-1"></a>          inc h x <span class="ot">=</span> (x <span class="op">-</span> <span class="dv">1</span> <span class="op">+</span> h) <span class="ot">`mod`</span> <span class="dv">9</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb118-19"><a href="#cb118-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-20"><a href="#cb118-20" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb118-21"><a href="#cb118-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- solutionB inp&#39; = minDist (neighbours inp) (distance inp) (0 :. 0) (endPoint inp)</span></span>
<span id="cb118-22"><a href="#cb118-22" aria-hidden="true" tabindex="-1"></a>solutionB inp&#39; <span class="ot">=</span> minDistArray2 inp (neighbours inp) (<span class="dv">0</span> <span class="op">:.</span> <span class="dv">0</span>) (endPoint inp)</span>
<span id="cb118-23"><a href="#cb118-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> inp <span class="ot">=</span> scaleUp inp&#39;</span></code></pre></div>
</div>
</section>
</section>
<section id="day-16-packet-decoder" class="level1">
<h1>Day 16: Packet Decoder</h1>
<p>Oh boy. I defined a <code>Stream</code> instance for Megaparsec on the <code>Bitstream</code> type from the <code>bitstreams</code> package. This lets me define some elementary parsers.</p>
<div class="named-code-block">
<p>file:app/Parsing/Binary.hs</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Parsing.Binary</span> <span class="kw">where</span></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Bits</span> (<span class="dt">Bits</span>)</span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Vector.Storable</span> (<span class="dt">Vector</span>)</span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector.Storable</span> <span class="kw">as</span> <span class="dt">Vector</span></span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Bitstream</span> <span class="kw">as</span> <span class="dt">BS</span></span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Bitstream.Packet</span> (toOctet)</span>
<span id="cb119-10"><a href="#cb119-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Bitstream.Generic</span> <span class="kw">as</span> <span class="dt">BSG</span></span>
<span id="cb119-11"><a href="#cb119-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> (<span class="dt">Parsec</span>, <span class="dt">Stream</span>(..), takeP, anySingle)</span>
<span id="cb119-12"><a href="#cb119-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-13"><a href="#cb119-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">BSG.Bitstream</span> (<span class="dt">BS.Bitstream</span> d)) <span class="ot">=&gt;</span> <span class="dt">Stream</span> (<span class="dt">BS.Bitstream</span> d) <span class="kw">where</span></span>
<span id="cb119-14"><a href="#cb119-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Token</span> (<span class="dt">BS.Bitstream</span> d) <span class="ot">=</span> <span class="dt">Bool</span></span>
<span id="cb119-15"><a href="#cb119-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Tokens</span> (<span class="dt">BS.Bitstream</span> d) <span class="ot">=</span> <span class="dt">BS.Bitstream</span> d</span>
<span id="cb119-16"><a href="#cb119-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-17"><a href="#cb119-17" aria-hidden="true" tabindex="-1"></a>    tokensToChunk pxy <span class="ot">=</span> BS.pack</span>
<span id="cb119-18"><a href="#cb119-18" aria-hidden="true" tabindex="-1"></a>    chunkToTokens pxy <span class="ot">=</span> BS.unpack</span>
<span id="cb119-19"><a href="#cb119-19" aria-hidden="true" tabindex="-1"></a>    chunkLength pxy <span class="ot">=</span> BS.length</span>
<span id="cb119-20"><a href="#cb119-20" aria-hidden="true" tabindex="-1"></a>    chunkEmpty pxy <span class="ot">=</span> BS.null</span>
<span id="cb119-21"><a href="#cb119-21" aria-hidden="true" tabindex="-1"></a>    take1_ s</span>
<span id="cb119-22"><a href="#cb119-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> BS.null s <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb119-23"><a href="#cb119-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Just</span> (BS.head s, BS.tail s)</span>
<span id="cb119-24"><a href="#cb119-24" aria-hidden="true" tabindex="-1"></a>    takeN_ n s</span>
<span id="cb119-25"><a href="#cb119-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> BS.length s <span class="op">&lt;</span> n <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb119-26"><a href="#cb119-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Just</span> (BS.take n s, BS.drop n s)</span>
<span id="cb119-27"><a href="#cb119-27" aria-hidden="true" tabindex="-1"></a>    takeWhile_ <span class="ot">=</span> BS.span</span>
<span id="cb119-28"><a href="#cb119-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-29"><a href="#cb119-29" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">BitParser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> (<span class="dt">BS.Bitstream</span> <span class="dt">BS.Right</span>)</span>
<span id="cb119-30"><a href="#cb119-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-31"><a href="#cb119-31" aria-hidden="true" tabindex="-1"></a><span class="ot">intN ::</span> (<span class="dt">Integral</span> n, <span class="dt">Bits</span> n) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BitParser</span> n</span>
<span id="cb119-32"><a href="#cb119-32" aria-hidden="true" tabindex="-1"></a>intN n <span class="ot">=</span> BS.toBits <span class="op">&lt;$&gt;</span> takeP (<span class="dt">Just</span> <span class="op">$</span> <span class="fu">show</span> n <span class="op">&lt;&gt;</span> <span class="st">&quot; bit integer&quot;</span>) n</span>
<span id="cb119-33"><a href="#cb119-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-34"><a href="#cb119-34" aria-hidden="true" tabindex="-1"></a><span class="ot">bool ::</span> <span class="dt">BitParser</span> <span class="dt">Bool</span></span>
<span id="cb119-35"><a href="#cb119-35" aria-hidden="true" tabindex="-1"></a>bool <span class="ot">=</span> anySingle</span>
<span id="cb119-36"><a href="#cb119-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-37"><a href="#cb119-37" aria-hidden="true" tabindex="-1"></a><span class="ot">bit ::</span> <span class="dt">BitParser</span> <span class="dt">Word8</span></span>
<span id="cb119-38"><a href="#cb119-38" aria-hidden="true" tabindex="-1"></a>bit <span class="ot">=</span> intN <span class="dv">1</span></span>
<span id="cb119-39"><a href="#cb119-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-40"><a href="#cb119-40" aria-hidden="true" tabindex="-1"></a><span class="ot">skip ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BitParser</span> ()</span>
<span id="cb119-41"><a href="#cb119-41" aria-hidden="true" tabindex="-1"></a>skip n <span class="ot">=</span> void <span class="op">$</span> takeP (<span class="dt">Just</span> <span class="op">$</span> <span class="st">&quot;skipping &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> n <span class="op">&lt;&gt;</span> <span class="st">&quot; bits&quot;</span>) n</span></code></pre></div>
</div>
<p>Now, I have a lot of imports.</p>
<div class="named-code-block">
<p>file:app/Day16.hs</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day16</span> <span class="kw">where</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span> <span class="kw">hiding</span> (bool, try)</span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.Char</span> (ord)</span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List.Partial</span> (foldl1&#39;)</span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.Partial</span> (toEnum)</span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.ByteString</span> <span class="kw">as</span> <span class="dt">ByteString</span></span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Bitstream</span> (<span class="dt">Bitstream</span>, <span class="dt">Right</span>)</span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Bitstream</span> <span class="kw">as</span> <span class="dt">Bitstream</span></span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> (<span class="dt">Parser</span>, readInputParsing)</span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing.Binary</span> (<span class="dt">BitParser</span>, intN, bool, skip, bit)</span>
<span id="cb120-13"><a href="#cb120-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (replicateM)</span>
<span id="cb120-14"><a href="#cb120-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> (parse, chunk, try, takeP)</span>
<span id="cb120-15"><a href="#cb120-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span> (hexDigitChar)</span>
<span id="cb120-16"><a href="#cb120-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-17"><a href="#cb120-17" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day16<span class="op">&gt;&gt;</span></span>
<span id="cb120-18"><a href="#cb120-18" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="kw">data</span><span class="op">-</span>types<span class="op">-</span>day16<span class="op">&gt;&gt;</span></span>
<span id="cb120-19"><a href="#cb120-19" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>bits<span class="op">-</span>parser<span class="op">-</span>day16<span class="op">&gt;&gt;</span></span>
<span id="cb120-20"><a href="#cb120-20" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>evaluator<span class="op">-</span>day16<span class="op">&gt;&gt;</span></span>
<span id="cb120-21"><a href="#cb120-21" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day16<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>First we need to parse the hexadecimal notation to a <code>Bitstream Right</code> object.</p>
<div class="named-code-block">
<p>«parser-day16»</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="ot">nibble ::</span> <span class="dt">Parser</span> <span class="dt">Word8</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>nibble <span class="ot">=</span> hexDigitChar <span class="op">&gt;&gt;=</span> toValue </span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> toValue c</span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="ch">&#39;0&#39;</span> <span class="op">&lt;=</span> c <span class="op">&amp;&amp;</span> c <span class="op">&lt;=</span> <span class="ch">&#39;9&#39;</span> <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> <span class="fu">fromIntegral</span> <span class="op">$</span> <span class="fu">ord</span> c <span class="op">-</span> <span class="fu">ord</span> <span class="ch">&#39;0&#39;</span></span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="ch">&#39;a&#39;</span> <span class="op">&lt;=</span> c <span class="op">&amp;&amp;</span> c <span class="op">&lt;=</span> <span class="ch">&#39;f&#39;</span> <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> <span class="fu">fromIntegral</span> <span class="op">$</span> <span class="fu">ord</span> c <span class="op">-</span> <span class="fu">ord</span> <span class="ch">&#39;a&#39;</span> <span class="op">+</span> <span class="dv">10</span></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="ch">&#39;A&#39;</span> <span class="op">&lt;=</span> c <span class="op">&amp;&amp;</span> c <span class="op">&lt;=</span> <span class="ch">&#39;F&#39;</span> <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> <span class="fu">fromIntegral</span> <span class="op">$</span> <span class="fu">ord</span> c <span class="op">-</span> <span class="fu">ord</span> <span class="ch">&#39;A&#39;</span> <span class="op">+</span> <span class="dv">10</span></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">fail</span> <span class="st">&quot;not a hexadecimal character&quot;</span></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a><span class="ot">byte ::</span> <span class="dt">Parser</span> <span class="dt">Word8</span></span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a>byte <span class="ot">=</span> combine <span class="op">&lt;$&gt;</span> nibble <span class="op">&lt;*&gt;</span> nibble</span>
<span id="cb121-11"><a href="#cb121-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> combine a b <span class="ot">=</span> a<span class="op">*</span><span class="dv">16</span> <span class="op">+</span> b</span>
<span id="cb121-12"><a href="#cb121-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-13"><a href="#cb121-13" aria-hidden="true" tabindex="-1"></a><span class="ot">bitstream ::</span> <span class="dt">Parser</span> (<span class="dt">Bitstream</span> <span class="dt">Right</span>)</span>
<span id="cb121-14"><a href="#cb121-14" aria-hidden="true" tabindex="-1"></a>bitstream <span class="ot">=</span> Bitstream.fromByteString <span class="op">.</span> <span class="dt">ByteString</span><span class="op">.</span><span class="fu">pack</span> <span class="op">&lt;$&gt;</span> some byte</span></code></pre></div>
</div>
<p>Then I parse directly to a single packet:</p>
<div class="named-code-block">
<p>«parser-day16»</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="ot">readBitstream ::</span> (<span class="dt">MonadReader</span> env m, <span class="dt">MonadIO</span> m, <span class="dt">HasLogFunc</span> env)</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>              <span class="ot">=&gt;</span> <span class="dt">Bitstream</span> <span class="dt">Right</span> <span class="ot">-&gt;</span> <span class="dt">BitParser</span> a <span class="ot">-&gt;</span> m a</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>readBitstream b p <span class="ot">=</span></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">either</span> (\e <span class="ot">-&gt;</span> <span class="kw">do</span> { logError <span class="op">$</span> display (tshow e); exitFailure })</span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>           <span class="fu">return</span> (parse p <span class="st">&quot;-&quot;</span> b)</span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env <span class="dt">Packet</span></span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a>    bits <span class="ot">&lt;-</span> readInputParsing <span class="st">&quot;data/day16.txt&quot;</span> bitstream</span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true" tabindex="-1"></a>    readBitstream bits packet</span></code></pre></div>
</div>
<p>These are my data types: a <code>TypeId</code>, a <code>Packet</code> container and <code>PacketContent</code> which is either a literal value or an operator.</p>
<div class="named-code-block">
<p>«data-types-day16»</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TypeId</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">SumId</span></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">ProductId</span></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">MinimumId</span></span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">MaximumId</span></span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">LiteralValueId</span></span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">GreaterThanId</span></span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">LessThanId</span></span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">EqualToId</span></span>
<span id="cb123-10"><a href="#cb123-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Enum</span>)</span>
<span id="cb123-11"><a href="#cb123-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-12"><a href="#cb123-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Packet</span> <span class="ot">=</span> <span class="dt">Packet</span></span>
<span id="cb123-13"><a href="#cb123-13" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> packetVersion ::</span> <span class="dt">Int</span></span>
<span id="cb123-14"><a href="#cb123-14" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> packetContent ::</span> <span class="dt">PacketContent</span></span>
<span id="cb123-15"><a href="#cb123-15" aria-hidden="true" tabindex="-1"></a>    } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb123-16"><a href="#cb123-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-17"><a href="#cb123-17" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">PacketContent</span></span>
<span id="cb123-18"><a href="#cb123-18" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">LiteralValuePacket</span> <span class="dt">Int</span></span>
<span id="cb123-19"><a href="#cb123-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">OperatorPacket</span> <span class="dt">TypeId</span> [<span class="dt">Packet</span>]</span>
<span id="cb123-20"><a href="#cb123-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
</div>
<p>So, now we need to parse the bit stream to a <code>Packet</code> object. These are a quite direct translation of the problem text into code. The ugly bit is that inside <code>operatorPacket</code>, we need to call the <code>parse</code> function recursively.</p>
<div class="named-code-block">
<p>«bits-parser-day16»</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="ot">version ::</span> <span class="dt">BitParser</span> <span class="dt">Int</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>version <span class="ot">=</span> intN <span class="dv">3</span></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a><span class="ot">typeId ::</span> <span class="dt">TypeId</span> <span class="ot">-&gt;</span> <span class="dt">BitParser</span> ()</span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>typeId i <span class="ot">=</span> void <span class="op">$</span> chunk (Bitstream.fromNBits <span class="dv">3</span> (<span class="fu">fromEnum</span> i))</span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a><span class="ot">literalValuePacket ::</span> <span class="dt">BitParser</span> <span class="dt">PacketContent</span></span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a>literalValuePacket <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb124-9"><a href="#cb124-9" aria-hidden="true" tabindex="-1"></a>    typeId <span class="dt">LiteralValueId</span></span>
<span id="cb124-10"><a href="#cb124-10" aria-hidden="true" tabindex="-1"></a>    loop <span class="dv">0</span></span>
<span id="cb124-11"><a href="#cb124-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> loop n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb124-12"><a href="#cb124-12" aria-hidden="true" tabindex="-1"></a>            continue <span class="ot">&lt;-</span> bool</span>
<span id="cb124-13"><a href="#cb124-13" aria-hidden="true" tabindex="-1"></a>            nib <span class="ot">&lt;-</span> intN <span class="dv">4</span></span>
<span id="cb124-14"><a href="#cb124-14" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> n&#39; <span class="ot">=</span> n <span class="op">*</span> <span class="dv">16</span> <span class="op">+</span> nib</span>
<span id="cb124-15"><a href="#cb124-15" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> continue <span class="kw">then</span> loop n&#39;</span>
<span id="cb124-16"><a href="#cb124-16" aria-hidden="true" tabindex="-1"></a>            <span class="kw">else</span> <span class="fu">return</span> <span class="op">$</span> <span class="dt">LiteralValuePacket</span> n&#39;</span>
<span id="cb124-17"><a href="#cb124-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-18"><a href="#cb124-18" aria-hidden="true" tabindex="-1"></a><span class="ot">operatorPacket ::</span> <span class="dt">BitParser</span> <span class="dt">PacketContent</span></span>
<span id="cb124-19"><a href="#cb124-19" aria-hidden="true" tabindex="-1"></a>operatorPacket <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb124-20"><a href="#cb124-20" aria-hidden="true" tabindex="-1"></a>    typeId <span class="ot">&lt;-</span> <span class="fu">toEnum</span> <span class="op">&lt;$&gt;</span> intN <span class="op">@</span><span class="dt">Int</span> <span class="dv">3</span></span>
<span id="cb124-21"><a href="#cb124-21" aria-hidden="true" tabindex="-1"></a>    lengthType <span class="ot">&lt;-</span> bit</span>
<span id="cb124-22"><a href="#cb124-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> lengthType <span class="op">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb124-23"><a href="#cb124-23" aria-hidden="true" tabindex="-1"></a>        l <span class="ot">&lt;-</span> intN <span class="dv">15</span></span>
<span id="cb124-24"><a href="#cb124-24" aria-hidden="true" tabindex="-1"></a>        subbits <span class="ot">&lt;-</span> takeP (<span class="dt">Just</span> <span class="st">&quot;sub-packets&quot;</span>) l</span>
<span id="cb124-25"><a href="#cb124-25" aria-hidden="true" tabindex="-1"></a>        subpkts <span class="ot">&lt;-</span> <span class="fu">either</span> (<span class="fu">fail</span> <span class="op">.</span> <span class="fu">show</span>) <span class="fu">return</span></span>
<span id="cb124-26"><a href="#cb124-26" aria-hidden="true" tabindex="-1"></a>                 <span class="op">$</span> parse (some packet) <span class="st">&quot;-&quot;</span> subbits</span>
<span id="cb124-27"><a href="#cb124-27" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> <span class="op">$</span> <span class="dt">OperatorPacket</span> typeId subpkts</span>
<span id="cb124-28"><a href="#cb124-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="kw">do</span></span>
<span id="cb124-29"><a href="#cb124-29" aria-hidden="true" tabindex="-1"></a>        l <span class="ot">&lt;-</span> intN <span class="dv">11</span></span>
<span id="cb124-30"><a href="#cb124-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">OperatorPacket</span> typeId <span class="op">&lt;$&gt;</span> replicateM l packet</span>
<span id="cb124-31"><a href="#cb124-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-32"><a href="#cb124-32" aria-hidden="true" tabindex="-1"></a><span class="ot">packet ::</span> <span class="dt">BitParser</span> <span class="dt">Packet</span></span>
<span id="cb124-33"><a href="#cb124-33" aria-hidden="true" tabindex="-1"></a>packet <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb124-34"><a href="#cb124-34" aria-hidden="true" tabindex="-1"></a>    packetVersion <span class="ot">&lt;-</span> version</span>
<span id="cb124-35"><a href="#cb124-35" aria-hidden="true" tabindex="-1"></a>    packetContent <span class="ot">&lt;-</span> try literalValuePacket</span>
<span id="cb124-36"><a href="#cb124-36" aria-hidden="true" tabindex="-1"></a>                 <span class="op">&lt;|&gt;</span> operatorPacket</span>
<span id="cb124-37"><a href="#cb124-37" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="op">$</span> <span class="dt">Packet</span> {<span class="op">..</span>}</span></code></pre></div>
</div>
<p>To solve part A, we need to sum all version numbers.</p>
<div class="named-code-block">
<p>«solution-day16»</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getVersions ::</span> <span class="dt">Packet</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>getVersions <span class="dt">Packet</span> {<span class="op">..</span>} <span class="ot">=</span> [packetVersion] <span class="op">&lt;&gt;</span> versions packetContent</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> versions (<span class="dt">OperatorPacket</span> _ p) <span class="ot">=</span> <span class="fu">concatMap</span> getVersions p</span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>          versions _                    <span class="ot">=</span> []</span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> <span class="dt">Packet</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a>solutionA <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> getVersions</span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-9"><a href="#cb125-9" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> <span class="dt">Packet</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb125-10"><a href="#cb125-10" aria-hidden="true" tabindex="-1"></a>solutionB <span class="ot">=</span> evalPacket</span>
<span id="cb125-11"><a href="#cb125-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-12"><a href="#cb125-12" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>For part B, we need to evaluate the computation that is contained in the message.</p>
<div class="named-code-block">
<p>«evaluator-day16»</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="ot">evalPacket ::</span> <span class="dt">Packet</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>evalPacket <span class="dt">Packet</span>{<span class="op">..</span>} <span class="ot">=</span> eval packetContent</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> eval (<span class="dt">LiteralValuePacket</span> i) <span class="ot">=</span> i</span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>          eval (<span class="dt">OperatorPacket</span> op p)  <span class="ot">=</span> eval&#39; op (<span class="fu">map</span> evalPacket p)</span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a>          eval&#39; <span class="dt">SumId</span> p               <span class="ot">=</span> <span class="fu">sum</span> p</span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>          eval&#39; <span class="dt">ProductId</span> p           <span class="ot">=</span> <span class="fu">product</span> p</span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a>          eval&#39; <span class="dt">MinimumId</span> p           <span class="ot">=</span> foldl1&#39; <span class="fu">min</span> p</span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a>          eval&#39; <span class="dt">MaximumId</span> p           <span class="ot">=</span> foldl1&#39; <span class="fu">max</span> p</span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a>          eval&#39; <span class="dt">GreaterThanId</span> [a, b]  <span class="ot">=</span> <span class="kw">if</span> a <span class="op">&gt;</span> b <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></span>
<span id="cb126-10"><a href="#cb126-10" aria-hidden="true" tabindex="-1"></a>          eval&#39; <span class="dt">LessThanId</span> [a, b]     <span class="ot">=</span> <span class="kw">if</span> a <span class="op">&lt;</span> b <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></span>
<span id="cb126-11"><a href="#cb126-11" aria-hidden="true" tabindex="-1"></a>          eval&#39; <span class="dt">EqualToId</span> [a, b]      <span class="ot">=</span> <span class="kw">if</span> a <span class="op">==</span> b <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></span>
<span id="cb126-12"><a href="#cb126-12" aria-hidden="true" tabindex="-1"></a>          eval&#39; _ _                   <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;illegal expression&quot;</span></span></code></pre></div>
</div>
<p>So this code is still full of partial functions, which is not so nice, but it’s getting late.</p>
</section>
<section id="day-17-trick-shot" class="level1">
<h1>Day 17: Trick Shot</h1>
<p>Today we need to do some math. The first part, we can even compute by hand! We are given a target area for a probe. Starting at position <span class="math inline">\((0,0)\)</span>, and an unknown initial velocity, we are given a rectangular area to hit. The probe lives in the weird integer arithmetic universe that we’ve come to love from Advent of Code</p>
<div class="named-code-block">
<p>file:app/Day17.hs</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day17</span> <span class="kw">where</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> (<span class="dt">Parser</span>, readInputParsing, string, integer, lexeme, char)</span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Linear.V2</span> (<span class="dt">V2</span>(..))</span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Print</span> ( printLn )</span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="kw">data</span><span class="op">-</span>types<span class="op">-</span>day17<span class="op">&gt;&gt;</span></span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day17<span class="op">&gt;&gt;</span></span>
<span id="cb127-10"><a href="#cb127-10" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day17<span class="op">&gt;&gt;</span></span>
<span id="cb127-11"><a href="#cb127-11" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«data-types-day17»</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Area</span> <span class="ot">=</span> <span class="dt">Area</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> minX ::</span> <span class="dt">Int</span></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> maxX ::</span> <span class="dt">Int</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> minY ::</span> <span class="dt">Int</span></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> maxY ::</span> <span class="dt">Int</span></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a>    } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">PhaseSpace</span> <span class="ot">=</span> <span class="dt">PhaseSpace</span></span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> position ::</span> <span class="dt">V2</span> <span class="dt">Int</span></span>
<span id="cb128-10"><a href="#cb128-10" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> velocity ::</span> <span class="dt">V2</span> <span class="dt">Int</span></span>
<span id="cb128-11"><a href="#cb128-11" aria-hidden="true" tabindex="-1"></a>    } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
</div>
<p>But first, parsing! (I know, overkill)</p>
<div class="named-code-block">
<p>«parser-day17»</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="ot">areaP ::</span> <span class="dt">Parser</span> <span class="dt">Area</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>areaP <span class="ot">=</span> <span class="dt">Area</span> <span class="op">&lt;$</span> string <span class="st">&quot;x=&quot;</span> <span class="op">&lt;*&gt;</span> integer <span class="op">&lt;*</span> rangeSep <span class="op">&lt;*&gt;</span> integer</span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>             <span class="op">&lt;*</span> listSep</span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>             <span class="op">&lt;*</span> string <span class="st">&quot;y=&quot;</span> <span class="op">&lt;*&gt;</span> integer <span class="op">&lt;*</span> rangeSep <span class="op">&lt;*&gt;</span> integer</span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> rangeSep <span class="ot">=</span> lexeme (string <span class="st">&quot;..&quot;</span>)</span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a>          listSep <span class="ot">=</span> lexeme (char <span class="ch">&#39;,&#39;</span>)</span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-8"><a href="#cb129-8" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env <span class="dt">Area</span></span>
<span id="cb129-9"><a href="#cb129-9" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day17.txt&quot;</span> (string <span class="st">&quot;target area: &quot;</span> <span class="op">*&gt;</span> areaP)</span></code></pre></div>
</div>
<p>The rules are that each timestep:</p>
<ul>
<li>position increases with velocity</li>
<li>the velocity in x-direction decreases in magnitude due to drag</li>
<li>the velocity in y-direction increases in negative direction by one due to gravity</li>
</ul>
<div class="named-code-block">
<p>«solution-day17»</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="ot">step ::</span> <span class="dt">PhaseSpace</span> <span class="ot">-&gt;</span> <span class="dt">PhaseSpace</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>step (<span class="dt">PhaseSpace</span> position velocity<span class="op">@</span>(<span class="dt">V2</span> vx vy)) <span class="ot">=</span> <span class="dt">PhaseSpace</span></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>    { position <span class="ot">=</span> position <span class="op">+</span> velocity</span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a>    , velocity <span class="ot">=</span> <span class="dt">V2</span> (vx <span class="op">-</span> <span class="fu">signum</span> vx) (vy <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
</div>
<p>We need to see if the probe hits the target area, but also if it definitely missed it.</p>
<div class="named-code-block">
<p>«solution-day17»</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="ot">hit ::</span> <span class="dt">Area</span> <span class="ot">-&gt;</span> <span class="dt">PhaseSpace</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>hit <span class="dt">Area</span>{<span class="op">..</span>} (<span class="dt">PhaseSpace</span> (<span class="dt">V2</span> x y) _) <span class="ot">=</span> minX <span class="op">&lt;=</span> x <span class="op">&amp;&amp;</span> x <span class="op">&lt;=</span> maxX</span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>                                    <span class="op">&amp;&amp;</span> minY <span class="op">&lt;=</span> y <span class="op">&amp;&amp;</span> y <span class="op">&lt;=</span> maxY</span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a><span class="ot">miss ::</span> <span class="dt">Area</span> <span class="ot">-&gt;</span> <span class="dt">PhaseSpace</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a>miss <span class="dt">Area</span>{<span class="op">..</span>} (<span class="dt">PhaseSpace</span> (<span class="dt">V2</span> _ y) (<span class="dt">V2</span> _ dy)) <span class="ot">=</span> y <span class="op">&lt;</span> minY <span class="op">&amp;&amp;</span> dy <span class="op">&lt;</span> <span class="dv">0</span></span></code></pre></div>
</div>
<p>The key is now to find the maximum velocity upward. The point being that the probe always returns to level 0, with negative that velocity. If that velocity will make the probe overshoot, than we definetly miss target. The minimum velocity is <span class="math inline">\(y_{\rm min}\)</span>, so the maximum velocity is <span class="math inline">\(-y_{\rm min} - 1\)</span>.</p>
<p>The height attained at the maximum y velocity is <span class="math inline">\((v_y (v_y + 1)) / 2\)</span>.</p>
<p>For the velocity in the X direction, the final X position we reach is <span class="math inline">\((v_x (v_x + 1))/2\)</span>, so the minimum velocity is <span class="math inline">\(\lfloor \sqrt{2 x_{\rm min}} \rfloor\)</span>. The maximum velocity is <span class="math inline">\(x_{\rm max}\)</span>.</p>
<div class="named-code-block">
<p>«solution-day17»</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="ot">velocityBounds ::</span> <span class="dt">Area</span> <span class="ot">-&gt;</span> (<span class="dt">V2</span> <span class="dt">Int</span>, <span class="dt">V2</span> <span class="dt">Int</span>)</span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>velocityBounds <span class="dt">Area</span>{<span class="op">..</span>} <span class="ot">=</span> (<span class="dt">V2</span> minvx minvy, <span class="dt">V2</span> maxvx maxvy)</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> minvy <span class="ot">=</span> minY</span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a>          maxvy <span class="ot">=</span> (<span class="op">-</span>minY) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a>          minvx <span class="ot">=</span> <span class="fu">floor</span> (<span class="fu">sqrt</span> (<span class="fu">fromIntegral</span> <span class="op">$</span> minX <span class="op">*</span> <span class="dv">2</span>))</span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a>          maxvx <span class="ot">=</span> maxX</span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Outcome</span> <span class="ot">=</span> <span class="dt">Hit</span> <span class="op">|</span> <span class="dt">Miss</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>)</span>
<span id="cb132-9"><a href="#cb132-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-10"><a href="#cb132-10" aria-hidden="true" tabindex="-1"></a><span class="ot">iterateUntil ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb132-11"><a href="#cb132-11" aria-hidden="true" tabindex="-1"></a>iterateUntil f p <span class="fu">init</span></span>
<span id="cb132-12"><a href="#cb132-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> p <span class="fu">init</span>    <span class="ot">=</span> <span class="fu">init</span></span>
<span id="cb132-13"><a href="#cb132-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> iterateUntil f p (f <span class="fu">init</span>)</span>
<span id="cb132-14"><a href="#cb132-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-15"><a href="#cb132-15" aria-hidden="true" tabindex="-1"></a><span class="ot">outcome ::</span> <span class="dt">Area</span> <span class="ot">-&gt;</span> <span class="dt">V2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Outcome</span></span>
<span id="cb132-16"><a href="#cb132-16" aria-hidden="true" tabindex="-1"></a>outcome a v <span class="ot">=</span> <span class="kw">if</span> hit a <span class="fu">last</span> <span class="kw">then</span> <span class="dt">Hit</span> <span class="kw">else</span> <span class="dt">Miss</span></span>
<span id="cb132-17"><a href="#cb132-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> <span class="fu">last</span> <span class="ot">=</span> iterateUntil step (\x <span class="ot">-&gt;</span> hit a x <span class="op">||</span> miss a x) </span>
<span id="cb132-18"><a href="#cb132-18" aria-hidden="true" tabindex="-1"></a>                              (<span class="dt">PhaseSpace</span> (<span class="dt">V2</span> <span class="dv">0</span> <span class="dv">0</span>) v)</span></code></pre></div>
</div>
<p>For part B we actually need to compute.</p>
<div class="named-code-block">
<p>«solution-day17»</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> <span class="dt">Area</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>solutionA <span class="dt">Area</span>{<span class="op">..</span>} <span class="ot">=</span> maxv <span class="op">*</span> (maxv <span class="op">+</span> <span class="dv">1</span>) <span class="ot">`div`</span> <span class="dv">2</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> maxv <span class="ot">=</span> (<span class="op">-</span> minY) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> <span class="dt">Area</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a>solutionB a <span class="ot">=</span> <span class="fu">length</span> [ <span class="dt">V2</span> vx vy</span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true" tabindex="-1"></a>                     <span class="op">|</span> vx <span class="ot">&lt;-</span> [minvx <span class="op">..</span> maxvx]</span>
<span id="cb133-8"><a href="#cb133-8" aria-hidden="true" tabindex="-1"></a>                     , vy <span class="ot">&lt;-</span> [minvy <span class="op">..</span> maxvy]</span>
<span id="cb133-9"><a href="#cb133-9" aria-hidden="true" tabindex="-1"></a>                     , outcome a (<span class="dt">V2</span> vx vy) <span class="op">==</span> <span class="dt">Hit</span> ]</span>
<span id="cb133-10"><a href="#cb133-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> (<span class="dt">V2</span> minvx minvy, <span class="dt">V2</span> maxvx maxvy) <span class="ot">=</span> velocityBounds a</span></code></pre></div>
</div>
<p>If I plot the time of impact for every initial velocity, a structure to the solution appears, which makes me think there should be a nicer solution to this problem than brute forcing.</p>
<p><img src="fig/day17-code.svg" class="figure" alt="" /></p>
<p>We have an initial set of trivial solutions, reaching the target area in one time step. From that we may be able to derive a set of solutions that reach the same target in two steps, and so on.</p>
<p>Given a point <span class="math inline">\(p = (p_x, p_y)\)</span>, we may reach this point in one step if the initial velocity <span class="math inline">\(v(0) = p\)</span>. We can compute the effect of two time steps.</p>
<p><span class="math display">\[x(2) = v_x(0) + v_x(1) = 2 v_x(0) - 1\]</span> <span class="math display">\[y(2) = v_y(0) + v_y(1) = 2 v_y(0) + 1\]</span></p>
<p>In general we can say,</p>
<p><span class="math display">\[x(t) = \min (t * v_x(0) - \Delta(t - 1), \Delta(v_x(0))),\]</span> <span class="math display">\[y(t) = t * v_y(0) - \Delta(t - 1),\]</span></p>
<p>where <span class="math inline">\(\Delta(t) = t(t+1)/2.\)</span> Now the question is, can we invert those to solve <span class="math inline">\(v(0)\)</span> from <span class="math inline">\(x(t)\)</span>? The <span class="math inline">\(y\)</span> component is not too hard:</p>
<p><span class="math display">\[v_y(0) = (y(t) + \Delta(t - 1)) / t = y(t) / t + (t - 1) / 2,\]</span></p>
<p>noting that we’re still limited to integer solutions; <span class="math inline">\(y(t) \mod t = 0\)</span> if <span class="math inline">\(t\)</span> is odd and <span class="math inline">\(y(t) \mod t = t/2\)</span> if <span class="math inline">\(t\)</span> is even.</p>
<p>The <span class="math inline">\(x\)</span> velocity is a bit more tricky. If <span class="math inline">\(t \le v_x(0)\)</span>, then the equation is the same as for <span class="math inline">\(y\)</span>. If <span class="math inline">\(t &gt; v_x(0)\)</span> then</p>
<p><span class="math display">\[x(t) = v_x(0) (v_x(0) + 1) / 2,\]</span></p>
<p>So the equation can only be solved if <span class="math inline">\(x(t)\)</span> is a triangular number, and then,</p>
<p><span class="math display">\[v_x(0) = \lfloor \sqrt{2 x(t)} \rfloor.\]</span></p>
<p>We can plot the resulting boxes for each time <span class="math inline">\(t\)</span>.</p>
<div class="named-code-block">
<p>«solution-day17»</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="ot">invertArea ::</span> <span class="dt">Area</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Area</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>invertArea <span class="dt">Area</span>{<span class="op">..</span>} t <span class="ot">=</span> <span class="dt">Area</span> minX&#39; maxX&#39; minY&#39; maxY&#39;</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> invertDelta x <span class="ot">=</span> <span class="fu">floor</span> (<span class="fu">sqrt</span> (<span class="fu">fromIntegral</span> <span class="op">$</span> <span class="dv">2</span> <span class="op">*</span> x))</span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a><span class="ot">          invertQuadratic ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Float</span></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>          invertQuadratic x <span class="ot">=</span> <span class="fu">fromIntegral</span> x <span class="op">/</span> <span class="fu">fromIntegral</span> t </span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a>                            <span class="op">+</span> (<span class="fu">fromIntegral</span> t <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a>          minX&#39; <span class="ot">=</span> <span class="fu">max</span> (invertDelta minX) (<span class="fu">ceiling</span> <span class="op">$</span> invertQuadratic minX)</span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a>          maxX&#39; <span class="ot">=</span> <span class="fu">floor</span> (invertQuadratic maxX)</span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true" tabindex="-1"></a>          minY&#39; <span class="ot">=</span> <span class="fu">ceiling</span> (invertQuadratic minY)</span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true" tabindex="-1"></a>          maxY&#39; <span class="ot">=</span> <span class="fu">floor</span> (invertQuadratic maxY)</span>
<span id="cb134-11"><a href="#cb134-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-12"><a href="#cb134-12" aria-hidden="true" tabindex="-1"></a><span class="ot">printArea ::</span> <span class="dt">Area</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb134-13"><a href="#cb134-13" aria-hidden="true" tabindex="-1"></a>printArea <span class="dt">Area</span>{<span class="op">..</span>} <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb134-14"><a href="#cb134-14" aria-hidden="true" tabindex="-1"></a>    printLn <span class="op">$</span> tshow minX <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> tshow minY</span>
<span id="cb134-15"><a href="#cb134-15" aria-hidden="true" tabindex="-1"></a>    printLn <span class="op">$</span> tshow maxX <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> tshow minY</span>
<span id="cb134-16"><a href="#cb134-16" aria-hidden="true" tabindex="-1"></a>    printLn <span class="op">$</span> tshow maxX <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> tshow maxY</span>
<span id="cb134-17"><a href="#cb134-17" aria-hidden="true" tabindex="-1"></a>    printLn <span class="op">$</span> tshow minX <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> tshow maxY</span>
<span id="cb134-18"><a href="#cb134-18" aria-hidden="true" tabindex="-1"></a>    printLn <span class="op">$</span> tshow minX <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> tshow minY</span>
<span id="cb134-19"><a href="#cb134-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-20"><a href="#cb134-20" aria-hidden="true" tabindex="-1"></a><span class="ot">showData2 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb134-21"><a href="#cb134-21" aria-hidden="true" tabindex="-1"></a>showData2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb134-22"><a href="#cb134-22" aria-hidden="true" tabindex="-1"></a>    area <span class="ot">&lt;-</span> runSimpleApp readInput</span>
<span id="cb134-23"><a href="#cb134-23" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mapM_</span> (\t <span class="ot">-&gt;</span> printArea (invertArea area t) <span class="op">&gt;&gt;</span> printLn <span class="st">&quot;\n&quot;</span>)</span>
<span id="cb134-24"><a href="#cb134-24" aria-hidden="true" tabindex="-1"></a>          [<span class="dv">0</span> <span class="op">..</span> <span class="dv">2</span> <span class="op">*</span> <span class="fu">negate</span> (minY area)]</span></code></pre></div>
</div>
</section>
<section id="day-18-snailfish" class="level1">
<h1>Day 18: Snailfish</h1>
<p>Today we’re walking trees. I spent most of my time reading the instructions. My solution is based on clever (if I can say so myself) combination of <code>Alternative</code> and continuation passing style.</p>
<div class="named-code-block">
<p>file:app/Day18.hs</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day18</span> <span class="kw">where</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List.Partial</span> (foldl1&#39;, maximum)</span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> (<span class="dt">Parser</span>, readInputParsing, char, integer, eol, sepEndBy1)</span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-7"><a href="#cb135-7" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day18<span class="op">&gt;&gt;</span></span>
<span id="cb135-8"><a href="#cb135-8" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day18<span class="op">&gt;&gt;</span></span>
<span id="cb135-9"><a href="#cb135-9" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>We have snailfish “numbers” that are represented by pairs of snailfish “numbers”.</p>
<div class="named-code-block">
<p>«parser-day18»</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Number</span> a</span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">Regular</span> a</span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Snailfish</span> (<span class="dt">Number</span> a) (<span class="dt">Number</span> a)</span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Eq</span>)</span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Number</span> a) <span class="kw">where</span></span>
<span id="cb136-7"><a href="#cb136-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">show</span> (<span class="dt">Regular</span> a) <span class="ot">=</span> <span class="fu">show</span> a</span>
<span id="cb136-8"><a href="#cb136-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">show</span> (<span class="dt">Snailfish</span> a b) <span class="ot">=</span> <span class="st">&quot;[&quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> a <span class="op">&lt;&gt;</span> <span class="st">&quot;,&quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> b <span class="op">&lt;&gt;</span> <span class="st">&quot;]&quot;</span></span>
<span id="cb136-9"><a href="#cb136-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-10"><a href="#cb136-10" aria-hidden="true" tabindex="-1"></a><span class="ot">snailfishP ::</span> <span class="dt">Parser</span> (<span class="dt">Number</span> <span class="dt">Int</span>)</span>
<span id="cb136-11"><a href="#cb136-11" aria-hidden="true" tabindex="-1"></a>snailfishP <span class="ot">=</span> <span class="dt">Snailfish</span> <span class="op">&lt;$</span> char <span class="ch">&#39;[&#39;</span> <span class="op">&lt;*&gt;</span> exprP <span class="op">&lt;*</span> char <span class="ch">&#39;,&#39;</span> <span class="op">&lt;*&gt;</span> exprP <span class="op">&lt;*</span> char <span class="ch">&#39;]&#39;</span></span>
<span id="cb136-12"><a href="#cb136-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-13"><a href="#cb136-13" aria-hidden="true" tabindex="-1"></a><span class="ot">exprP ::</span> <span class="dt">Parser</span> (<span class="dt">Number</span> <span class="dt">Int</span>)</span>
<span id="cb136-14"><a href="#cb136-14" aria-hidden="true" tabindex="-1"></a>exprP <span class="ot">=</span> (<span class="dt">Regular</span> <span class="op">&lt;$&gt;</span> integer) <span class="op">&lt;|&gt;</span> snailfishP</span>
<span id="cb136-15"><a href="#cb136-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-16"><a href="#cb136-16" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env [<span class="dt">Number</span> <span class="dt">Int</span>]</span>
<span id="cb136-17"><a href="#cb136-17" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day18.txt&quot;</span> (snailfishP <span class="ot">`sepEndBy1`</span> eol)</span></code></pre></div>
</div>
<p>We are told that numbers are added by creating a new pair and then reducing.</p>
<div class="named-code-block">
<p>«solution-day18»</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> (<span class="dt">Number</span> <span class="dt">Int</span>) <span class="kw">where</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Regular</span> <span class="dv">0</span> <span class="op">&lt;&gt;</span> b <span class="ot">=</span> b</span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>    a <span class="op">&lt;&gt;</span> <span class="dt">Regular</span> <span class="dv">0</span> <span class="ot">=</span> a</span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>    a <span class="op">&lt;&gt;</span> b <span class="ot">=</span> reduce <span class="op">$</span> <span class="dt">Snailfish</span> a b</span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Number</span> <span class="dt">Int</span>) <span class="kw">where</span></span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Regular</span> <span class="dv">0</span></span></code></pre></div>
</div>
<p>To reduce a number, we either explode or split. It took me a long time to understand that we don’t split unless there’s nothing to explode.</p>
<div class="named-code-block">
<p>«solution-day18»</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="ot">reduce ::</span> <span class="dt">Number</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="dt">Int</span></span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>reduce a <span class="ot">=</span> <span class="fu">maybe</span> a reduce (reduceExplode a <span class="op">&lt;|&gt;</span> reduceSplit a)</span></code></pre></div>
</div>
<p>The idea of <code>Alternative Maybe</code> and CPS is best explained on <code>reduceSplit</code>. Once we found a number to split, we should stop scanning for other numbers to split. This means we have to represent upper levels of the tree in terms of what happens somewhere down in the walk. Instead of waiting for a function to return, I pass it a continuation (think a template) that we may use <strong>if and only if</strong> we want to change something in the tree. The continuation should be a function that, when given a node, reconstructs the entire tree.</p>
<p>Calling the continuation will result in a <code>Just</code> that already contains the entire tree. If the continuation is not called, the result is a <code>Nothing</code>, telling the <code>Alternative</code> class that we’re not done yet.</p>
<div class="named-code-block">
<p>«solution-day18»</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="ot">reduceSplit ::</span> <span class="dt">Number</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Number</span> <span class="dt">Int</span>)</span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a>reduceSplit <span class="ot">=</span> walk <span class="dt">Just</span></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> walk cc (<span class="dt">Snailfish</span> a b)</span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a>          <span class="ot">=</span>   walk (\n <span class="ot">-&gt;</span> cc <span class="op">$</span> <span class="dt">Snailfish</span> n b) a</span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a>          <span class="op">&lt;|&gt;</span> walk (\n <span class="ot">-&gt;</span> cc <span class="op">$</span> <span class="dt">Snailfish</span> a n) b</span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a>        walk cc (<span class="dt">Regular</span> x)</span>
<span id="cb139-7"><a href="#cb139-7" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> x <span class="op">&gt;=</span> <span class="dv">10</span>    <span class="ot">=</span> cc <span class="op">$</span> split x</span>
<span id="cb139-8"><a href="#cb139-8" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="fu">otherwise</span>  <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb139-9"><a href="#cb139-9" aria-hidden="true" tabindex="-1"></a>          <span class="kw">where</span> split x <span class="ot">=</span> <span class="dt">Snailfish</span> (<span class="dt">Regular</span> <span class="op">$</span> <span class="fu">floor</span> (<span class="fu">fromIntegral</span> x <span class="op">/</span> <span class="dv">2</span>))</span>
<span id="cb139-10"><a href="#cb139-10" aria-hidden="true" tabindex="-1"></a>                                    (<span class="dt">Regular</span> <span class="op">$</span> <span class="fu">ceiling</span> (<span class="fu">fromIntegral</span> x <span class="op">/</span> <span class="dv">2</span>))</span></code></pre></div>
</div>
<p>The same principle applies on the <code>reduceExplode</code> function. However, now it is more complicated. Next to replacing the current node with <code>Regular 0</code>, we need to add numbers to the left and right. If a sub-tree is unmodified, we may decide to add <code>0</code> after all.</p>
<div class="named-code-block">
<p>«solution-day18»</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="ot">reduceExplode ::</span> <span class="dt">Number</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Number</span> <span class="dt">Int</span>)</span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a>reduceExplode <span class="ot">=</span> walk <span class="dv">0</span> (\_ x _  <span class="ot">-&gt;</span> <span class="dt">Just</span> x)</span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> walk <span class="dv">4</span> explode (<span class="dt">Snailfish</span> (<span class="dt">Regular</span> a) (<span class="dt">Regular</span> b))</span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a>            <span class="ot">=</span> explode a (<span class="dt">Regular</span> <span class="dv">0</span>) b</span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>        walk depth explode (<span class="dt">Snailfish</span> a b)</span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a>            <span class="ot">=</span>   walk (depth<span class="op">+</span><span class="dv">1</span>) explodeLeft a</span>
<span id="cb140-7"><a href="#cb140-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">&lt;|&gt;</span> walk (depth<span class="op">+</span><span class="dv">1</span>) explodeRight b</span>
<span id="cb140-8"><a href="#cb140-8" aria-hidden="true" tabindex="-1"></a>            <span class="kw">where</span> explodeLeft x n y <span class="ot">=</span> </span>
<span id="cb140-9"><a href="#cb140-9" aria-hidden="true" tabindex="-1"></a>                    explode x (<span class="dt">Snailfish</span> n (addToLeftMost b y)) <span class="dv">0</span></span>
<span id="cb140-10"><a href="#cb140-10" aria-hidden="true" tabindex="-1"></a>                  explodeRight x n y <span class="ot">=</span></span>
<span id="cb140-11"><a href="#cb140-11" aria-hidden="true" tabindex="-1"></a>                    explode <span class="dv">0</span> (<span class="dt">Snailfish</span> (addToRightMost a x) n) y</span>
<span id="cb140-12"><a href="#cb140-12" aria-hidden="true" tabindex="-1"></a>        walk _ _ (<span class="dt">Regular</span> _) <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
</div>
<p>The <code>addToLeftMost</code> and <code>addToRightMost</code> functions to a normal recursive decent, optimising for the common case of adding <code>0</code>.</p>
<div class="named-code-block">
<p>«solution-day18»</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addToLeftMost ::</span> <span class="dt">Number</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="dt">Int</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>addToLeftMost a <span class="dv">0</span> <span class="ot">=</span> a</span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>addToLeftMost a x <span class="ot">=</span> go a</span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go (<span class="dt">Snailfish</span> a b) <span class="ot">=</span> <span class="dt">Snailfish</span> (go a) b</span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>          go (<span class="dt">Regular</span> y) <span class="ot">=</span> <span class="dt">Regular</span> (x <span class="op">+</span> y)</span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a><span class="ot">addToRightMost ::</span> <span class="dt">Number</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="dt">Int</span></span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a>addToRightMost a <span class="dv">0</span> <span class="ot">=</span> a</span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true" tabindex="-1"></a>addToRightMost a x <span class="ot">=</span> go a</span>
<span id="cb141-10"><a href="#cb141-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go (<span class="dt">Snailfish</span> a b) <span class="ot">=</span> <span class="dt">Snailfish</span> a (go b)</span>
<span id="cb141-11"><a href="#cb141-11" aria-hidden="true" tabindex="-1"></a>          go (<span class="dt">Regular</span> y) <span class="ot">=</span> <span class="dt">Regular</span> (x <span class="op">+</span> y)</span></code></pre></div>
</div>
<p>With all that in place, the rest of the exercise is not too hard.</p>
<div class="named-code-block">
<p>«solution-day18»</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="ot">magnitude ::</span> <span class="dt">Number</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>magnitude (<span class="dt">Regular</span> x) <span class="ot">=</span> x</span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>magnitude (<span class="dt">Snailfish</span> a b) <span class="ot">=</span> magnitude a <span class="op">*</span> <span class="dv">3</span> <span class="op">+</span> magnitude b <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> [<span class="dt">Number</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb142-6"><a href="#cb142-6" aria-hidden="true" tabindex="-1"></a>solutionA <span class="ot">=</span> magnitude <span class="op">.</span> fold</span>
<span id="cb142-7"><a href="#cb142-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-8"><a href="#cb142-8" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> [<span class="dt">Number</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb142-9"><a href="#cb142-9" aria-hidden="true" tabindex="-1"></a>solutionB inp <span class="ot">=</span> <span class="fu">maximum</span> [ magnitude (a <span class="op">&lt;&gt;</span> b)</span>
<span id="cb142-10"><a href="#cb142-10" aria-hidden="true" tabindex="-1"></a>                        <span class="op">|</span> a <span class="ot">&lt;-</span> inp, b <span class="ot">&lt;-</span> inp, a <span class="op">/=</span> b]</span></code></pre></div>
</div>
</section>
<section id="day-19-beacon-scanner" class="level1">
<h1>Day 19: Beacon Scanner</h1>
<p>Boy, this was a hard one.</p>
<div class="named-code-block">
<p>file:app/Day19.hs</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day19</span> <span class="kw">where</span></span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span> <span class="kw">hiding</span> (try)</span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (sortBy, find, sort, headMaybe)</span>
<span id="cb143-5"><a href="#cb143-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List.Partial</span> (head, last, maximum)</span>
<span id="cb143-6"><a href="#cb143-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb143-7"><a href="#cb143-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb143-8"><a href="#cb143-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Lazy</span> <span class="kw">as</span> <span class="dt">LazyMap</span></span>
<span id="cb143-9"><a href="#cb143-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Vector</span> (<span class="dt">Vector</span>)</span>
<span id="cb143-10"><a href="#cb143-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">Vector</span></span>
<span id="cb143-11"><a href="#cb143-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-12"><a href="#cb143-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> (<span class="dt">Parser</span>, readInputParsing, string, integer, char, eol, sepEndBy1, dropUntilEol)</span>
<span id="cb143-13"><a href="#cb143-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> (try)</span>
<span id="cb143-14"><a href="#cb143-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-15"><a href="#cb143-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Linear.Matrix</span> ( <span class="dt">M33</span>, (!*), (!!*), (!*!), transpose, det33 )</span>
<span id="cb143-16"><a href="#cb143-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Linear.V3</span> ( <span class="dt">V3</span>(..), _x, _y, _z )</span>
<span id="cb143-17"><a href="#cb143-17" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Linear.Vector</span> ( negated )</span>
<span id="cb143-18"><a href="#cb143-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-19"><a href="#cb143-19" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="kw">data</span><span class="op">-</span>types<span class="op">-</span>day19<span class="op">&gt;&gt;</span></span>
<span id="cb143-20"><a href="#cb143-20" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day19<span class="op">&gt;&gt;</span></span>
<span id="cb143-21"><a href="#cb143-21" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day19<span class="op">&gt;&gt;</span></span>
<span id="cb143-22"><a href="#cb143-22" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>For this problem I use the <code>Linear</code> module quite a lot: <code>V3 Int</code> for coordinates, <code>V3 (V3 Int)</code> for rotating and reflecting the coordinates. I defined my own <code>Affine</code> type here, I know <code>Linear</code> also has one, but this kind of grew and I don’t know if it is used in a similar way. The <code>Affine</code> type combines a coordinate transformation and an offset. I implemented <code>Monoid</code> to get the <code>&lt;&gt;</code> operator to combine <code>Affine</code> transformations.</p>
<div class="named-code-block">
<p>«data-types-day19»</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Pt</span> <span class="ot">=</span> <span class="dt">V3</span> <span class="dt">Int</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Scan</span> <span class="ot">=</span> [<span class="dt">Pt</span>]</span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Transform</span> <span class="ot">=</span> <span class="dt">M33</span> <span class="dt">Int</span></span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Affine</span> <span class="ot">=</span> <span class="dt">Affine</span> <span class="dt">Transform</span> <span class="dt">Pt</span></span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-8"><a href="#cb144-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">Affine</span> <span class="kw">where</span></span>
<span id="cb144-9"><a href="#cb144-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Affine</span> t p <span class="op">&lt;&gt;</span> <span class="dt">Affine</span> u q <span class="ot">=</span> <span class="dt">Affine</span> (t <span class="op">!*!</span> u) (t <span class="op">!*</span> q <span class="op">+</span> p)</span>
<span id="cb144-10"><a href="#cb144-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-11"><a href="#cb144-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Affine</span> <span class="kw">where</span></span>
<span id="cb144-12"><a href="#cb144-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Affine</span> (<span class="dt">V3</span> (<span class="dt">V3</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">0</span>) (<span class="dt">V3</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">0</span>) (<span class="dt">V3</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">1</span>))</span>
<span id="cb144-13"><a href="#cb144-13" aria-hidden="true" tabindex="-1"></a>                    (<span class="dt">V3</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span>)</span>
<span id="cb144-14"><a href="#cb144-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-15"><a href="#cb144-15" aria-hidden="true" tabindex="-1"></a><span class="ot">invert ::</span> <span class="dt">Affine</span> <span class="ot">-&gt;</span> <span class="dt">Affine</span></span>
<span id="cb144-16"><a href="#cb144-16" aria-hidden="true" tabindex="-1"></a>invert (<span class="dt">Affine</span> t p) <span class="ot">=</span> <span class="dt">Affine</span> (transpose t) (negated p)</span>
<span id="cb144-17"><a href="#cb144-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-18"><a href="#cb144-18" aria-hidden="true" tabindex="-1"></a><span class="ot">applyAffine ::</span> <span class="dt">Affine</span> <span class="ot">-&gt;</span> <span class="dt">Pt</span> <span class="ot">-&gt;</span> <span class="dt">Pt</span></span>
<span id="cb144-19"><a href="#cb144-19" aria-hidden="true" tabindex="-1"></a>applyAffine (<span class="dt">Affine</span> t p) q <span class="ot">=</span> t <span class="op">!*</span> q <span class="op">+</span> p</span></code></pre></div>
</div>
<div class="named-code-block">
<p>«parser-day19»</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="ot">inputP ::</span> <span class="dt">Parser</span> <span class="dt">Scan</span></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a>inputP <span class="ot">=</span> string <span class="st">&quot;---&quot;</span> <span class="op">&gt;&gt;</span> dropUntilEol</span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a>       <span class="op">&gt;&gt;</span> (<span class="dt">V3</span> <span class="op">&lt;$&gt;</span> integer <span class="op">&lt;*</span> char <span class="ch">&#39;,&#39;</span> <span class="op">&lt;*&gt;</span> integer <span class="op">&lt;*</span> char <span class="ch">&#39;,&#39;</span> <span class="op">&lt;*&gt;</span> integer) <span class="ot">`sepEndBy1`</span> eol</span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env (<span class="dt">Vector</span> <span class="dt">Scan</span>)</span>
<span id="cb145-6"><a href="#cb145-6" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day19.txt&quot;</span> (Vector.fromList <span class="op">&lt;$&gt;</span> inputP <span class="ot">`sepEndBy1`</span> eol)</span></code></pre></div>
</div>
<p>To find if two scans have matching points, I try all transpositions and reflections of coordinates. This may not be the most compact way of writing these down, but it works. At first I didn’t read well enough and did too many transformations. I fixed it by filtering on ones that have determinant of one.</p>
<div class="named-code-block">
<p>«solution-day19»</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="ot">allTransforms ::</span> [<span class="dt">Transform</span>]</span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>allTransforms <span class="ot">=</span> [ p <span class="op">*</span> s <span class="op">|</span> p <span class="ot">&lt;-</span> permutations (<span class="dt">V3</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">0</span>) (<span class="dt">V3</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">0</span>) (<span class="dt">V3</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">1</span>)</span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>                        , s <span class="ot">&lt;-</span> signatures</span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>                        , det33 (p <span class="op">*</span> s) <span class="op">==</span> <span class="dv">1</span> ]</span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true" tabindex="-1"></a>          permutations a b c <span class="ot">=</span> [ <span class="dt">V3</span> a b c, <span class="dt">V3</span> a c b, <span class="dt">V3</span> b a c</span>
<span id="cb146-7"><a href="#cb146-7" aria-hidden="true" tabindex="-1"></a>                               , <span class="dt">V3</span> b c a, <span class="dt">V3</span> c a b, <span class="dt">V3</span> c b a ]</span>
<span id="cb146-8"><a href="#cb146-8" aria-hidden="true" tabindex="-1"></a>          signatures <span class="ot">=</span> [ <span class="dt">V3</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>,       <span class="dt">V3</span> <span class="dv">1</span> <span class="dv">1</span> (<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb146-9"><a href="#cb146-9" aria-hidden="true" tabindex="-1"></a>                       , <span class="dt">V3</span> <span class="dv">1</span> (<span class="op">-</span><span class="dv">1</span>) <span class="dv">1</span>,    <span class="dt">V3</span> <span class="dv">1</span> (<span class="op">-</span><span class="dv">1</span>) (<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb146-10"><a href="#cb146-10" aria-hidden="true" tabindex="-1"></a>                       , <span class="dt">V3</span> (<span class="op">-</span><span class="dv">1</span>) <span class="dv">1</span> <span class="dv">1</span>,    <span class="dt">V3</span> (<span class="op">-</span><span class="dv">1</span>) <span class="dv">1</span> (<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb146-11"><a href="#cb146-11" aria-hidden="true" tabindex="-1"></a>                       , <span class="dt">V3</span> (<span class="op">-</span><span class="dv">1</span>) (<span class="op">-</span><span class="dv">1</span>) <span class="dv">1</span>, <span class="dt">V3</span> (<span class="op">-</span><span class="dv">1</span>) (<span class="op">-</span><span class="dv">1</span>) (<span class="op">-</span><span class="dv">1</span>) ]</span></code></pre></div>
</div>
<p>At first, I had a terribly complicated method here to detect the relative offsets of two scans. I happened across a solution by someone else that is much more elegant.</p>
<div class="named-code-block">
<p>«solution-day19»</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="ot">matchScans ::</span> [<span class="dt">Pt</span>] <span class="ot">-&gt;</span> [<span class="dt">Pt</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Pt</span></span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>matchScans a b <span class="ot">=</span> headMaybe <span class="op">$</span> Map.keys <span class="op">$</span> Map.filter (<span class="op">&gt;=</span> <span class="dv">12</span>) <span class="op">$</span> count diffs</span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> diffs <span class="ot">=</span> (<span class="op">-</span>) <span class="op">&lt;$&gt;</span> a <span class="op">&lt;*&gt;</span> b</span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>          count <span class="ot">=</span> Map.fromListWith (<span class="op">+</span>) <span class="op">.</span> <span class="fu">map</span> (,<span class="dv">1</span>)</span></code></pre></div>
</div>
<p>We still have to try this for every rotation and reflection of one of the scans.</p>
<div class="named-code-block">
<p>«solution-day19»</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="ot">match ::</span> [<span class="dt">Pt</span>] <span class="ot">-&gt;</span> [<span class="dt">Pt</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Affine</span></span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a>match a b <span class="ot">=</span> asum (go <span class="op">&lt;$&gt;</span> allTransforms)</span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go t <span class="ot">=</span> <span class="dt">Affine</span> t <span class="op">&lt;$&gt;</span> matchScans a (<span class="fu">map</span> (t <span class="op">!*</span>) b)</span></code></pre></div>
</div>
<p>I build an index of <code>Affine</code> transformations. Starting with scan 0, I find the first remaining scan that produces a match, add that to the map and repeat. This could be sped up by memoizing matches we already know to fail; for me this gives a factor 60 speedup.</p>
<div class="named-code-block">
<p>«solution-day19»</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="ot">memoizeMatch ::</span> <span class="dt">Vector</span> <span class="dt">Scan</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Affine</span></span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a>memoizeMatch s <span class="ot">=</span> <span class="fu">lookup</span></span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> <span class="fu">lookup</span> i j <span class="ot">=</span> join <span class="op">$</span> LazyMap.lookup (i, j) cache</span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true" tabindex="-1"></a>          cache <span class="ot">=</span> LazyMap.fromList [ ((i, j), match (s <span class="op">Vector.!</span> i) (s <span class="op">Vector.!</span> j))</span>
<span id="cb149-5"><a href="#cb149-5" aria-hidden="true" tabindex="-1"></a>                                   <span class="op">|</span> i <span class="ot">&lt;-</span> [<span class="dv">0</span> <span class="op">..</span> Vector.length s <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb149-6"><a href="#cb149-6" aria-hidden="true" tabindex="-1"></a>                                   , j <span class="ot">&lt;-</span> [<span class="dv">0</span> <span class="op">..</span> Vector.length s <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb149-7"><a href="#cb149-7" aria-hidden="true" tabindex="-1"></a>                                   , i <span class="op">/=</span> j ]</span>
<span id="cb149-8"><a href="#cb149-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-9"><a href="#cb149-9" aria-hidden="true" tabindex="-1"></a><span class="ot">buildMap ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Affine</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Map</span> <span class="dt">Int</span> <span class="dt">Affine</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Map</span> <span class="dt">Int</span> <span class="dt">Affine</span>)</span>
<span id="cb149-10"><a href="#cb149-10" aria-hidden="true" tabindex="-1"></a>buildMap f n m</span>
<span id="cb149-11"><a href="#cb149-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> Map.size m <span class="op">==</span> n <span class="ot">=</span> <span class="dt">Just</span> m</span>
<span id="cb149-12"><a href="#cb149-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> asum matches <span class="op">&gt;&gt;=</span> insert <span class="op">&gt;&gt;=</span> buildMap f n</span>
<span id="cb149-13"><a href="#cb149-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> insert (i, j, aff) <span class="ot">=</span> <span class="kw">do</span> { a <span class="ot">&lt;-</span> m <span class="op">Map.!?</span> i;</span>
<span id="cb149-14"><a href="#cb149-14" aria-hidden="true" tabindex="-1"></a>                                    <span class="fu">return</span> <span class="op">$</span> Map.insert j (a <span class="op">&lt;&gt;</span> aff) m }</span>
<span id="cb149-15"><a href="#cb149-15" aria-hidden="true" tabindex="-1"></a>          matches <span class="ot">=</span> [ (i, j,) <span class="op">&lt;$&gt;</span> f i j</span>
<span id="cb149-16"><a href="#cb149-16" aria-hidden="true" tabindex="-1"></a>                    <span class="op">|</span> i <span class="ot">&lt;-</span> Map.keys m</span>
<span id="cb149-17"><a href="#cb149-17" aria-hidden="true" tabindex="-1"></a>                    , j <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="op">..</span>(n <span class="op">-</span> <span class="dv">1</span>)]</span>
<span id="cb149-18"><a href="#cb149-18" aria-hidden="true" tabindex="-1"></a>                    , j <span class="ot">`Map.notMember`</span> m ]</span></code></pre></div>
</div>
<p>That was the hard bit. This code runs in about 15 seconds on my laptop.</p>
<div class="named-code-block">
<p>«solution-day19»</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mergeScans ::</span> <span class="dt">Vector</span> <span class="dt">Scan</span> <span class="ot">-&gt;</span> <span class="dt">Map</span> <span class="dt">Int</span> <span class="dt">Affine</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">Pt</span></span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a>mergeScans s <span class="ot">=</span> Map.foldMapWithKey (\i a <span class="ot">-&gt;</span> Set.fromList <span class="op">$</span> <span class="fu">map</span> (applyAffine a) (s <span class="op">Vector.!</span> i))</span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> <span class="dt">Vector</span> <span class="dt">Scan</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb150-5"><a href="#cb150-5" aria-hidden="true" tabindex="-1"></a>solutionA inp <span class="ot">=</span> Set.size <span class="op">.</span> mergeScans inp</span>
<span id="cb150-6"><a href="#cb150-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">&lt;$&gt;</span> buildMap (memoizeMatch inp) (Vector.length inp)</span>
<span id="cb150-7"><a href="#cb150-7" aria-hidden="true" tabindex="-1"></a>                         (Map.singleton <span class="dv">0</span> <span class="fu">mempty</span>)</span>
<span id="cb150-8"><a href="#cb150-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-9"><a href="#cb150-9" aria-hidden="true" tabindex="-1"></a><span class="ot">maxDist ::</span> <span class="dt">Map</span> <span class="dt">Int</span> <span class="dt">Affine</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb150-10"><a href="#cb150-10" aria-hidden="true" tabindex="-1"></a>maxDist m <span class="ot">=</span> <span class="fu">maximum</span> [dist a b <span class="op">|</span> a <span class="ot">&lt;-</span> Map.elems m, b <span class="ot">&lt;-</span> Map.elems m]</span>
<span id="cb150-11"><a href="#cb150-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> dist (<span class="dt">Affine</span> _ a) (<span class="dt">Affine</span> _ b) <span class="ot">=</span> <span class="fu">sum</span> (<span class="fu">abs</span> (a <span class="op">-</span> b))</span>
<span id="cb150-12"><a href="#cb150-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-13"><a href="#cb150-13" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> <span class="dt">Vector</span> <span class="dt">Scan</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb150-14"><a href="#cb150-14" aria-hidden="true" tabindex="-1"></a>solutionB inp <span class="ot">=</span> maxDist</span>
<span id="cb150-15"><a href="#cb150-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">&lt;$&gt;</span> buildMap (memoizeMatch inp) (Vector.length inp)</span>
<span id="cb150-16"><a href="#cb150-16" aria-hidden="true" tabindex="-1"></a>                         (Map.singleton <span class="dv">0</span> <span class="fu">mempty</span>)</span></code></pre></div>
</div>
</section>
<section id="day-20-trench-map" class="level1">
<h1>Day 20: Trench Map</h1>
<p>It’s game of life time!</p>
<div class="named-code-block">
<p>file:app/Day20.hs</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day20</span> <span class="kw">where</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (iterate)</span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List.Partial</span> ((!!))</span>
<span id="cb151-6"><a href="#cb151-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Massiv.Array</span> (<span class="dt">Ix1</span>, <span class="dt">Ix2</span>(..), <span class="dt">U</span>, <span class="dt">Sz</span>(..))</span>
<span id="cb151-7"><a href="#cb151-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Massiv.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb151-8"><a href="#cb151-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-9"><a href="#cb151-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> (<span class="dt">Parser</span>, readInputParsing, char, failOnException, sepEndBy1, eol)</span>
<span id="cb151-10"><a href="#cb151-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-11"><a href="#cb151-11" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day20<span class="op">&gt;&gt;</span></span>
<span id="cb151-12"><a href="#cb151-12" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day20<span class="op">&gt;&gt;</span></span>
<span id="cb151-13"><a href="#cb151-13" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«parser-day20»</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Array1</span> a <span class="ot">=</span> <span class="dt">A.Array</span> <span class="dt">U</span> <span class="dt">Ix1</span> a</span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Array2</span> a <span class="ot">=</span> <span class="dt">A.Array</span> <span class="dt">U</span> <span class="dt">Ix2</span> a</span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Input</span> <span class="ot">=</span> (<span class="dt">Array1</span> <span class="dt">Int</span>, <span class="dt">Array2</span> <span class="dt">Int</span>)</span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-5"><a href="#cb152-5" aria-hidden="true" tabindex="-1"></a><span class="ot">lineP ::</span> <span class="dt">Parser</span> [<span class="dt">Int</span>]</span>
<span id="cb152-6"><a href="#cb152-6" aria-hidden="true" tabindex="-1"></a>lineP <span class="ot">=</span> some ((char <span class="ch">&#39;.&#39;</span> <span class="op">$&gt;</span> <span class="dv">0</span>) <span class="op">&lt;|&gt;</span> (char <span class="ch">&#39;#&#39;</span> <span class="op">$&gt;</span> <span class="dv">1</span>))</span>
<span id="cb152-7"><a href="#cb152-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-8"><a href="#cb152-8" aria-hidden="true" tabindex="-1"></a><span class="ot">rulesP ::</span> <span class="dt">Parser</span> (<span class="dt">Array1</span> <span class="dt">Int</span>)</span>
<span id="cb152-9"><a href="#cb152-9" aria-hidden="true" tabindex="-1"></a>rulesP <span class="ot">=</span> A.fromList <span class="dt">A.Seq</span> <span class="op">.</span> join <span class="op">&lt;$&gt;</span> (lineP <span class="ot">`sepEndBy1`</span> eol)</span>
<span id="cb152-10"><a href="#cb152-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-11"><a href="#cb152-11" aria-hidden="true" tabindex="-1"></a><span class="ot">gridP ::</span> <span class="dt">Parser</span> (<span class="dt">Array2</span> <span class="dt">Int</span>)</span>
<span id="cb152-12"><a href="#cb152-12" aria-hidden="true" tabindex="-1"></a>gridP <span class="ot">=</span> failOnException <span class="op">.</span> A.fromListsM <span class="dt">A.Seq</span> <span class="op">=&lt;&lt;</span> (lineP <span class="ot">`sepEndBy1`</span> eol)</span>
<span id="cb152-13"><a href="#cb152-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-14"><a href="#cb152-14" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env <span class="dt">Input</span></span>
<span id="cb152-15"><a href="#cb152-15" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day20.txt&quot;</span></span>
<span id="cb152-16"><a href="#cb152-16" aria-hidden="true" tabindex="-1"></a>            ((,) <span class="op">&lt;$&gt;</span> rulesP <span class="op">&lt;*</span> eol <span class="op">&lt;*&gt;</span> gridP)</span></code></pre></div>
</div>
<p>Little comment needed. Take care with the value at infinity!</p>
<div class="named-code-block">
<p>«solution-day20»</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="ot">patch ::</span> [<span class="dt">Ix2</span>]</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a>patch <span class="ot">=</span> [i <span class="op">:.</span> j <span class="op">|</span> i <span class="ot">&lt;-</span> [(<span class="op">-</span><span class="dv">1</span>)<span class="op">..</span><span class="dv">1</span>], j <span class="ot">&lt;-</span> [(<span class="op">-</span><span class="dv">1</span>)<span class="op">..</span><span class="dv">1</span>]]</span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a><span class="ot">fromBinary ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a>fromBinary <span class="ot">=</span> go <span class="dv">0</span></span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go n (b<span class="op">:</span>bs) <span class="ot">=</span> go (<span class="dv">2</span><span class="op">*</span>n <span class="op">+</span> b) bs</span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a>          go n []     <span class="ot">=</span> n</span>
<span id="cb153-8"><a href="#cb153-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-9"><a href="#cb153-9" aria-hidden="true" tabindex="-1"></a><span class="ot">ruleStencil ::</span> <span class="dt">Array1</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">A.Stencil</span> <span class="dt">Ix2</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb153-10"><a href="#cb153-10" aria-hidden="true" tabindex="-1"></a>ruleStencil rules <span class="ot">=</span> A.makeStencil (<span class="dt">Sz</span> <span class="op">$</span> <span class="dv">3</span> <span class="op">:.</span> <span class="dv">3</span>) (<span class="dv">1</span> <span class="op">:.</span> <span class="dv">1</span>) go</span>
<span id="cb153-11"><a href="#cb153-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go get <span class="ot">=</span> rules <span class="op">A.!</span> idx</span>
<span id="cb153-12"><a href="#cb153-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">where</span> idx <span class="ot">=</span> fromBinary (<span class="fu">map</span> get patch)</span>
<span id="cb153-13"><a href="#cb153-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-14"><a href="#cb153-14" aria-hidden="true" tabindex="-1"></a><span class="ot">growBorder ::</span> <span class="dt">Array2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Array2</span> <span class="dt">Int</span></span>
<span id="cb153-15"><a href="#cb153-15" aria-hidden="true" tabindex="-1"></a>growBorder src inf <span class="ot">=</span> A.makeArrayR <span class="dt">A.U</span> <span class="dt">A.Seq</span> (A.liftSz (<span class="op">+</span> <span class="dv">2</span>) (A.size src))</span>
<span id="cb153-16"><a href="#cb153-16" aria-hidden="true" tabindex="-1"></a>                    (\ix <span class="ot">-&gt;</span> fromMaybe inf <span class="op">$</span> src <span class="op">A.!?</span> (ix <span class="op">-</span> (<span class="dv">1</span> <span class="op">:.</span> <span class="dv">1</span>)))</span>
<span id="cb153-17"><a href="#cb153-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-18"><a href="#cb153-18" aria-hidden="true" tabindex="-1"></a><span class="ot">step ::</span> <span class="dt">Array1</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Array2</span> <span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">Array2</span> <span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb153-19"><a href="#cb153-19" aria-hidden="true" tabindex="-1"></a>step rules (src, inf) <span class="ot">=</span> (tgt, inf&#39;)</span>
<span id="cb153-20"><a href="#cb153-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> tgt  <span class="ot">=</span> A.compute <span class="op">$</span> A.mapStencil (<span class="dt">A.Fill</span> inf) (ruleStencil rules) (growBorder src inf)</span>
<span id="cb153-21"><a href="#cb153-21" aria-hidden="true" tabindex="-1"></a>          inf&#39; <span class="ot">=</span> <span class="kw">if</span> inf <span class="op">==</span> <span class="dv">0</span> <span class="kw">then</span> rules <span class="op">A.!</span> <span class="dv">0</span> <span class="kw">else</span> rules <span class="op">A.!</span> <span class="dv">511</span></span>
<span id="cb153-22"><a href="#cb153-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-23"><a href="#cb153-23" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> <span class="dt">Input</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb153-24"><a href="#cb153-24" aria-hidden="true" tabindex="-1"></a>solutionA (rules, src) <span class="ot">=</span> A.sum <span class="op">$</span> <span class="fu">fst</span> <span class="op">$</span> step&#39; <span class="op">$</span> step&#39; (src, <span class="dv">0</span>)</span>
<span id="cb153-25"><a href="#cb153-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> step&#39; <span class="ot">=</span> step rules</span>
<span id="cb153-26"><a href="#cb153-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-27"><a href="#cb153-27" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> <span class="dt">Input</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb153-28"><a href="#cb153-28" aria-hidden="true" tabindex="-1"></a>solutionB (rules, src) <span class="ot">=</span> A.sum <span class="op">$</span> <span class="fu">fst</span> <span class="op">$</span> (<span class="op">!!</span> <span class="dv">50</span>) <span class="op">$</span> <span class="fu">iterate</span> (step rules) (src, <span class="dv">0</span>)</span></code></pre></div>
</div>
</section>
<section id="day-21-dirac-dice" class="level1">
<h1>Day 21: Dirac Dice</h1>
<p>I reused the <code>Tally</code> structure that I made on day 6, and extended it such that <code>Tally Int</code> supports numeric operations. This way I computed the answer using distributions of integers, and distributions of game states.</p>
<p>What I started with, was writing a monadic type class for playing the game. Considering that the game is independent for both players, I tried to solve this by simulation each player separately, but I got stuck in the bookkeeping. Then decided that keeping tally of numbers of game states was easier.</p>
<div class="named-code-block">
<p>file:app/Day21.hs</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day21</span> <span class="kw">where</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.List</span> (find, cycle, iterate, scanl&#39;)</span>
<span id="cb154-5"><a href="#cb154-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.State</span> (<span class="dt">MonadState</span>, <span class="dt">State</span>, get, gets, put, modify, execState)</span>
<span id="cb154-6"><a href="#cb154-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-7"><a href="#cb154-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span> (readInputParsing, string, integer, eol)</span>
<span id="cb154-8"><a href="#cb154-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Lens.Micro.Platform</span> ((&amp;), (&lt;%~), use, (%=), (.=), (&lt;%=), (&lt;&lt;%=))</span>
<span id="cb154-9"><a href="#cb154-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Tally</span></span>
<span id="cb154-10"><a href="#cb154-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Tally</span> (<span class="dt">Tally</span>)</span>
<span id="cb154-11"><a href="#cb154-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-12"><a href="#cb154-12" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Input</span> <span class="ot">=</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb154-13"><a href="#cb154-13" aria-hidden="true" tabindex="-1"></a>inputP <span class="ot">=</span> (,) <span class="op">&lt;$</span> string <span class="st">&quot;Player 1 starting position: &quot;</span> <span class="op">&lt;*&gt;</span> integer <span class="op">&lt;*</span> eol</span>
<span id="cb154-14"><a href="#cb154-14" aria-hidden="true" tabindex="-1"></a>             <span class="op">&lt;*</span> string <span class="st">&quot;Player 2 starting position: &quot;</span> <span class="op">&lt;*&gt;</span> integer <span class="op">&lt;*</span> eol</span>
<span id="cb154-15"><a href="#cb154-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-16"><a href="#cb154-16" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env <span class="dt">Input</span></span>
<span id="cb154-17"><a href="#cb154-17" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day21.txt&quot;</span> inputP</span>
<span id="cb154-18"><a href="#cb154-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-19"><a href="#cb154-19" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Player</span> <span class="ot">=</span> <span class="dt">Player1</span> <span class="op">|</span> <span class="dt">Player2</span></span>
<span id="cb154-20"><a href="#cb154-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span>
<span id="cb154-21"><a href="#cb154-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-22"><a href="#cb154-22" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Game</span> m <span class="kw">where</span></span>
<span id="cb154-23"><a href="#cb154-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Dist</span><span class="ot"> m ::</span> <span class="op">*</span></span>
<span id="cb154-24"><a href="#cb154-24" aria-hidden="true" tabindex="-1"></a><span class="ot">    roll ::</span> m (<span class="dt">Dist</span> m)</span>
<span id="cb154-25"><a href="#cb154-25" aria-hidden="true" tabindex="-1"></a><span class="ot">    move ::</span> <span class="dt">Player</span> <span class="ot">-&gt;</span> <span class="dt">Dist</span> m <span class="ot">-&gt;</span> m ()</span>
<span id="cb154-26"><a href="#cb154-26" aria-hidden="true" tabindex="-1"></a><span class="ot">    stop ::</span> m <span class="dt">Bool</span></span>
<span id="cb154-27"><a href="#cb154-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-28"><a href="#cb154-28" aria-hidden="true" tabindex="-1"></a><span class="ot">turn ::</span> (<span class="dt">Game</span> m, <span class="dt">Num</span> (<span class="dt">Dist</span> m)) <span class="ot">=&gt;</span> <span class="dt">Player</span> <span class="ot">-&gt;</span> m ()</span>
<span id="cb154-29"><a href="#cb154-29" aria-hidden="true" tabindex="-1"></a>turn p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb154-30"><a href="#cb154-30" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">&lt;-</span> roll</span>
<span id="cb154-31"><a href="#cb154-31" aria-hidden="true" tabindex="-1"></a>    b <span class="ot">&lt;-</span> roll</span>
<span id="cb154-32"><a href="#cb154-32" aria-hidden="true" tabindex="-1"></a>    c <span class="ot">&lt;-</span> roll</span>
<span id="cb154-33"><a href="#cb154-33" aria-hidden="true" tabindex="-1"></a>    move p (a <span class="op">+</span> b <span class="op">+</span> c)</span>
<span id="cb154-34"><a href="#cb154-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-35"><a href="#cb154-35" aria-hidden="true" tabindex="-1"></a><span class="ot">runUntilM ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m ()</span>
<span id="cb154-36"><a href="#cb154-36" aria-hidden="true" tabindex="-1"></a>runUntilM _ [] <span class="ot">=</span> <span class="fu">return</span> ()</span>
<span id="cb154-37"><a href="#cb154-37" aria-hidden="true" tabindex="-1"></a>runUntilM p (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb154-38"><a href="#cb154-38" aria-hidden="true" tabindex="-1"></a>    q <span class="ot">&lt;-</span> p x</span>
<span id="cb154-39"><a href="#cb154-39" aria-hidden="true" tabindex="-1"></a>    unless q (runUntilM p xs)</span>
<span id="cb154-40"><a href="#cb154-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-41"><a href="#cb154-41" aria-hidden="true" tabindex="-1"></a><span class="ot">play ::</span> (<span class="dt">Game</span> m, <span class="dt">Num</span> (<span class="dt">Dist</span> m)) <span class="ot">=&gt;</span> m ()</span>
<span id="cb154-42"><a href="#cb154-42" aria-hidden="true" tabindex="-1"></a>play <span class="ot">=</span> runUntilM (\x <span class="ot">-&gt;</span> turn x <span class="op">&gt;&gt;</span> stop) (<span class="fu">cycle</span> [<span class="dt">Player1</span>, <span class="dt">Player2</span>])</span>
<span id="cb154-43"><a href="#cb154-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-44"><a href="#cb154-44" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">PlayerData</span> <span class="ot">=</span> <span class="dt">PlayerData</span></span>
<span id="cb154-45"><a href="#cb154-45" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> _playerPos ::</span> <span class="dt">Int</span></span>
<span id="cb154-46"><a href="#cb154-46" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> _playerScore ::</span> <span class="dt">Int</span></span>
<span id="cb154-47"><a href="#cb154-47" aria-hidden="true" tabindex="-1"></a>    } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span>
<span id="cb154-48"><a href="#cb154-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-49"><a href="#cb154-49" aria-hidden="true" tabindex="-1"></a><span class="ot">pos ::</span> <span class="dt">Lens&#39;</span> <span class="dt">PlayerData</span> <span class="dt">Int</span></span>
<span id="cb154-50"><a href="#cb154-50" aria-hidden="true" tabindex="-1"></a>pos <span class="ot">=</span> lens _playerPos (\p x <span class="ot">-&gt;</span> p{_playerPos <span class="ot">=</span> x})</span>
<span id="cb154-51"><a href="#cb154-51" aria-hidden="true" tabindex="-1"></a><span class="ot">score ::</span> <span class="dt">Lens&#39;</span> <span class="dt">PlayerData</span> <span class="dt">Int</span></span>
<span id="cb154-52"><a href="#cb154-52" aria-hidden="true" tabindex="-1"></a>score <span class="ot">=</span> lens _playerScore (\p x <span class="ot">-&gt;</span> p{_playerScore <span class="ot">=</span> x})</span>
<span id="cb154-53"><a href="#cb154-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-54"><a href="#cb154-54" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">GameData</span> <span class="ot">=</span> <span class="dt">GameData</span></span>
<span id="cb154-55"><a href="#cb154-55" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> _die100 ::</span> <span class="dt">Int</span></span>
<span id="cb154-56"><a href="#cb154-56" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> _player1 ::</span> <span class="dt">PlayerData</span></span>
<span id="cb154-57"><a href="#cb154-57" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> _player2 ::</span> <span class="dt">PlayerData</span></span>
<span id="cb154-58"><a href="#cb154-58" aria-hidden="true" tabindex="-1"></a>    } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span>
<span id="cb154-59"><a href="#cb154-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-60"><a href="#cb154-60" aria-hidden="true" tabindex="-1"></a><span class="ot">die100 ::</span> <span class="dt">Lens&#39;</span> <span class="dt">GameData</span> <span class="dt">Int</span></span>
<span id="cb154-61"><a href="#cb154-61" aria-hidden="true" tabindex="-1"></a>die100 <span class="ot">=</span> lens _die100 (\g d <span class="ot">-&gt;</span> g{_die100 <span class="ot">=</span> d})</span>
<span id="cb154-62"><a href="#cb154-62" aria-hidden="true" tabindex="-1"></a><span class="ot">player1 ::</span> <span class="dt">Lens&#39;</span> <span class="dt">GameData</span> <span class="dt">PlayerData</span></span>
<span id="cb154-63"><a href="#cb154-63" aria-hidden="true" tabindex="-1"></a>player1 <span class="ot">=</span> lens _player1 (\g p <span class="ot">-&gt;</span> g{_player1 <span class="ot">=</span> p})</span>
<span id="cb154-64"><a href="#cb154-64" aria-hidden="true" tabindex="-1"></a><span class="ot">player2 ::</span> <span class="dt">Lens&#39;</span> <span class="dt">GameData</span> <span class="dt">PlayerData</span></span>
<span id="cb154-65"><a href="#cb154-65" aria-hidden="true" tabindex="-1"></a>player2 <span class="ot">=</span> lens _player2 (\g p <span class="ot">-&gt;</span> g{_player2 <span class="ot">=</span> p})</span>
<span id="cb154-66"><a href="#cb154-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-67"><a href="#cb154-67" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">GameA</span> a <span class="ot">=</span> <span class="dt">GameA</span> {<span class="ot"> gameStateA ::</span> <span class="dt">State</span> <span class="dt">GameData</span> a }</span>
<span id="cb154-68"><a href="#cb154-68" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>, <span class="dt">MonadState</span> <span class="dt">GameData</span>)</span>
<span id="cb154-69"><a href="#cb154-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-70"><a href="#cb154-70" aria-hidden="true" tabindex="-1"></a>select <span class="dt">Player1</span> <span class="ot">=</span> player1</span>
<span id="cb154-71"><a href="#cb154-71" aria-hidden="true" tabindex="-1"></a>select <span class="dt">Player2</span> <span class="ot">=</span> player2</span>
<span id="cb154-72"><a href="#cb154-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-73"><a href="#cb154-73" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Game</span> <span class="dt">GameA</span> <span class="kw">where</span></span>
<span id="cb154-74"><a href="#cb154-74" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Dist</span> <span class="dt">GameA</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb154-75"><a href="#cb154-75" aria-hidden="true" tabindex="-1"></a>    roll <span class="ot">=</span> <span class="kw">do</span> { x <span class="ot">&lt;-</span> die100 <span class="op">&lt;&lt;%=</span> (<span class="op">+</span> <span class="dv">1</span>);</span>
<span id="cb154-76"><a href="#cb154-76" aria-hidden="true" tabindex="-1"></a>                <span class="fu">return</span> <span class="op">$</span> x <span class="ot">`mod`</span> <span class="dv">100</span> <span class="op">+</span> <span class="dv">1</span> }</span>
<span id="cb154-77"><a href="#cb154-77" aria-hidden="true" tabindex="-1"></a>    move p i <span class="ot">=</span> modify (gscore p <span class="op">.</span> gmove p i)</span>
<span id="cb154-78"><a href="#cb154-78" aria-hidden="true" tabindex="-1"></a>    stop <span class="ot">=</span> <span class="kw">do</span> </span>
<span id="cb154-79"><a href="#cb154-79" aria-hidden="true" tabindex="-1"></a>        p1 <span class="ot">&lt;-</span> use <span class="op">$</span> player1 <span class="op">.</span> score</span>
<span id="cb154-80"><a href="#cb154-80" aria-hidden="true" tabindex="-1"></a>        p2 <span class="ot">&lt;-</span> use <span class="op">$</span> player2 <span class="op">.</span> score</span>
<span id="cb154-81"><a href="#cb154-81" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> (p1 <span class="op">&gt;=</span> <span class="dv">1000</span> <span class="op">||</span> p2 <span class="op">&gt;=</span> <span class="dv">1000</span>)</span>
<span id="cb154-82"><a href="#cb154-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-83"><a href="#cb154-83" aria-hidden="true" tabindex="-1"></a><span class="ot">runGameA ::</span> <span class="dt">Input</span> <span class="ot">-&gt;</span> <span class="dt">GameData</span></span>
<span id="cb154-84"><a href="#cb154-84" aria-hidden="true" tabindex="-1"></a>runGameA (p1, p2) <span class="ot">=</span> execState (gameStateA play)</span>
<span id="cb154-85"><a href="#cb154-85" aria-hidden="true" tabindex="-1"></a>    <span class="op">$</span> <span class="dt">GameData</span> <span class="dv">0</span> (<span class="dt">PlayerData</span> p1 <span class="dv">0</span>) (<span class="dt">PlayerData</span> p2 <span class="dv">0</span>)</span>
<span id="cb154-86"><a href="#cb154-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-87"><a href="#cb154-87" aria-hidden="true" tabindex="-1"></a>solutionA <span class="ot">=</span> output <span class="op">.</span> runGameA</span>
<span id="cb154-88"><a href="#cb154-88" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> output g <span class="ot">=</span> <span class="fu">min</span> (g <span class="op">^.</span> player1 <span class="op">.</span> score)</span>
<span id="cb154-89"><a href="#cb154-89" aria-hidden="true" tabindex="-1"></a>                         (g <span class="op">^.</span> player2 <span class="op">.</span> score)</span>
<span id="cb154-90"><a href="#cb154-90" aria-hidden="true" tabindex="-1"></a>                   <span class="op">*</span> (g <span class="op">^.</span> die100)</span>
<span id="cb154-91"><a href="#cb154-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-92"><a href="#cb154-92" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">GameState</span> <span class="ot">=</span> <span class="dt">Either</span> <span class="dt">Player</span> <span class="dt">GameData</span></span>
<span id="cb154-93"><a href="#cb154-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-94"><a href="#cb154-94" aria-hidden="true" tabindex="-1"></a><span class="ot">gmove ::</span> <span class="dt">Player</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">GameData</span> <span class="ot">-&gt;</span> <span class="dt">GameData</span></span>
<span id="cb154-95"><a href="#cb154-95" aria-hidden="true" tabindex="-1"></a>gmove p i gd <span class="ot">=</span> gd <span class="op">&amp;</span> select p <span class="op">.</span> pos <span class="op">%~</span> (\x <span class="ot">-&gt;</span> (x <span class="op">+</span> i <span class="op">-</span> <span class="dv">1</span>) <span class="ot">`mod`</span> <span class="dv">10</span> <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb154-96"><a href="#cb154-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-97"><a href="#cb154-97" aria-hidden="true" tabindex="-1"></a><span class="ot">gscore ::</span> <span class="dt">Player</span> <span class="ot">-&gt;</span> <span class="dt">GameData</span> <span class="ot">-&gt;</span> <span class="dt">GameData</span></span>
<span id="cb154-98"><a href="#cb154-98" aria-hidden="true" tabindex="-1"></a>gscore p gd <span class="ot">=</span> gd <span class="op">&amp;</span> select p <span class="op">.</span> score <span class="op">%~</span> (<span class="op">+</span> s)</span>
<span id="cb154-99"><a href="#cb154-99" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> s <span class="ot">=</span> gd <span class="op">^.</span> select p <span class="op">.</span> pos</span>
<span id="cb154-100"><a href="#cb154-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-101"><a href="#cb154-101" aria-hidden="true" tabindex="-1"></a>gwin p gd <span class="ot">=</span> <span class="kw">if</span> gd <span class="op">^.</span> select p <span class="op">.</span> score <span class="op">&gt;=</span> <span class="dv">21</span></span>
<span id="cb154-102"><a href="#cb154-102" aria-hidden="true" tabindex="-1"></a>               <span class="kw">then</span> <span class="dt">Left</span> p <span class="kw">else</span> <span class="dt">Right</span> gd</span>
<span id="cb154-103"><a href="#cb154-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-104"><a href="#cb154-104" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">GameB</span> a <span class="ot">=</span> <span class="dt">GameB</span> {<span class="ot"> gameStateB ::</span> <span class="dt">State</span> (<span class="dt">Tally</span> <span class="dt">GameState</span>) a }</span>
<span id="cb154-105"><a href="#cb154-105" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>, <span class="dt">MonadState</span> (<span class="dt">Tally</span> <span class="dt">GameState</span>))</span>
<span id="cb154-106"><a href="#cb154-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-107"><a href="#cb154-107" aria-hidden="true" tabindex="-1"></a><span class="ot">solve ::</span> <span class="dt">Player</span> <span class="ot">-&gt;</span> <span class="dt">Tally</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">GameState</span> <span class="ot">-&gt;</span> <span class="dt">Tally</span> <span class="dt">GameState</span></span>
<span id="cb154-108"><a href="#cb154-108" aria-hidden="true" tabindex="-1"></a>solve p _ g<span class="op">@</span>(<span class="dt">Left</span> _) <span class="ot">=</span> Tally.singleton g</span>
<span id="cb154-109"><a href="#cb154-109" aria-hidden="true" tabindex="-1"></a>solve p i (<span class="dt">Right</span> gd) <span class="ot">=</span> Tally.cmap (\i <span class="ot">-&gt;</span> gwin p <span class="op">$</span> gscore p <span class="op">$</span> gmove p i gd) i</span>
<span id="cb154-110"><a href="#cb154-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-111"><a href="#cb154-111" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Game</span> <span class="dt">GameB</span> <span class="kw">where</span></span>
<span id="cb154-112"><a href="#cb154-112" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Dist</span> <span class="dt">GameB</span> <span class="ot">=</span> <span class="dt">Tally</span> <span class="dt">Int</span></span>
<span id="cb154-113"><a href="#cb154-113" aria-hidden="true" tabindex="-1"></a>    roll <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> Tally.fromList [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb154-114"><a href="#cb154-114" aria-hidden="true" tabindex="-1"></a>    move p i <span class="ot">=</span> modify (Tally.cbind (solve p i))</span>
<span id="cb154-115"><a href="#cb154-115" aria-hidden="true" tabindex="-1"></a>    stop <span class="ot">=</span> gets (<span class="fu">all</span> isLeft <span class="op">.</span> Tally.distinct)</span>
<span id="cb154-116"><a href="#cb154-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-117"><a href="#cb154-117" aria-hidden="true" tabindex="-1"></a><span class="ot">runGameB ::</span> <span class="dt">Input</span> <span class="ot">-&gt;</span> <span class="dt">Tally</span> <span class="dt">GameState</span></span>
<span id="cb154-118"><a href="#cb154-118" aria-hidden="true" tabindex="-1"></a>runGameB (p1, p2) <span class="ot">=</span> execState (gameStateB play)</span>
<span id="cb154-119"><a href="#cb154-119" aria-hidden="true" tabindex="-1"></a>    <span class="op">$</span> Tally.singleton <span class="op">$</span> <span class="dt">Right</span></span>
<span id="cb154-120"><a href="#cb154-120" aria-hidden="true" tabindex="-1"></a>    <span class="op">$</span> <span class="dt">GameData</span> <span class="dv">0</span> (<span class="dt">PlayerData</span> p1 <span class="dv">0</span>) (<span class="dt">PlayerData</span> p2 <span class="dv">0</span>)</span>
<span id="cb154-121"><a href="#cb154-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-122"><a href="#cb154-122" aria-hidden="true" tabindex="-1"></a>solutionB <span class="ot">=</span> runGameB</span>
<span id="cb154-123"><a href="#cb154-123" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«tally»</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Integral</span> n) <span class="ot">=&gt;</span> <span class="dt">Num</span> (<span class="dt">Tally</span> n) <span class="kw">where</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a>    (<span class="op">+</span>) <span class="ot">=</span> cliftA2 (<span class="op">+</span>)</span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a>    (<span class="op">-</span>) <span class="ot">=</span> cliftA2 (<span class="op">-</span>)</span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a>    (<span class="op">*</span>) <span class="ot">=</span> cliftA2 (<span class="op">*</span>)</span>
<span id="cb155-5"><a href="#cb155-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">negate</span> <span class="ot">=</span> cmap <span class="fu">negate</span></span>
<span id="cb155-6"><a href="#cb155-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">abs</span> <span class="ot">=</span> cmap <span class="fu">abs</span></span>
<span id="cb155-7"><a href="#cb155-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fromInteger</span> <span class="ot">=</span> singleton <span class="op">.</span> <span class="fu">fromInteger</span></span>
<span id="cb155-8"><a href="#cb155-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">signum</span> <span class="ot">=</span> cmap <span class="fu">signum</span></span></code></pre></div>
</div>
</section>
<section id="day-22-reactor-reboot" class="level1">
<h1>Day 22: Reactor Reboot</h1>
<div class="named-code-block">
<p>file:app/Day22.hs</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day22</span> <span class="kw">where</span></span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Linear.V3</span> (<span class="dt">V3</span>(..), _x, _y, _z)</span>
<span id="cb156-6"><a href="#cb156-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parsing</span></span>
<span id="cb156-7"><a href="#cb156-7" aria-hidden="true" tabindex="-1"></a>    ( <span class="dt">Parser</span>, integer, lexeme, readInputParsing, eol, string, sepEndBy1 )</span>
<span id="cb156-8"><a href="#cb156-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-9"><a href="#cb156-9" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>parser<span class="op">-</span>day22<span class="op">&gt;&gt;</span></span>
<span id="cb156-10"><a href="#cb156-10" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>solution<span class="op">-</span>day22<span class="op">&gt;&gt;</span></span>
<span id="cb156-11"><a href="#cb156-11" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>run<span class="op">-</span>solutions<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«parser-day22»</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">V3Range</span> <span class="ot">=</span> (<span class="dt">V3</span> <span class="dt">Int</span>, <span class="dt">V3</span> <span class="dt">Int</span>)</span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Command</span> <span class="ot">=</span> <span class="dt">CommandOn</span> <span class="op">|</span> <span class="dt">CommandOff</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Bounded</span>, <span class="dt">Enum</span>)</span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Input</span> <span class="ot">=</span> [(<span class="dt">Command</span>, <span class="dt">V3Range</span>)]</span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true" tabindex="-1"></a><span class="ot">intRangeP ::</span> <span class="dt">Parser</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb157-6"><a href="#cb157-6" aria-hidden="true" tabindex="-1"></a>intRangeP <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> integer <span class="op">&lt;*</span> string <span class="st">&quot;..&quot;</span> <span class="op">&lt;*&gt;</span> integer</span>
<span id="cb157-7"><a href="#cb157-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-8"><a href="#cb157-8" aria-hidden="true" tabindex="-1"></a><span class="ot">rangeP ::</span> <span class="dt">Parser</span> (<span class="dt">Command</span>, <span class="dt">V3Range</span>)</span>
<span id="cb157-9"><a href="#cb157-9" aria-hidden="true" tabindex="-1"></a>rangeP <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> lexeme (<span class="dt">CommandOn</span> <span class="op">&lt;$</span> string <span class="st">&quot;on&quot;</span> <span class="op">&lt;|&gt;</span> (<span class="dt">CommandOff</span> <span class="op">&lt;$</span> string <span class="st">&quot;off&quot;</span>))</span>
<span id="cb157-10"><a href="#cb157-10" aria-hidden="true" tabindex="-1"></a>             <span class="op">&lt;*&gt;</span> (<span class="kw">do</span></span>
<span id="cb157-11"><a href="#cb157-11" aria-hidden="true" tabindex="-1"></a>                    (xmin, xmax) <span class="ot">&lt;-</span> string <span class="st">&quot;x=&quot;</span> <span class="op">*&gt;</span> intRangeP</span>
<span id="cb157-12"><a href="#cb157-12" aria-hidden="true" tabindex="-1"></a>                    string <span class="st">&quot;,&quot;</span></span>
<span id="cb157-13"><a href="#cb157-13" aria-hidden="true" tabindex="-1"></a>                    (ymin, ymax) <span class="ot">&lt;-</span> string <span class="st">&quot;y=&quot;</span> <span class="op">*&gt;</span> intRangeP</span>
<span id="cb157-14"><a href="#cb157-14" aria-hidden="true" tabindex="-1"></a>                    string <span class="st">&quot;,&quot;</span></span>
<span id="cb157-15"><a href="#cb157-15" aria-hidden="true" tabindex="-1"></a>                    (zmin, zmax) <span class="ot">&lt;-</span> string <span class="st">&quot;z=&quot;</span> <span class="op">*&gt;</span> intRangeP</span>
<span id="cb157-16"><a href="#cb157-16" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">return</span> (<span class="dt">V3</span> xmin ymin zmin, <span class="dt">V3</span> xmax ymax zmax))</span>
<span id="cb157-17"><a href="#cb157-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-18"><a href="#cb157-18" aria-hidden="true" tabindex="-1"></a><span class="ot">inputP ::</span> <span class="dt">Parser</span> <span class="dt">Input</span></span>
<span id="cb157-19"><a href="#cb157-19" aria-hidden="true" tabindex="-1"></a>inputP <span class="ot">=</span> rangeP <span class="ot">`sepEndBy1`</span> eol</span>
<span id="cb157-20"><a href="#cb157-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-21"><a href="#cb157-21" aria-hidden="true" tabindex="-1"></a><span class="ot">readInput ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env <span class="dt">Input</span></span>
<span id="cb157-22"><a href="#cb157-22" aria-hidden="true" tabindex="-1"></a>readInput <span class="ot">=</span> readInputParsing <span class="st">&quot;data/day22.txt&quot;</span> inputP</span></code></pre></div>
</div>
<div class="named-code-block">
<p>«solution-day22»</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Range</span> a <span class="kw">where</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    intersect ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a><span class="ot">(=/=) ::</span> (<span class="dt">Range</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a>(<span class="op">=/=</span>) <span class="ot">=</span> intersect</span>
<span id="cb158-6"><a href="#cb158-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-7"><a href="#cb158-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Range</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="kw">where</span></span>
<span id="cb158-8"><a href="#cb158-8" aria-hidden="true" tabindex="-1"></a>    intersect (a1, a2) (b1, b2)</span>
<span id="cb158-9"><a href="#cb158-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> b1 <span class="op">&gt;</span> a2 <span class="op">||</span> a1 <span class="op">&gt;</span> b2 <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb158-10"><a href="#cb158-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> b1 <span class="op">&gt;=</span> a1 <span class="op">&amp;&amp;</span> b2 <span class="op">&gt;=</span> a2 <span class="ot">=</span> <span class="dt">Just</span> (b1, a2)</span>
<span id="cb158-11"><a href="#cb158-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> a1 <span class="op">&gt;=</span> b1 <span class="op">&amp;&amp;</span> a2 <span class="op">&gt;=</span> b2 <span class="ot">=</span> <span class="dt">Just</span> (a1, b2)</span>
<span id="cb158-12"><a href="#cb158-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> b1 <span class="op">&gt;=</span> a1 <span class="op">&amp;&amp;</span> b2 <span class="op">&lt;=</span> a2 <span class="ot">=</span> <span class="dt">Just</span> (b1, b2)</span>
<span id="cb158-13"><a href="#cb158-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> a1 <span class="op">&gt;=</span> b1 <span class="op">&amp;&amp;</span> a2 <span class="op">&lt;=</span> b2 <span class="ot">=</span> <span class="dt">Just</span> (a1, a2)</span>
<span id="cb158-14"><a href="#cb158-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;no known configuration: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> ((a1, a2), (b1, b2))</span>
<span id="cb158-15"><a href="#cb158-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-16"><a href="#cb158-16" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Range</span> (<span class="dt">V3</span> <span class="dt">Int</span>, <span class="dt">V3</span> <span class="dt">Int</span>) <span class="kw">where</span></span>
<span id="cb158-17"><a href="#cb158-17" aria-hidden="true" tabindex="-1"></a>    intersect (a1, a2) (b1, b2) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb158-18"><a href="#cb158-18" aria-hidden="true" tabindex="-1"></a>        (x1, x2) <span class="ot">&lt;-</span> intersect (a1 <span class="op">^.</span> _x, a2 <span class="op">^.</span> _x) (b1 <span class="op">^.</span> _x, b2 <span class="op">^.</span> _x)</span>
<span id="cb158-19"><a href="#cb158-19" aria-hidden="true" tabindex="-1"></a>        (y1, y2) <span class="ot">&lt;-</span> intersect (a1 <span class="op">^.</span> _y, a2 <span class="op">^.</span> _y) (b1 <span class="op">^.</span> _y, b2 <span class="op">^.</span> _y)</span>
<span id="cb158-20"><a href="#cb158-20" aria-hidden="true" tabindex="-1"></a>        (z1, z2) <span class="ot">&lt;-</span> intersect (a1 <span class="op">^.</span> _z, a2 <span class="op">^.</span> _z) (b1 <span class="op">^.</span> _z, b2 <span class="op">^.</span> _z)</span>
<span id="cb158-21"><a href="#cb158-21" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> (<span class="dt">V3</span> x1 y1 z1, <span class="dt">V3</span> x2 y2 z2)</span>
<span id="cb158-22"><a href="#cb158-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-23"><a href="#cb158-23" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">MultiRange</span> r <span class="ot">=</span> <span class="dt">MultiRange</span> {<span class="ot"> toList ::</span> [(r, <span class="dt">Int</span>)] }</span>
<span id="cb158-24"><a href="#cb158-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb158-25"><a href="#cb158-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-26"><a href="#cb158-26" aria-hidden="true" tabindex="-1"></a><span class="ot">(=+=) ::</span> <span class="dt">Range</span> r <span class="ot">=&gt;</span> <span class="dt">MultiRange</span> r <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> <span class="dt">MultiRange</span> r</span>
<span id="cb158-27"><a href="#cb158-27" aria-hidden="true" tabindex="-1"></a>(<span class="dt">MultiRange</span> m) <span class="op">=+=</span> r <span class="ot">=</span> <span class="dt">MultiRange</span> <span class="op">$</span> (r, <span class="dv">1</span>) <span class="op">:</span> (mapMaybe isect m <span class="op">&lt;&gt;</span> m)</span>
<span id="cb158-28"><a href="#cb158-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> isect (s, m) <span class="ot">=</span> (, <span class="fu">negate</span> m) <span class="op">&lt;$&gt;</span> (s <span class="op">=/=</span> r)</span>
<span id="cb158-29"><a href="#cb158-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-30"><a href="#cb158-30" aria-hidden="true" tabindex="-1"></a><span class="ot">(=-=) ::</span> <span class="dt">Range</span> r <span class="ot">=&gt;</span> <span class="dt">MultiRange</span> r <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> <span class="dt">MultiRange</span> r</span>
<span id="cb158-31"><a href="#cb158-31" aria-hidden="true" tabindex="-1"></a>(<span class="dt">MultiRange</span> m) <span class="op">=-=</span> r <span class="ot">=</span> <span class="dt">MultiRange</span> <span class="op">$</span> mapMaybe isect m <span class="op">&lt;&gt;</span> m</span>
<span id="cb158-32"><a href="#cb158-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> isect (s, m) <span class="ot">=</span> (, <span class="fu">negate</span> m) <span class="op">&lt;$&gt;</span> (s <span class="op">=/=</span> r)</span>
<span id="cb158-33"><a href="#cb158-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-34"><a href="#cb158-34" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionA ::</span> <span class="dt">Input</span> <span class="ot">-&gt;</span> <span class="dt">MultiRange</span> (<span class="dt">V3</span> <span class="dt">Int</span>, <span class="dt">V3</span> <span class="dt">Int</span>)</span>
<span id="cb158-35"><a href="#cb158-35" aria-hidden="true" tabindex="-1"></a>solutionA <span class="ot">=</span> foldl&#39; switch (<span class="dt">MultiRange</span> []) <span class="op">.</span> <span class="fu">filter</span> (small <span class="op">.</span> <span class="fu">snd</span>)</span>
<span id="cb158-36"><a href="#cb158-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> switch m (<span class="dt">CommandOn</span>, r) <span class="ot">=</span> m <span class="op">=+=</span> r</span>
<span id="cb158-37"><a href="#cb158-37" aria-hidden="true" tabindex="-1"></a>          switch m (<span class="dt">CommandOff</span>, r) <span class="ot">=</span> m <span class="op">=-=</span> r</span>
<span id="cb158-38"><a href="#cb158-38" aria-hidden="true" tabindex="-1"></a>          small (a, b) <span class="ot">=</span> <span class="fu">all</span> ((<span class="op">&lt;=</span><span class="dv">50</span>) <span class="op">.</span> <span class="fu">abs</span>) a <span class="op">&amp;&amp;</span> <span class="fu">all</span> ((<span class="op">&lt;=</span><span class="dv">50</span>) <span class="op">.</span> <span class="fu">abs</span>) b</span>
<span id="cb158-39"><a href="#cb158-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-40"><a href="#cb158-40" aria-hidden="true" tabindex="-1"></a><span class="ot">solutionB ::</span> b <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb158-41"><a href="#cb158-41" aria-hidden="true" tabindex="-1"></a>solutionB <span class="ot">=</span> <span class="fu">const</span> <span class="dv">0</span></span></code></pre></div>
</div>
</section>
<section id="appendix-boiler-plate" class="level1">
<h1>Appendix: Boiler plate</h1>
<div class="named-code-block">
<p>«run-solutions»</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runA ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env ()</span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a>runA <span class="ot">=</span> readInput <span class="op">&gt;&gt;=</span> logInfo <span class="op">.</span> display <span class="op">.</span> tshow <span class="op">.</span> solutionA</span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a><span class="ot">runB ::</span> (<span class="dt">HasLogFunc</span> env) <span class="ot">=&gt;</span> <span class="dt">RIO</span> env ()</span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true" tabindex="-1"></a>runB <span class="ot">=</span> readInput <span class="op">&gt;&gt;=</span> logInfo <span class="op">.</span> display <span class="op">.</span> tshow <span class="op">.</span> solutionB</span></code></pre></div>
</div>
</section>
<section id="appendix-output" class="level1">
<h1>Appendix: Output</h1>
<p>RIO is missing easy functions for standard output, it’s a bit principled in that regard.</p>
<div class="named-code-block">
<p>file:app/Print.hs</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Print</span> <span class="kw">where</span></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.ByteString</span> (putStr)</span>
<span id="cb160-6"><a href="#cb160-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Massiv.Array</span> (<span class="dt">Ix2</span>(..))</span>
<span id="cb160-7"><a href="#cb160-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-8"><a href="#cb160-8" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span><span class="ot"> ::</span> (<span class="dt">MonadIO</span> m) <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> m ()</span>
<span id="cb160-9"><a href="#cb160-9" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span> <span class="ot">=</span> <span class="fu">putStr</span> <span class="op">.</span> Text.encodeUtf8</span>
<span id="cb160-10"><a href="#cb160-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-11"><a href="#cb160-11" aria-hidden="true" tabindex="-1"></a><span class="ot">printLn ::</span> (<span class="dt">MonadIO</span> m) <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> m ()</span>
<span id="cb160-12"><a href="#cb160-12" aria-hidden="true" tabindex="-1"></a>printLn <span class="ot">=</span> <span class="fu">print</span> <span class="op">.</span> (<span class="op">&lt;&gt;</span> <span class="st">&quot;\n&quot;</span>) </span>
<span id="cb160-13"><a href="#cb160-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-14"><a href="#cb160-14" aria-hidden="true" tabindex="-1"></a><span class="ot">printCoords ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> [<span class="dt">Ix2</span>] <span class="ot">-&gt;</span> m ()</span>
<span id="cb160-15"><a href="#cb160-15" aria-hidden="true" tabindex="-1"></a>printCoords <span class="ot">=</span> <span class="fu">mapM_</span> (\(x <span class="op">:.</span> y) <span class="ot">-&gt;</span> printLn <span class="op">$</span> tshow x <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> tshow y)</span></code></pre></div>
</div>
</section>
<section id="appendix-parsing" class="level1">
<h1>Appendix: Parsing</h1>
<div class="named-code-block">
<p>file:app/Parsing.hs</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Parsing</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>    ( <span class="dt">Parser</span>, hspace, string, char, readInputParsing, lexeme</span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>    , integer, eol, sepEndBy1, sepBy1, failOnException, digit</span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a>    , digitArray, dropUntilEol )</span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO</span></span>
<span id="cb161-8"><a href="#cb161-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RIO.Char</span> (ord, <span class="dt">GeneralCategory</span>(<span class="dt">LineSeparator</span>), generalCategory)</span>
<span id="cb161-9"><a href="#cb161-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Set</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb161-10"><a href="#cb161-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">RIO.Text</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb161-11"><a href="#cb161-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-12"><a href="#cb161-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span></span>
<span id="cb161-13"><a href="#cb161-13" aria-hidden="true" tabindex="-1"></a>    ( <span class="dt">ParseErrorBundle</span>, <span class="dt">Parsec</span>, parse, errorBundlePretty, sepEndBy1</span>
<span id="cb161-14"><a href="#cb161-14" aria-hidden="true" tabindex="-1"></a>    , sepBy1, fancyFailure, <span class="dt">ErrorFancy</span>(<span class="op">..</span>), takeWhileP )</span>
<span id="cb161-15"><a href="#cb161-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span> (hspace, string, char, eol)</span>
<span id="cb161-16"><a href="#cb161-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Megaparsec.Char</span> <span class="kw">as</span> <span class="dt">C</span></span>
<span id="cb161-17"><a href="#cb161-17" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Megaparsec.Char.Lexer</span> <span class="kw">as</span> <span class="dt">L</span></span>
<span id="cb161-18"><a href="#cb161-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-19"><a href="#cb161-19" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Massiv.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb161-20"><a href="#cb161-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-21"><a href="#cb161-21" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Text</span></span>
<span id="cb161-22"><a href="#cb161-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-23"><a href="#cb161-23" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Display</span> (<span class="dt">ParseErrorBundle</span> <span class="dt">Text</span> <span class="dt">Void</span>) <span class="kw">where</span></span>
<span id="cb161-24"><a href="#cb161-24" aria-hidden="true" tabindex="-1"></a>    textDisplay <span class="ot">=</span> Text.pack <span class="op">.</span> errorBundlePretty</span>
<span id="cb161-25"><a href="#cb161-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-26"><a href="#cb161-26" aria-hidden="true" tabindex="-1"></a><span class="ot">failOnException ::</span> (<span class="dt">Exception</span> e) <span class="ot">=&gt;</span> <span class="dt">Either</span> e a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb161-27"><a href="#cb161-27" aria-hidden="true" tabindex="-1"></a>failOnException <span class="ot">=</span> <span class="fu">either</span> convertError <span class="fu">return</span></span>
<span id="cb161-28"><a href="#cb161-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> convertError <span class="ot">=</span> fancyFailure <span class="op">.</span> Set.singleton</span>
<span id="cb161-29"><a href="#cb161-29" aria-hidden="true" tabindex="-1"></a>                       <span class="op">.</span> <span class="dt">ErrorFail</span> <span class="op">.</span> displayException</span>
<span id="cb161-30"><a href="#cb161-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-31"><a href="#cb161-31" aria-hidden="true" tabindex="-1"></a><span class="ot">readInputParsing ::</span> (<span class="dt">MonadReader</span> env m, <span class="dt">MonadIO</span> m, <span class="dt">HasLogFunc</span> env)</span>
<span id="cb161-32"><a href="#cb161-32" aria-hidden="true" tabindex="-1"></a>                 <span class="ot">=&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> m a</span>
<span id="cb161-33"><a href="#cb161-33" aria-hidden="true" tabindex="-1"></a>readInputParsing file p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb161-34"><a href="#cb161-34" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">&lt;-</span> parse p file <span class="op">&lt;$&gt;</span> readFileUtf8 file</span>
<span id="cb161-35"><a href="#cb161-35" aria-hidden="true" tabindex="-1"></a>    <span class="fu">either</span> (\e <span class="ot">-&gt;</span> <span class="kw">do</span> { logError <span class="op">$</span> display e; exitFailure })</span>
<span id="cb161-36"><a href="#cb161-36" aria-hidden="true" tabindex="-1"></a>           <span class="fu">return</span> x</span>
<span id="cb161-37"><a href="#cb161-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-38"><a href="#cb161-38" aria-hidden="true" tabindex="-1"></a><span class="ot">lexeme ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb161-39"><a href="#cb161-39" aria-hidden="true" tabindex="-1"></a>lexeme <span class="ot">=</span> L.lexeme hspace</span>
<span id="cb161-40"><a href="#cb161-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-41"><a href="#cb161-41" aria-hidden="true" tabindex="-1"></a><span class="ot">integer ::</span> <span class="dt">Parser</span> <span class="dt">Int</span></span>
<span id="cb161-42"><a href="#cb161-42" aria-hidden="true" tabindex="-1"></a>integer <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb161-43"><a href="#cb161-43" aria-hidden="true" tabindex="-1"></a>    sign_ <span class="ot">&lt;-</span> <span class="fu">maybe</span> <span class="dv">1</span> (<span class="fu">const</span> (<span class="op">-</span><span class="dv">1</span>)) <span class="op">&lt;$&gt;</span> optional (char <span class="ch">&#39;-&#39;</span>)</span>
<span id="cb161-44"><a href="#cb161-44" aria-hidden="true" tabindex="-1"></a>    abs_  <span class="ot">&lt;-</span> lexeme L.decimal</span>
<span id="cb161-45"><a href="#cb161-45" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (sign_ <span class="op">*</span> abs_)</span>
<span id="cb161-46"><a href="#cb161-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-47"><a href="#cb161-47" aria-hidden="true" tabindex="-1"></a><span class="ot">digit ::</span> <span class="dt">Parser</span> <span class="dt">Int</span></span>
<span id="cb161-48"><a href="#cb161-48" aria-hidden="true" tabindex="-1"></a>digit <span class="ot">=</span> toValue <span class="op">&lt;$&gt;</span> C.digitChar</span>
<span id="cb161-49"><a href="#cb161-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> toValue c <span class="ot">=</span> <span class="fu">ord</span> c <span class="op">-</span> <span class="fu">ord</span> <span class="ch">&#39;0&#39;</span></span>
<span id="cb161-50"><a href="#cb161-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-51"><a href="#cb161-51" aria-hidden="true" tabindex="-1"></a><span class="ot">dropUntilEol ::</span> <span class="dt">Parser</span> ()</span>
<span id="cb161-52"><a href="#cb161-52" aria-hidden="true" tabindex="-1"></a>dropUntilEol <span class="ot">=</span> void <span class="op">$</span> takeWhileP (<span class="dt">Just</span> <span class="st">&quot;reading to eol&quot;</span>)</span>
<span id="cb161-53"><a href="#cb161-53" aria-hidden="true" tabindex="-1"></a>                                 (<span class="op">/=</span> <span class="ch">&#39;\n&#39;</span>)</span>
<span id="cb161-54"><a href="#cb161-54" aria-hidden="true" tabindex="-1"></a>                    <span class="op">&gt;&gt;</span> eol</span>
<span id="cb161-55"><a href="#cb161-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-56"><a href="#cb161-56" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>digit<span class="op">-</span>array<span class="op">-</span>parser<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
</section>
        </div>
         <div class="col-3 col-s-3 menu" id="menu">
                <nav id="TOC" role="doc-toc">
                                <h2 id="toc-title">Contents</h2>
                                <ul>
                                <li><a href="#advent-of-code-2021">Advent of Code 2021</a></li>
                                <li><a href="#day-1-sonar-sweep">Day 1: Sonar Sweep</a></li>
                                <li><a href="#day-2-dive">Day 2: Dive!</a></li>
                                <li><a href="#day-3-binary-diagnostic">Day 3: Binary Diagnostic</a></li>
                                <li><a href="#day-4-giant-squid">Day 4: Giant Squid</a></li>
                                <li><a href="#day-5-hydrothermal-venture">Day 5: Hydrothermal Venture</a></li>
                                <li><a href="#day-6-lanternfish">Day 6: Lanternfish</a></li>
                                <li><a href="#day-7-the-treachery-of-whales">Day 7: The Treachery of Whales</a></li>
                                <li><a href="#day-8-seven-segment-search">Day 8: Seven Segment Search</a></li>
                                <li><a href="#day-9-smoke-basin">Day 9: Smoke Basin</a></li>
                                <li><a href="#day-10-syntax-scoring">Day 10: Syntax Scoring</a></li>
                                <li><a href="#day-11-dumbo-octopus">Day 11: Dumbo Octopus</a></li>
                                <li><a href="#day-12-passage-pathing">Day 12: Passage Pathing</a></li>
                                <li><a href="#day-13-transparent-origami">Day 13: Transparent Origami</a></li>
                                <li><a href="#day-14-extended-polymerization">Day 14: Extended Polymerization</a></li>
                                <li><a href="#day-15-chiton">Day 15: Chiton</a></li>
                                <li><a href="#day-16-packet-decoder">Day 16: Packet Decoder</a></li>
                                <li><a href="#day-17-trick-shot">Day 17: Trick Shot</a></li>
                                <li><a href="#day-18-snailfish">Day 18: Snailfish</a></li>
                                <li><a href="#day-19-beacon-scanner">Day 19: Beacon Scanner</a></li>
                                <li><a href="#day-20-trench-map">Day 20: Trench Map</a></li>
                                <li><a href="#day-21-dirac-dice">Day 21: Dirac Dice</a></li>
                                <li><a href="#day-22-reactor-reboot">Day 22: Reactor Reboot</a></li>
                                <li><a href="#appendix-boiler-plate">Appendix: Boiler plate</a></li>
                                <li><a href="#appendix-output">Appendix: Output</a></li>
                                <li><a href="#appendix-parsing">Appendix: Parsing</a></li>
                                </ul>
                </nav>
        </div> 
</div>
<div class="footer">
</div>
</body>
<!-- This script scrolls the page to top when a link in the TOC is clicked. -->
<script>
   var elems = document.getElementById("TOC").querySelectorAll("a");
   for (var i = 0; i < elems.length; ++i) {
      elems[i].addEventListener("click", clickFunc);
   }
   function clickFunc(e) {
      e.preventDefault();
      window.location.hash = this.hash;
      window.scrollTo(0, 0); 
   }
</script>
   <!-- Set the default landing page. Sections are set display: none by default
        except for the one that is currently the location hash. -->
   <script type="text/javascript">
           if (document.location.hash == "" || document.location.hash == "#") {
                document.location.hash = "#advent-of-code-2021";
                window.scrollTo(0, 0); 
           }
  </script>
</html>
